//! FrankenTUI (ftui) application model for cass TUI.
//!
//! Defines the Elm-architecture types: [`CassApp`] (Model), [`CassMsg`] (Message),
//! and service trait boundaries.  This module is the foundational type definition
//! that all subsequent ftui feature work builds on (bead 2noh9.2.2).
//!
//! # Architecture
//!
//! ```text
//!   Event (key/mouse/resize/tick)
//!        │
//!        ▼
//!   CassMsg (from Event)
//!        │
//!        ▼
//!   CassApp::update(&mut self, msg) -> Cmd<CassMsg>
//!        │
//!        ├── Pure state transition  → Cmd::none()
//!        ├── Async search           → Cmd::task(SearchService::execute)
//!        ├── Spawn editor           → Cmd::task(EditorService::open)
//!        ├── Export                  → Cmd::task(ExportService::export)
//!        └── Persist state          → Cmd::save_state()
//!
//!   CassApp::view(&self, frame)
//!        │
//!        ▼
//!   Renders current state to ftui Frame
//! ```
//!
//! # FrankenTUI UX Overhaul (1mfw3)
//!
//! This module underwent a comprehensive UX overhaul migrating from ratatui to ftui
//! (a custom Elm-architecture framework). Key subsystems introduced:
//!
//! ## Command Palette
//!
//! Keyboard-first action dispatch via Ctrl+P / Alt+P. The palette provides fuzzy
//! search over ~28 action variants grouped into 7 categories (Chrome, Filter, View,
//! Analytics, Export, Recording, Sources). Filtering uses Bayesian-scored matching
//! with six modes (All/Exact/Prefix/WordStart/Substring/Fuzzy) cycled via F9.
//! See [`PaletteState`] in `components/palette.rs` for state, and
//! [`PaletteLatencyStats`] for query performance instrumentation.
//!
//! **Design tradeoff**: Bayesian scoring adds ~50μs per keystroke but produces
//! significantly better ranking than simple substring matching. The latency budget
//! indicator (OK <200μs, WARN <1000μs, SLOW ≥1000μs) keeps this measurable.
//! Alt+B toggles a micro-bench overlay showing queries/second throughput.
//!
//! ## Responsive Layout
//!
//! Terminal width drives [`LayoutBreakpoint`] (Narrow <80, MediumNarrow 80-119,
//! Medium 120-159, Wide ≥160). Each breakpoint maps to concrete topology contracts:
//! - [`SearchTopology`]: pane widths, split handle, dual-pane toggle
//! - [`AnalyticsTopology`]: tab bar, filter summary, header rows, footer hints
//! - [`VisibilityPolicy`]: theme label, hint slots/budget, saved-view path length
//!
//! Ultra-narrow terminals (<30 cols or <6 rows) get a "terminal too small" fallback
//! rather than a broken layout.
//!
//! ## Analytics Explorer
//!
//! Seven views under [`AnalyticsView`]: Dashboard, Explorer, Heatmap, Breakdowns,
//! Tools, Plans, Coverage. The Explorer view supports interactive cycling of:
//! - [`ExplorerMetric`] (m/M): ApiTokens, ContentTokens, Messages, ToolCalls, etc.
//! - [`ExplorerOverlay`] (o): None, ByAgent, ByWorkspace, BySource
//! - [`ExplorerZoom`] (z/Z): All, 24h, 7d, 30d, 90d
//! - GroupBy (g/G): Hour, Day, Week, Month
//!
//! Chart data is pre-computed via `load_chart_data()` in `analytics_charts.rs`.
//!
//! ## Inspector & Diagnostics
//!
//! Ctrl+Shift+I opens the inspector overlay with 7 tabs ([`InspectorTab`]):
//! Timing, Layout, HitRegions, Resize, Diff, Budget, Timeline. Each tab renders
//! from [`EvidenceSnapshots`], which are updated per-tick from ftui's evidence
//! telemetry rather than re-parsing log files at render time.
//!
//! [`FrameTimingStats`] maintains a rolling ring buffer of frame durations for
//! FPS calculation and jitter detection.
//!
//! ## Theme Editor
//!
//! Ctrl+Shift+T opens [`ThemeEditorState`] — a modal editor for 19 color slots
//! ([`ThemeColorSlot`]). Supports hex input, preset cycling, WCAG contrast warnings,
//! and export-to-disk. Changes apply live and revert on cancel.
//!
//! ## Key Bindings
//!
//! Modal interceptors form a priority stack: theme editor > inspector > palette >
//! normal key handling. When a modal is open, it captures all input except its own
//! dismiss/close messages, which must be explicitly passed through (not swallowed
//! by `_ => Cmd::none()` wildcards).
//!
//! ## Test Coverage
//!
//! - 532 unit tests in this module (palette, latency, responsive, inspector, etc.)
//! - 59 unit tests in `components/palette.rs`
//! - 74 cross-workstream integration tests in `tests/cross_workstream_integration.rs`
//! - Key regression suites: palette lifecycle, dispatch coverage for all 28 action
//!   variants, responsive SIZE_MATRIX (16 entries), perf envelope checks

use std::cell::{Cell, RefCell};
use std::collections::{BTreeSet, HashMap, HashSet, VecDeque};
use std::path::{Path, PathBuf};
use std::process::Command as StdCommand;
use std::sync::Arc;
use std::time::{Duration, Instant};

use ftui::runtime::input_macro::{MacroPlayback, MacroRecorder};

use crate::model::types::MessageRole;
use crate::search::model_manager::SemanticAvailability;
use crate::search::query::{MatchType, QuerySuggestion, SearchFilters, SearchHit, SearchMode};
use crate::sources::provenance::SourceFilter;
use crate::storage::sqlite::SqliteStorage;
use crate::ui::components::export_modal::{ExportField, ExportModalState, ExportProgress};
use crate::ui::components::palette::{
    AnalyticsTarget, InputModeTarget, PaletteMatchMode, PaletteResult, PaletteState,
    ScreenshotTarget, TimeFilterPreset, action_by_id, action_id, default_actions, execute_selected,
};
use crate::ui::components::pills::Pill;
use crate::ui::components::toast::ToastManager;
use crate::ui::data::{
    BudgetHealthContract, CockpitState, ConversationView, DiffStrategyContract, InputMode,
    ResizeRegimeContract, format_time_short, load_conversation,
};
use crate::ui::shortcuts;
use crate::ui::time_parser::parse_time_input;
use crate::update_check::{UpdateInfo, open_in_browser, skip_version};
#[cfg(not(test))]
use crate::update_check::{run_self_update, spawn_update_check};
use ftui::widgets::Widget;
use ftui::widgets::block::{Alignment, Block};
use ftui::widgets::borders::{BorderType, Borders};
use ftui::widgets::command_palette::{ActionItem, CommandPalette, MatchFilter};
use ftui::widgets::help_registry::{HelpContent, HelpId, HelpRegistry, Keybinding};
use ftui::widgets::hint_ranker::{HintContext, HintRanker, RankerConfig};
use ftui::widgets::json_view::{JsonToken, JsonView};
use ftui::widgets::paragraph::Paragraph;
use ftui::widgets::{RenderItem, StatefulWidget, VirtualizedList, VirtualizedListState};
use ftui_extras::markdown::{MarkdownRenderer, is_likely_markdown};

// ---------------------------------------------------------------------------
// Re-export ftui primitives through the adapter
// ---------------------------------------------------------------------------
use super::ftui_adapter::{Constraint, Flex, Rect};
use super::style_system::{self, StyleContext, StyleOptions, UiThemePreset};
use ftui::widgets::InspectorState;
use ftui::widgets::focus::{FocusId, FocusManager, FocusNode, NavDirection};

/// Well-known focus node IDs for the cass TUI layout.
pub mod focus_ids {
    use super::FocusId;
    // Primary surface nodes (tab order 0-2)
    pub const SEARCH_BAR: FocusId = 1;
    pub const RESULTS_LIST: FocusId = 2;
    pub const DETAIL_PANE: FocusId = 3;
    // Modal nodes (tab_index -1 = skip global tab order)
    pub const COMMAND_PALETTE: FocusId = 10;
    pub const HELP_OVERLAY: FocusId = 11;
    pub const EXPORT_MODAL: FocusId = 12;
    pub const CONSENT_DIALOG: FocusId = 13;
    pub const BULK_MODAL: FocusId = 14;
    pub const SAVED_VIEWS_MODAL: FocusId = 15;
    pub const SOURCE_FILTER_MENU: FocusId = 16;
    pub const DETAIL_MODAL: FocusId = 17;
    // Focus groups
    pub const GROUP_MAIN: u32 = 99;
    pub const GROUP_PALETTE: u32 = 100;
    pub const GROUP_HELP: u32 = 101;
    pub const GROUP_EXPORT: u32 = 102;
    pub const GROUP_CONSENT: u32 = 103;
    pub const GROUP_BULK: u32 = 104;
    pub const GROUP_SAVED_VIEWS: u32 = 105;
    pub const GROUP_SOURCE_FILTER: u32 = 106;
    pub const GROUP_DETAIL_MODAL: u32 = 107;
}

// =========================================================================
// Thread-local raw event stash (for model-level macro recording)
// =========================================================================

thread_local! {
    /// Stores the last raw ftui Event before it is converted to CassMsg.
    /// Used by the macro recorder to capture events at the terminal level.
    static RAW_EVENT_STASH: RefCell<Option<super::ftui_adapter::Event>> = const { RefCell::new(None) };
}

fn stash_raw_event(event: &super::ftui_adapter::Event) {
    RAW_EVENT_STASH.with(|buf| {
        *buf.borrow_mut() = Some(event.clone());
    });
}

fn take_raw_event() -> Option<super::ftui_adapter::Event> {
    RAW_EVENT_STASH.with(|buf| buf.borrow_mut().take())
}

/// Peek at the stashed raw event without removing it.
fn peek_raw_event() -> Option<super::ftui_adapter::Event> {
    RAW_EVENT_STASH.with(|buf| buf.borrow().clone())
}

// =========================================================================
// Constants
// =========================================================================

/// Labels for the bulk-actions modal menu (order matters — matches action_index).
pub const BULK_ACTIONS: [&str; 4] = [
    "Open all in editor",
    "Copy all paths",
    "Export as JSON",
    "Clear selection",
];

/// Title used by the saved-views manager modal.
pub const SAVED_VIEWS_MODAL_TITLE: &str = " Saved Views ";

/// Number of selected items before requiring double-press confirmation.
pub const OPEN_CONFIRM_THRESHOLD: usize = 12;
/// Maximum number of panes shown simultaneously in the results strip.
const MAX_VISIBLE_PANES: usize = 6;
/// Baseline agent slugs used for filter input autocompletion when no
/// search-backed candidates are currently available.
const INPUT_AUTOCOMPLETE_AGENT_HINTS: &[&str] = &[
    "aider",
    "amp",
    "chatgpt",
    "claude_code",
    "cline",
    "codex",
    "copilot",
    "cursor",
    "factory",
    "gemini",
    "opencode",
    "pi_agent",
];
const PANEL_RATIO_MIN: f64 = 0.25;
const PANEL_RATIO_MAX: f64 = 0.75;
const FOOTER_HINT_ROOT_ID: HelpId = HelpId(1_000_000);
const RESULTS_REVEAL_MIN_HITS: usize = 6;
const RESULTS_REVEAL_MAX_HITS: usize = 400;
const SURFACE_TRANSITION_DURATION: Duration = Duration::from_millis(160);
const ANALYTICS_VIEW_TRANSITION_DURATION: Duration = Duration::from_millis(120);

#[derive(Clone, Debug)]
struct FooterHintCandidate {
    key: &'static str,
    action: &'static str,
    context: HintContext,
    static_priority: u32,
}

#[derive(Clone, Debug)]
struct ViewTransition {
    from_label: String,
    to_label: String,
    started_at: Instant,
    duration: Duration,
    from_snapshot: Option<ftui::Buffer>,
    slide_direction: i16,
}

#[derive(Clone, Debug)]
struct ViewSnapshot {
    surface: AppSurface,
    analytics_view: Option<AnalyticsView>,
    buffer: ftui::Buffer,
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
enum LoadingContext {
    Search,
    DetailModal,
    Analytics,
    IndexRefresh,
    StateLoad,
}

impl LoadingContext {
    fn label(self) -> &'static str {
        match self {
            Self::Search => "search",
            Self::DetailModal => "detail",
            Self::Analytics => "analytics",
            Self::IndexRefresh => "index",
            Self::StateLoad => "state",
        }
    }
}

impl ViewTransition {
    fn new(
        from_label: impl Into<String>,
        to_label: impl Into<String>,
        duration: Duration,
        from_snapshot: Option<ftui::Buffer>,
        slide_direction: i16,
    ) -> Self {
        Self {
            from_label: from_label.into(),
            to_label: to_label.into(),
            started_at: Instant::now(),
            duration,
            from_snapshot,
            slide_direction,
        }
    }

    fn progress(&self, now: Instant) -> f32 {
        if self.duration.is_zero() {
            return 1.0;
        }
        (now.duration_since(self.started_at).as_secs_f32() / self.duration.as_secs_f32())
            .clamp(0.0, 1.0)
    }

    fn is_done(&self, now: Instant) -> bool {
        self.progress(now) >= 1.0
    }

    fn eased_progress(&self, now: Instant) -> f32 {
        let p = self.progress(now);
        1.0 - (1.0 - p) * (1.0 - p)
    }
}

impl FooterHintCandidate {
    fn token(&self) -> String {
        format!("{}={}", self.key, self.action)
    }
}

// =========================================================================
// Animation infrastructure (bead 2noh9.4.14)
// =========================================================================

/// Spring-based animation durations / presets.
pub mod anim_config {
    use std::time::Duration;

    /// Focus flash settle time (spring-based, replaces 220ms linear).
    pub const FOCUS_FLASH_DURATION: Duration = Duration::from_millis(300);
    /// Peek badge display duration before fade-out.
    pub const PEEK_BADGE_DURATION: Duration = Duration::from_millis(800);
    /// Stagger delay between consecutive result items.
    pub const STAGGER_DELAY: Duration = Duration::from_millis(30);
    /// Maximum number of items that receive stagger animation.
    pub const MAX_ANIMATED_ITEMS: usize = 15;
    /// Modal open/close spring duration.
    pub const MODAL_SPRING_DURATION: Duration = Duration::from_millis(250);
    /// Panel resize interpolation duration.
    pub const PANEL_RESIZE_DURATION: Duration = Duration::from_millis(180);
}

/// Centralized animation state for all spring-based animations in the TUI.
///
/// All springs are ticked on every `CassMsg::Tick`.  When `enabled` is false
/// (CASS_DISABLE_ANIMATIONS=1), springs snap instantly to their targets.
#[derive(Debug)]
pub struct AnimationState {
    /// Master kill-switch: `false` when `CASS_DISABLE_ANIMATIONS=1`.
    pub enabled: bool,
    /// Focus flash spring (0→1 = flash active → settled).
    pub focus_flash: super::ftui_adapter::Spring,
    /// Peek badge spring (0→1 = badge visible → hidden).
    pub peek_badge: super::ftui_adapter::Spring,
    /// Panel resize spring (current → target split ratio, 0.0–1.0).
    pub panel_ratio: super::ftui_adapter::Spring,
    /// Modal open spring (0 = closed, 1 = fully open).
    pub modal_open: super::ftui_adapter::Spring,
    /// Result list reveal progress per slot (up to MAX_ANIMATED_ITEMS).
    pub reveal_springs: Vec<super::ftui_adapter::Spring>,
    /// Whether a reveal sequence is actively playing.
    pub reveal_active: bool,
}

impl Default for AnimationState {
    fn default() -> Self {
        Self::new(true)
    }
}

impl AnimationState {
    /// Create a new animation state.  Pass `false` to disable all animations.
    pub fn new(enabled: bool) -> Self {
        use super::ftui_adapter::Spring;
        Self {
            enabled,
            focus_flash: Spring::new(1.0, 1.0)
                .with_stiffness(280.0)
                .with_damping(22.0),
            peek_badge: Spring::new(0.0, 0.0)
                .with_stiffness(200.0)
                .with_damping(20.0),
            panel_ratio: Spring::new(0.7, 0.7)
                .with_stiffness(300.0)
                .with_damping(26.0),
            modal_open: Spring::new(0.0, 0.0)
                .with_stiffness(350.0)
                .with_damping(24.0),
            reveal_springs: Vec::new(),
            reveal_active: false,
        }
    }

    /// Read CASS_DISABLE_ANIMATIONS from environment.
    pub fn from_env() -> Self {
        let disabled = dotenvy::var("CASS_DISABLE_ANIMATIONS")
            .map(|v| v == "1" || v.eq_ignore_ascii_case("true"))
            .unwrap_or(false);
        Self::new(!disabled)
    }

    /// Tick all active springs by `dt`.  If animations are disabled, snap to targets.
    pub fn tick(&mut self, dt: std::time::Duration) {
        use super::ftui_adapter::Animation;
        if !self.enabled {
            // Snap all springs to rest instantly.
            self.focus_flash = super::ftui_adapter::Spring::new(
                self.focus_flash.target(),
                self.focus_flash.target(),
            );
            self.peek_badge = super::ftui_adapter::Spring::new(
                self.peek_badge.target(),
                self.peek_badge.target(),
            );
            self.panel_ratio = super::ftui_adapter::Spring::new(
                self.panel_ratio.target(),
                self.panel_ratio.target(),
            );
            self.modal_open = super::ftui_adapter::Spring::new(
                self.modal_open.target(),
                self.modal_open.target(),
            );
            for s in &mut self.reveal_springs {
                *s = super::ftui_adapter::Spring::new(s.target(), s.target());
            }
            self.reveal_active = false;
            return;
        }
        self.focus_flash.tick(dt);
        self.peek_badge.tick(dt);
        self.panel_ratio.tick(dt);
        self.modal_open.tick(dt);
        let mut all_done = true;
        for s in &mut self.reveal_springs {
            s.tick(dt);
            if !s.is_at_rest() {
                all_done = false;
            }
        }
        if self.reveal_active && all_done {
            self.reveal_active = false;
        }
    }

    /// Trigger a focus flash (spring from 0→1).
    pub fn trigger_focus_flash(&mut self) {
        self.focus_flash = super::ftui_adapter::Spring::new(0.0, 1.0)
            .with_stiffness(280.0)
            .with_damping(22.0);
    }

    /// Show peek badge (spring to 1), will need explicit hide.
    pub fn show_peek_badge(&mut self) {
        self.peek_badge.set_target(1.0);
    }

    /// Hide peek badge (spring to 0).
    pub fn hide_peek_badge(&mut self) {
        self.peek_badge.set_target(0.0);
    }

    /// Animate panel split ratio to a new target.
    pub fn set_panel_ratio(&mut self, target: f64) {
        self.panel_ratio.set_target(target);
    }

    /// Open a modal (spring to 1).
    pub fn open_modal(&mut self) {
        self.modal_open.set_target(1.0);
    }

    /// Close a modal (spring to 0).
    pub fn close_modal(&mut self) {
        self.modal_open.set_target(0.0);
    }

    /// Start a staggered reveal for `count` result items.
    pub fn start_reveal(&mut self, count: usize) {
        use super::ftui_adapter::Spring;
        let n = count.min(anim_config::MAX_ANIMATED_ITEMS);
        self.reveal_springs.clear();
        for i in 0..n {
            // Each item starts at 0 (hidden) and springs to 1 (visible).
            // Slight stagger by decreasing stiffness for later items.
            let stiffness = 320.0 - (i as f64 * 8.0).min(160.0);
            self.reveal_springs.push(
                Spring::new(0.0, 1.0)
                    .with_stiffness(stiffness)
                    .with_damping(22.0),
            );
        }
        self.reveal_active = true;
    }

    /// Clear any in-flight reveal sequence.
    pub fn clear_reveal(&mut self) {
        self.reveal_springs.clear();
        self.reveal_active = false;
    }

    /// Get the reveal progress for item at index (0.0 = hidden, 1.0 = visible).
    pub fn reveal_progress(&self, idx: usize) -> f64 {
        if !self.enabled || !self.reveal_active {
            return 1.0;
        }
        self.reveal_springs
            .get(idx)
            .map(|s| s.position().clamp(0.0, 1.0))
            .unwrap_or(1.0)
    }

    /// Get the focus flash progress (0.0 = just triggered, 1.0 = settled).
    pub fn focus_flash_progress(&self) -> f32 {
        if !self.enabled {
            return 1.0;
        }
        self.focus_flash.position().clamp(0.0, 1.0) as f32
    }

    /// Get the peek badge visibility (0.0 = hidden, 1.0 = fully visible).
    pub fn peek_badge_progress(&self) -> f32 {
        if !self.enabled {
            return if self.peek_badge.target() > 0.5 {
                1.0
            } else {
                0.0
            };
        }
        self.peek_badge.position().clamp(0.0, 1.0) as f32
    }

    /// Get the modal open progress (0.0 = closed, 1.0 = fully open).
    pub fn modal_progress(&self) -> f32 {
        if !self.enabled {
            return if self.modal_open.target() > 0.5 {
                1.0
            } else {
                0.0
            };
        }
        self.modal_open.position().clamp(0.0, 1.0) as f32
    }

    /// Get the animated panel split ratio.
    pub fn panel_ratio_value(&self) -> f64 {
        if !self.enabled {
            return self.panel_ratio.target();
        }
        self.panel_ratio.position()
    }
}

// =========================================================================
// Enums (ported from tui.rs, canonical for ftui)
// =========================================================================

/// Top-level application surface.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Default)]
pub enum AppSurface {
    /// Main search view (results list + detail pane).
    #[default]
    Search,
    /// Analytics dashboard surface.
    Analytics,
    /// Sources management surface.
    Sources,
}

impl AppSurface {
    fn label(self) -> &'static str {
        match self {
            Self::Search => "Search",
            Self::Analytics => "Analytics",
            Self::Sources => "Sources",
        }
    }

    fn nav_order(self) -> i16 {
        match self {
            Self::Search => 0,
            Self::Analytics => 1,
            Self::Sources => 2,
        }
    }
}

/// Analytics subview within the Analytics surface.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Default)]
pub enum AnalyticsView {
    /// Overview with KPI tiles + sparklines.
    #[default]
    Dashboard,
    /// Interactive time-series explorer.
    Explorer,
    /// Calendar heatmap of daily activity.
    Heatmap,
    /// Agents/workspaces/sources/models breakdowns.
    Breakdowns,
    /// Per-tool usage analytics.
    Tools,
    /// Plan frequency + plan token share + trends.
    Plans,
    /// Token measurement coverage diagnostics.
    Coverage,
}

impl AnalyticsView {
    /// Display label for the view.
    pub fn label(self) -> &'static str {
        match self {
            Self::Dashboard => "Dashboard",
            Self::Explorer => "Explorer",
            Self::Heatmap => "Heatmap",
            Self::Breakdowns => "Breakdowns",
            Self::Tools => "Tools",
            Self::Plans => "Plans",
            Self::Coverage => "Coverage",
        }
    }

    /// All analytics views in display order.
    pub fn all() -> &'static [Self] {
        &[
            Self::Dashboard,
            Self::Explorer,
            Self::Heatmap,
            Self::Breakdowns,
            Self::Tools,
            Self::Plans,
            Self::Coverage,
        ]
    }

    fn nav_order(self) -> i16 {
        Self::all().iter().position(|v| *v == self).unwrap_or(0) as i16
    }

    /// Canonicalize legacy views that should no longer be shown in normal UX.
    fn canonical(self) -> Self {
        self
    }
}

/// Metric to display in the Explorer view.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Default)]
pub enum ExplorerMetric {
    #[default]
    ApiTokens,
    ContentTokens,
    Messages,
    ToolCalls,
    PlanMessages,
}

impl ExplorerMetric {
    pub fn label(self) -> &'static str {
        match self {
            Self::ApiTokens => "API Tokens",
            Self::ContentTokens => "Content Tokens",
            Self::Messages => "Messages",
            Self::ToolCalls => "Tool Calls",
            Self::PlanMessages => "Plan Messages",
        }
    }

    pub fn next(self) -> Self {
        match self {
            Self::ApiTokens => Self::ContentTokens,
            Self::ContentTokens => Self::Messages,
            Self::Messages => Self::ToolCalls,
            Self::ToolCalls => Self::PlanMessages,
            Self::PlanMessages => Self::ApiTokens,
        }
    }

    pub fn prev(self) -> Self {
        match self {
            Self::ApiTokens => Self::PlanMessages,
            Self::ContentTokens => Self::ApiTokens,
            Self::Messages => Self::ContentTokens,
            Self::ToolCalls => Self::Messages,
            Self::PlanMessages => Self::ToolCalls,
        }
    }
}

/// Overlay mode for the Explorer view.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Default)]
pub enum ExplorerOverlay {
    #[default]
    None,
    ByAgent,
    ByWorkspace,
    BySource,
}

impl ExplorerOverlay {
    pub fn label(self) -> &'static str {
        match self {
            Self::None => "No Overlay",
            Self::ByAgent => "By Agent",
            Self::ByWorkspace => "By Workspace",
            Self::BySource => "By Source",
        }
    }

    pub fn next(self) -> Self {
        match self {
            Self::None => Self::ByAgent,
            Self::ByAgent => Self::ByWorkspace,
            Self::ByWorkspace => Self::BySource,
            Self::BySource => Self::None,
        }
    }
}

/// Zoom presets for the Explorer time range.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Default)]
pub enum ExplorerZoom {
    #[default]
    All,
    Day,
    Week,
    Month,
    Quarter,
}

impl ExplorerZoom {
    pub fn label(self) -> &'static str {
        match self {
            Self::All => "All",
            Self::Day => "24h",
            Self::Week => "7d",
            Self::Month => "30d",
            Self::Quarter => "90d",
        }
    }

    pub fn next(self) -> Self {
        match self {
            Self::All => Self::Day,
            Self::Day => Self::Week,
            Self::Week => Self::Month,
            Self::Month => Self::Quarter,
            Self::Quarter => Self::All,
        }
    }

    pub fn prev(self) -> Self {
        match self {
            Self::All => Self::Quarter,
            Self::Day => Self::All,
            Self::Week => Self::Day,
            Self::Month => Self::Week,
            Self::Quarter => Self::Month,
        }
    }

    /// Convert to `(since_ms, until_ms)` relative to now.
    pub fn to_range(self) -> (Option<i64>, Option<i64>) {
        let now_ms = chrono::Utc::now().timestamp_millis();
        match self {
            Self::All => (None, None),
            Self::Day => (Some(now_ms - 24 * 3600 * 1000), None),
            Self::Week => (Some(now_ms - 7 * 24 * 3600 * 1000), None),
            Self::Month => (Some(now_ms - 30 * 24 * 3600 * 1000), None),
            Self::Quarter => (Some(now_ms - 90 * 24 * 3600 * 1000), None),
        }
    }
}

/// Active tab within the Breakdowns view.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Default)]
pub enum BreakdownTab {
    #[default]
    Agent,
    Workspace,
    Source,
    Model,
}

impl BreakdownTab {
    pub fn label(self) -> &'static str {
        match self {
            Self::Agent => "Agents",
            Self::Workspace => "Workspaces",
            Self::Source => "Sources",
            Self::Model => "Models",
        }
    }

    pub fn next(self) -> Self {
        match self {
            Self::Agent => Self::Workspace,
            Self::Workspace => Self::Source,
            Self::Source => Self::Model,
            Self::Model => Self::Agent,
        }
    }

    pub fn prev(self) -> Self {
        match self {
            Self::Agent => Self::Model,
            Self::Workspace => Self::Agent,
            Self::Source => Self::Workspace,
            Self::Model => Self::Source,
        }
    }

    pub fn all() -> &'static [Self] {
        &[Self::Agent, Self::Workspace, Self::Source, Self::Model]
    }
}

/// Metric to display in the Heatmap view.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Default)]
pub enum HeatmapMetric {
    #[default]
    ApiTokens,
    Messages,
    ContentTokens,
    ToolCalls,
    Coverage,
}

impl HeatmapMetric {
    pub fn label(self) -> &'static str {
        match self {
            Self::ApiTokens => "API Tokens",
            Self::Messages => "Messages",
            Self::ContentTokens => "Content Tokens",
            Self::ToolCalls => "Tool Calls",
            Self::Coverage => "Coverage %",
        }
    }

    pub fn next(self) -> Self {
        match self {
            Self::ApiTokens => Self::Messages,
            Self::Messages => Self::ContentTokens,
            Self::ContentTokens => Self::ToolCalls,
            Self::ToolCalls => Self::Coverage,
            Self::Coverage => Self::ApiTokens,
        }
    }

    pub fn prev(self) -> Self {
        match self {
            Self::ApiTokens => Self::Coverage,
            Self::Messages => Self::ApiTokens,
            Self::ContentTokens => Self::Messages,
            Self::ToolCalls => Self::ContentTokens,
            Self::Coverage => Self::ToolCalls,
        }
    }
}

/// Analytics-specific filter state (persisted within the analytics surface).
#[derive(Clone, Debug, Default)]
pub struct AnalyticsFilterState {
    /// Time range: since (ms epoch).
    pub since_ms: Option<i64>,
    /// Time range: until (ms epoch).
    pub until_ms: Option<i64>,
    /// Filter to specific agents (empty = all).
    pub agents: HashSet<String>,
    /// Filter to specific workspaces (empty = all).
    pub workspaces: HashSet<String>,
    /// Source filter.
    pub source_filter: SourceFilter,
}

/// Context passed when drilling down from an analytics selection into search.
///
/// Captures the time-range boundaries and dimensional filter implied by the
/// selected chart element (bucket, row, or heatmap day).
#[derive(Clone, Debug, Default)]
pub struct DrilldownContext {
    /// Start of the selected bucket's time window (ms epoch, inclusive).
    pub since_ms: Option<i64>,
    /// End of the selected bucket's time window (ms epoch, exclusive).
    pub until_ms: Option<i64>,
    /// Agent slug to filter by (from breakdowns / tools selection).
    pub agent: Option<String>,
    /// Workspace path to filter by (from workspace breakdown selection).
    pub workspace: Option<String>,
    /// Source filter to apply (from source breakdown selection).
    pub source_filter: Option<SourceFilter>,
    /// Model family to filter by (from cost / models selection).
    pub model: Option<String>,
}

// Re-export from the analytics_charts module.
pub use super::analytics_charts::AnalyticsChartData;

/// Which tab is active in the detail pane.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Default)]
pub enum DetailTab {
    #[default]
    Messages,
    Snippets,
    Raw,
    /// Syntax-highlighted JSON viewer with collapsible tree display.
    Json,
    /// Per-session analytics: token timeline, tool calls, message stats.
    Analytics,
}

/// Text matching strategy for search queries.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Default)]
pub enum MatchMode {
    #[default]
    Standard,
    Prefix,
}

/// How search results are ranked and ordered.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Default)]
pub enum RankingMode {
    RecentHeavy,
    #[default]
    Balanced,
    RelevanceHeavy,
    MatchQualityHeavy,
    DateNewest,
    DateOldest,
}

/// How much surrounding context to show per result.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Default)]
pub enum ContextWindow {
    Small,
    #[default]
    Medium,
    Large,
    XLarge,
}

/// Quick time filter presets for Shift+F5 cycling.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Default)]
pub enum TimePreset {
    #[default]
    All,
    Today,
    Week,
    Month,
    Custom,
}

impl TimePreset {
    /// Cycle to the next preset (skips Custom on cycle).
    pub fn next(self) -> Self {
        match self {
            Self::All => Self::Today,
            Self::Today => Self::Week,
            Self::Week => Self::Month,
            Self::Month => Self::All,
            Self::Custom => Self::All,
        }
    }

    /// Label for display.
    pub fn label(self) -> &'static str {
        match self {
            Self::All => "All time",
            Self::Today => "Today",
            Self::Week => "Past 7d",
            Self::Month => "Past 30d",
            Self::Custom => "Custom",
        }
    }
}

/// Visual density of the result list.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Default)]
pub enum DensityMode {
    Compact,
    #[default]
    Cozy,
    Spacious,
}

/// Which pane currently holds keyboard focus.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Default)]
pub enum FocusRegion {
    #[default]
    Results,
    Detail,
}

/// Responsive layout breakpoint based on terminal width.
///
/// # Topology Matrix
///
/// | Surface          | Narrow (<80)       | MediumNarrow (80-119)    | Medium (120-159)        | Wide (≥160)              |
/// |------------------|--------------------|--------------------------|-------------------------|--------------------------|
/// | **Search**       | Single pane, focus  | Side-by-side tight       | Side-by-side balanced   | Side-by-side spacious    |
/// |  └ Results       | Full-width or hide  | min 35 cols              | min 45 cols             | min 50 cols              |
/// |  └ Detail        | Full-width or hide  | min 25 cols              | min 32 cols             | min 34 cols              |
/// |  └ Split handle  | None (no split)     | Active (draggable)       | Active (draggable)      | Active (draggable)       |
/// |  └ Navigation    | Focus toggles pane  | Focus + mouse + drag     | Focus + mouse + drag    | Focus + mouse + drag     |
/// | **Analytics**    | Compact chrome       | Standard chrome          | Full chrome + tabs      | Full chrome + tabs       |
/// |  └ Tab bar       | Hidden (active only) | Hidden (active only)     | Full tab bar            | Full tab bar             |
/// |  └ Filter summary| Hidden               | Shown                    | Shown                   | Shown                    |
/// |  └ Footer hints  | Minimal              | Full nav hints           | Full nav hints          | Full nav hints           |
/// |  └ Content views  | min 20w×4h guard    | Full area, inline adjust | Full area, inline adjust| Full area, inline adjust |
/// | **Detail modal** | Full-screen overlay | Full-screen overlay      | Full-screen overlay     | Full-screen overlay      |
/// | **Other modals** | Centered, fixed     | Centered, fixed          | Centered, fixed         | Centered, fixed          |
/// | **Footer**       | "narrow"            | "med-n"                  | "med"                   | "wide"                   |
/// | **Inspector**    | "Narrow (<80)"      | "MedNarrow (80-119)"     | "Medium (120-159)"      | "Wide (>=160)"           |
///
/// # Interaction expectations
///
/// - **Narrow**: Keyboard-primary. `Tab`/`Enter` switches between results ↔ detail.
///   No split handle. Mouse clicks work on the visible pane only.
/// - **MediumNarrow**: Both panes visible but tight. Detail shows wrapped message
///   previews (25-col minimum). Split handle is draggable but range is constrained.
/// - **Medium**: Comfortable dual-pane. Both panes have enough room for full content.
///   Split handle draggable within 25–75% range.
/// - **Wide**: Spacious dual-pane. Extra width used for wider result columns and
///   full detail formatting. Split handle draggable within 25–75% range.
///
/// # Ultra-narrow fallback
///
/// Below `ULTRA_NARROW_MIN_WIDTH` (30) or `ULTRA_NARROW_MIN_HEIGHT` (6), the
/// full UI is not rendered. Instead, a compact "terminal too small" message is
/// shown. This prevents layout panics and unreadable content at degenerate
/// sizes (e.g., 10x3). See [`LayoutBreakpoint::is_ultra_narrow`].
///
/// # Analytics surface notes
///
/// Analytics view content areas do NOT consume `LayoutBreakpoint` — each view
/// checks its assigned `Rect` dimensions directly (e.g., `area.height < 4` as
/// a minimum guard) and adapts layout inline. The breakpoint drives the outer
/// chrome: header tab bar visibility, filter summary, and footer hint density.
/// See [`AnalyticsTopology`] for the per-breakpoint contract.
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum LayoutBreakpoint {
    /// <80 cols: single pane with tab switching (very tight)
    Narrow,
    /// 80-119 cols: side-by-side with tight detail pane
    MediumNarrow,
    /// 120-159 cols: side-by-side results/detail with balanced ratio
    Medium,
    /// >=160 cols: comfortable side-by-side results + detail panes
    Wide,
}

/// Per-breakpoint layout parameters for the search surface.
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct SearchTopology {
    /// Minimum width for the results (left) pane. 0 means single-pane mode.
    pub min_results: u16,
    /// Minimum width for the detail (right) pane. 0 means single-pane mode.
    pub min_detail: u16,
    /// Whether a draggable split handle is shown between panes.
    pub has_split_handle: bool,
    /// Whether both panes are visible simultaneously.
    pub dual_pane: bool,
}

/// Per-breakpoint layout parameters for the analytics surface.
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct AnalyticsTopology {
    /// Whether to show the full tab bar (all view labels) or just the active view.
    pub show_tab_bar: bool,
    /// Whether to show the filter summary line in the header.
    pub show_filter_summary: bool,
    /// Header height in rows (includes borders).
    pub header_rows: u16,
    /// Whether the footer shows key hints alongside the view label.
    pub show_footer_hints: bool,
}

/// Per-breakpoint visibility policy for optional UI elements.
///
/// Controls what non-essential chrome is shown at each breakpoint. When an
/// element is hidden, its action remains accessible via keyboard shortcut
/// or the command palette — visibility only affects the visual affordance.
///
/// # Visibility Matrix
///
/// | Element            | Narrow | MediumNarrow | Medium | Wide |
/// |--------------------|--------|--------------|--------|------|
/// | Theme name in bar  | No     | Yes          | Yes    | Yes  |
/// | Footer key hints   | 0      | 2 slots      | 4 slots| 4   |
/// | Footer hint budget | 0      | 22 chars     | 52     | 52  |
/// | Split handle       | No     | Yes          | Yes    | Yes  |
/// | Saved view paths   | Trunc  | Trunc        | Full   | Full |
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct VisibilityPolicy {
    /// Show the theme name in the search bar title.
    pub show_theme_in_title: bool,
    /// Number of contextual key hint slots in the status footer.
    pub footer_hint_slots: u8,
    /// Character budget for all footer key hints combined.
    pub footer_hint_budget: u16,
    /// Maximum display length for saved-view path labels (0 = hide).
    pub saved_view_path_max: u16,
}

/// Ultra-narrow fallback policy constants.
///
/// When the terminal is smaller than these minimums, we show a compact
/// fallback message instead of attempting to render the full UI. This
/// prevents layout panics, empty renders, and unreadable content.
pub const ULTRA_NARROW_MIN_WIDTH: u16 = 30;
pub const ULTRA_NARROW_MIN_HEIGHT: u16 = 6;

impl LayoutBreakpoint {
    /// Classify from terminal width.
    pub fn from_width(cols: u16) -> Self {
        if cols >= 160 {
            Self::Wide
        } else if cols >= 120 {
            Self::Medium
        } else if cols >= 80 {
            Self::MediumNarrow
        } else {
            Self::Narrow
        }
    }

    /// Check whether the given dimensions are below the ultra-narrow threshold.
    ///
    /// When true, the UI should render a minimal fallback instead of the full
    /// surface. This prevents empty/broken layouts at very constrained sizes.
    pub fn is_ultra_narrow(width: u16, height: u16) -> bool {
        width < ULTRA_NARROW_MIN_WIDTH || height < ULTRA_NARROW_MIN_HEIGHT
    }

    /// Return the search surface topology contract for this breakpoint.
    pub fn search_topology(self) -> SearchTopology {
        match self {
            Self::Narrow => SearchTopology {
                min_results: 0,
                min_detail: 0,
                has_split_handle: false,
                dual_pane: false,
            },
            Self::MediumNarrow => SearchTopology {
                min_results: 35,
                min_detail: 25,
                has_split_handle: true,
                dual_pane: true,
            },
            Self::Medium => SearchTopology {
                min_results: 45,
                min_detail: 32,
                has_split_handle: true,
                dual_pane: true,
            },
            Self::Wide => SearchTopology {
                min_results: 50,
                min_detail: 34,
                has_split_handle: true,
                dual_pane: true,
            },
        }
    }

    /// Return the analytics surface topology contract for this breakpoint.
    pub fn analytics_topology(self) -> AnalyticsTopology {
        match self {
            Self::Narrow => AnalyticsTopology {
                show_tab_bar: false,
                show_filter_summary: false,
                header_rows: 3,
                show_footer_hints: false,
            },
            Self::MediumNarrow => AnalyticsTopology {
                show_tab_bar: false,
                show_filter_summary: true,
                header_rows: 3,
                show_footer_hints: true,
            },
            Self::Medium => AnalyticsTopology {
                show_tab_bar: true,
                show_filter_summary: true,
                header_rows: 3,
                show_footer_hints: true,
            },
            Self::Wide => AnalyticsTopology {
                show_tab_bar: true,
                show_filter_summary: true,
                header_rows: 3,
                show_footer_hints: true,
            },
        }
    }

    /// Return the visibility policy for optional UI elements at this breakpoint.
    pub fn visibility_policy(self) -> VisibilityPolicy {
        match self {
            Self::Narrow => VisibilityPolicy {
                show_theme_in_title: false,
                footer_hint_slots: 0,
                footer_hint_budget: 0,
                saved_view_path_max: 20,
            },
            Self::MediumNarrow => VisibilityPolicy {
                show_theme_in_title: true,
                footer_hint_slots: 2,
                footer_hint_budget: 22,
                saved_view_path_max: 40,
            },
            Self::Medium => VisibilityPolicy {
                show_theme_in_title: true,
                footer_hint_slots: 4,
                footer_hint_budget: 52,
                saved_view_path_max: 60,
            },
            Self::Wide => VisibilityPolicy {
                show_theme_in_title: true,
                footer_hint_slots: 4,
                footer_hint_budget: 52,
                saved_view_path_max: 80,
            },
        }
    }

    /// Short label for the status footer.
    pub fn footer_label(self) -> &'static str {
        match self {
            Self::Narrow => "narrow",
            Self::MediumNarrow => "med-n",
            Self::Medium => "med",
            Self::Wide => "wide",
        }
    }

    /// Descriptive label for the inspector overlay.
    pub fn inspector_label(self) -> &'static str {
        match self {
            Self::Narrow => "Narrow (<80)",
            Self::MediumNarrow => "MedNarrow (80-119)",
            Self::Medium => "Medium (120-159)",
            Self::Wide => "Wide (>=160)",
        }
    }

    /// Return the cockpit overlay topology for this breakpoint and mode.
    pub fn cockpit_topology(self, mode: crate::ui::data::CockpitMode) -> CockpitTopology {
        use crate::ui::data::CockpitMode;
        match (self, mode) {
            (Self::Narrow, CockpitMode::Overlay) => CockpitTopology {
                overlay_max_w: 42,
                overlay_max_h: 10,
                overlay_min_w: 20,
                overlay_min_h: 6,
                use_short_labels: true,
                show_mode_indicator: false,
                max_timeline_events: 3,
                label_width: 6,
                show_footer_hint: false,
            },
            (Self::Narrow, CockpitMode::Expanded) => CockpitTopology {
                overlay_max_w: 42,
                overlay_max_h: 16,
                overlay_min_w: 20,
                overlay_min_h: 6,
                use_short_labels: true,
                show_mode_indicator: false,
                max_timeline_events: 6,
                label_width: 6,
                show_footer_hint: true,
            },
            (Self::MediumNarrow, CockpitMode::Overlay) => CockpitTopology {
                overlay_max_w: 56,
                overlay_max_h: 12,
                overlay_min_w: 20,
                overlay_min_h: 6,
                use_short_labels: false,
                show_mode_indicator: true,
                max_timeline_events: 5,
                label_width: 8,
                show_footer_hint: true,
            },
            (Self::MediumNarrow, CockpitMode::Expanded) => CockpitTopology {
                overlay_max_w: 56,
                overlay_max_h: 22,
                overlay_min_w: 20,
                overlay_min_h: 6,
                use_short_labels: false,
                show_mode_indicator: true,
                max_timeline_events: 10,
                label_width: 8,
                show_footer_hint: true,
            },
            (Self::Medium | Self::Wide, CockpitMode::Overlay) => CockpitTopology {
                overlay_max_w: 66,
                overlay_max_h: 16,
                overlay_min_w: 20,
                overlay_min_h: 6,
                use_short_labels: false,
                show_mode_indicator: true,
                max_timeline_events: 8,
                label_width: 9,
                show_footer_hint: true,
            },
            (Self::Medium | Self::Wide, CockpitMode::Expanded) => CockpitTopology {
                overlay_max_w: 72,
                overlay_max_h: 30,
                overlay_min_w: 20,
                overlay_min_h: 6,
                use_short_labels: false,
                show_mode_indicator: true,
                max_timeline_events: 18,
                label_width: 9,
                show_footer_hint: true,
            },
        }
    }
}

/// Per-breakpoint sizing and truncation policy for the cockpit overlay.
///
/// Design rationale (1mfw3.3.3): The inspector overlay must remain readable
/// across terminal widths from 40 to 200+ columns. Rather than hard-coding
/// dimensions, each `LayoutBreakpoint` × `CockpitMode` pair yields a topology
/// that controls overlay size, label verbosity, and content density.
///
/// Key decisions:
/// - Narrow (<80w) uses single-char tab labels (`T L H R D B G`) to fit in 42 cols.
/// - `overlay_min_w=20` / `overlay_min_h=6` gates auto-disable for tiny terminals.
/// - Expanded mode doubles timeline capacity vs Overlay for deeper inspection.
/// - Footer hints are hidden on Narrow/Overlay to maximize content rows.
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct CockpitTopology {
    /// Maximum width of the overlay box (clamped to available area).
    pub overlay_max_w: u16,
    /// Maximum height of the overlay box.
    pub overlay_max_h: u16,
    /// Below this width, the overlay is auto-disabled.
    pub overlay_min_w: u16,
    /// Below this height, the overlay is auto-disabled.
    pub overlay_min_h: u16,
    /// Use single-char abbreviations instead of full tab labels.
    pub use_short_labels: bool,
    /// Show `[cockpit]`/`[expanded]` mode indicator in the title bar.
    pub show_mode_indicator: bool,
    /// Max timeline events shown in the Timeline tab.
    pub max_timeline_events: u16,
    /// Character budget for row labels (e.g. "Strategy", "Frame/Bgt").
    pub label_width: u16,
    /// Whether to render the keyboard-hint footer row.
    pub show_footer_hint: bool,
}

impl DensityMode {
    /// Lines per result row for this density.
    ///
    /// Layout per density:
    ///   Compact (2): title, meta+inline-snippet
    ///   Cozy    (5): title, meta, location, snippet×2
    ///   Spacious(6): title, meta, location, snippet×3
    pub fn row_height(self) -> u16 {
        match self {
            Self::Compact => 2,
            Self::Cozy => 5,
            Self::Spacious => 6,
        }
    }

    /// Expected number of dedicated snippet lines for this density.
    pub fn snippet_lines(self) -> usize {
        match self {
            Self::Compact => 0, // inline preview only
            Self::Cozy => 2,
            Self::Spacious => 3,
        }
    }

    /// Apply auto-fallback: Compact when terminal is narrow (< 90 cols).
    pub fn effective(self, term_width: u16) -> Self {
        if term_width < 90 && self != Self::Compact {
            Self::Compact
        } else {
            self
        }
    }
}

/// Active tab in the inspector overlay (Ctrl+Shift+I).
///
/// 7 tabs covering rendering diagnostics (Timing/Layout/HitRegions),
/// adaptive system evidence (Resize/Diff/Budget), and an event feed (Timeline).
/// Cycle with Tab; cockpit mode (c key) focuses on Diff/Budget/Timeline.
/// Each tab renders into `render_inspector_overlay()` via `match self.inspector_tab`.
#[derive(Clone, Copy, Debug, Default, PartialEq, Eq)]
pub enum InspectorTab {
    #[default]
    /// Frame timing, FPS, render budget
    Timing,
    /// Widget layout bounds and focus state
    Layout,
    /// Hit-test regions and mouse targets
    HitRegions,
    /// Resize regime, BOCPD, budget evidence
    Resize,
    /// Diff strategy selection evidence
    Diff,
    /// Budget controller / degradation state
    Budget,
    /// Timeline of adaptive decisions
    Timeline,
}

impl InspectorTab {
    pub fn label(self) -> &'static str {
        match self {
            Self::Timing => "Timing",
            Self::Layout => "Layout",
            Self::HitRegions => "Hits",
            Self::Resize => "Resize",
            Self::Diff => "Diff",
            Self::Budget => "Budget",
            Self::Timeline => "Log",
        }
    }

    /// Single-character abbreviation for narrow terminal widths.
    pub fn short_label(self) -> &'static str {
        match self {
            Self::Timing => "T",
            Self::Layout => "L",
            Self::HitRegions => "H",
            Self::Resize => "R",
            Self::Diff => "D",
            Self::Budget => "B",
            Self::Timeline => "G",
        }
    }

    pub fn next(self) -> Self {
        match self {
            Self::Timing => Self::Layout,
            Self::Layout => Self::HitRegions,
            Self::HitRegions => Self::Resize,
            Self::Resize => Self::Diff,
            Self::Diff => Self::Budget,
            Self::Budget => Self::Timeline,
            Self::Timeline => Self::Timing,
        }
    }
}

/// Rolling frame timing statistics for the inspector overlay.
#[derive(Clone, Debug)]
pub struct FrameTimingStats {
    /// Ring buffer of recent frame durations (microseconds).
    pub frame_times_us: VecDeque<u64>,
    /// Timestamp of the last view() call.
    pub last_frame: Option<Instant>,
    /// Maximum ring buffer size.
    capacity: usize,
}

impl Default for FrameTimingStats {
    fn default() -> Self {
        Self {
            frame_times_us: VecDeque::with_capacity(120),
            last_frame: None,
            capacity: 120,
        }
    }
}

impl FrameTimingStats {
    /// Record a frame render and return its duration in microseconds.
    pub fn record_frame(&mut self) -> Option<u64> {
        let now = Instant::now();
        let dt = self
            .last_frame
            .map(|prev| now.duration_since(prev).as_micros() as u64);
        self.last_frame = Some(now);
        if let Some(us) = dt {
            if self.frame_times_us.len() >= self.capacity {
                self.frame_times_us.pop_front();
            }
            self.frame_times_us.push_back(us);
        }
        dt
    }

    /// Average frame time in microseconds (or 0 if empty).
    pub fn avg_us(&self) -> u64 {
        if self.frame_times_us.is_empty() {
            return 0;
        }
        let sum: u64 = self.frame_times_us.iter().sum();
        sum / self.frame_times_us.len() as u64
    }

    /// Estimated frames per second from rolling average.
    pub fn fps(&self) -> f64 {
        let avg = self.avg_us();
        if avg == 0 {
            return 0.0;
        }
        1_000_000.0 / avg as f64
    }

    /// 95th percentile frame time in microseconds.
    pub fn p95_us(&self) -> u64 {
        if self.frame_times_us.is_empty() {
            return 0;
        }
        let mut sorted: Vec<u64> = self.frame_times_us.iter().copied().collect();
        sorted.sort_unstable();
        let idx = (sorted.len() as f64 * 0.95) as usize;
        sorted[idx.min(sorted.len() - 1)]
    }

    /// Most recent frame time in microseconds.
    pub fn last_us(&self) -> u64 {
        self.frame_times_us.back().copied().unwrap_or(0)
    }
}

// ---------------------------------------------------------------------------
// Runtime evidence snapshots (1mfw3.2.3)
// ---------------------------------------------------------------------------

/// Cached snapshots of the latest runtime resize/diff/budget decisions.
/// Populated by polling `ftui::runtime::evidence_telemetry` global snapshots.
///
/// Capacity for the timeline event ring buffer.
const TIMELINE_CAPACITY: usize = 20;

/// Type of adaptive decision captured in the timeline.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum TimelineEventKind {
    /// Diff strategy changed.
    DiffStrategy,
    /// Resize regime changed or resize applied.
    Resize,
    /// Budget degradation level changed.
    BudgetChange,
}

impl TimelineEventKind {
    pub fn label(self) -> &'static str {
        match self {
            Self::DiffStrategy => "Diff",
            Self::Resize => "Resize",
            Self::BudgetChange => "Budget",
        }
    }
}

/// A single timeline event for the explainability cockpit.
#[derive(Debug, Clone)]
pub struct TimelineEvent {
    /// Event kind for icon/color selection.
    pub kind: TimelineEventKind,
    /// Frame index when this event occurred.
    pub frame_idx: u64,
    /// Short human-readable summary of what happened.
    pub summary: String,
}

/// Ring buffer of recent adaptive decision events.
#[derive(Debug, Clone, Default)]
pub struct TimelineBuffer {
    events: VecDeque<TimelineEvent>,
    /// Last seen frame indices to detect new events.
    last_resize_idx: u64,
    last_diff_idx: u64,
    last_budget_idx: u64,
}

impl TimelineBuffer {
    pub fn new() -> Self {
        Self {
            events: VecDeque::with_capacity(TIMELINE_CAPACITY),
            last_resize_idx: 0,
            last_diff_idx: 0,
            last_budget_idx: 0,
        }
    }

    /// Update the timeline from current evidence snapshots.
    /// Only pushes new events when the frame index advances.
    ///
    /// Accepts individual Option refs to avoid a double-borrow conflict
    /// when called from `EvidenceSnapshots::refresh()` (which owns timeline).
    pub fn update_from_snapshots(
        &mut self,
        resize: &Option<ftui::runtime::evidence_telemetry::ResizeDecisionSnapshot>,
        diff: &Option<ftui::runtime::evidence_telemetry::DiffDecisionSnapshot>,
        budget: &Option<ftui::runtime::evidence_telemetry::BudgetDecisionSnapshot>,
    ) {
        // Check for new resize events
        if let Some(resize) = resize
            && resize.event_idx > self.last_resize_idx
        {
            self.last_resize_idx = resize.event_idx;
            let summary = format!(
                "{} {:?} {}",
                resize.action,
                resize.regime,
                resize
                    .applied_size
                    .map(|(w, h)| format!("{w}x{h}"))
                    .unwrap_or_default()
            );
            self.push(TimelineEvent {
                kind: TimelineEventKind::Resize,
                frame_idx: resize.event_idx,
                summary,
            });
        }

        // Check for new diff strategy events
        if let Some(diff) = diff
            && diff.event_idx > self.last_diff_idx
        {
            self.last_diff_idx = diff.event_idx;
            let summary = format!(
                "{} ({:.0}% dirty)",
                diff.strategy_used,
                diff.evidence.posterior_mean * 100.0
            );
            self.push(TimelineEvent {
                kind: TimelineEventKind::DiffStrategy,
                frame_idx: diff.event_idx,
                summary,
            });
        }

        // Check for new budget events
        if let Some(budget) = budget
            && budget.frame_idx > self.last_budget_idx
        {
            self.last_budget_idx = budget.frame_idx;
            let summary = format!(
                "{:?} {:?}\u{2192}{:?}",
                budget.decision, budget.degradation_before, budget.degradation_after
            );
            self.push(TimelineEvent {
                kind: TimelineEventKind::BudgetChange,
                frame_idx: budget.frame_idx,
                summary,
            });
        }
    }

    fn push(&mut self, event: TimelineEvent) {
        if self.events.len() >= TIMELINE_CAPACITY {
            self.events.pop_front();
        }
        self.events.push_back(event);
    }

    /// Recent events, newest first.
    pub fn recent(&self) -> impl Iterator<Item = &TimelineEvent> {
        self.events.iter().rev()
    }

    /// Number of events in the buffer.
    pub fn len(&self) -> usize {
        self.events.len()
    }

    pub fn is_empty(&self) -> bool {
        self.events.is_empty()
    }
}

/// Cached evidence telemetry snapshots, polled from global singletons on
/// each tick. Inspector/cockpit panels read these during `view()` instead of
/// parsing the JSONL evidence file at render time.
///
/// This pull-on-tick pattern avoids file I/O in the render path. The `refresh()`
/// method is called once per tick in `update()`, keeping all evidence data at
/// most one frame stale.
#[derive(Debug, Clone, Default)]
pub struct EvidenceSnapshots {
    /// Latest resize coalescer decision (regime, BOCPD evidence, applied size).
    pub resize: Option<ftui::runtime::evidence_telemetry::ResizeDecisionSnapshot>,
    /// Latest diff-strategy decision (dirty-rows vs full-redraw evidence).
    pub diff: Option<ftui::runtime::evidence_telemetry::DiffDecisionSnapshot>,
    /// Latest frame-budget decision (degradation level, PID output, conformal).
    pub budget: Option<ftui::runtime::evidence_telemetry::BudgetDecisionSnapshot>,
    /// Rendering-ready summary (1mfw3.2.4) — derived from raw snapshots.
    pub summary: ResizeEvidenceSummary,
    /// Timeline of recent adaptive decisions (1mfw3.3.6).
    pub timeline: TimelineBuffer,
}

impl EvidenceSnapshots {
    /// Poll the global telemetry singletons for the latest snapshots,
    /// then update the rendering-ready summary.
    pub fn refresh(&mut self) {
        self.resize = ftui::runtime::evidence_telemetry::resize_snapshot();
        self.diff = ftui::runtime::evidence_telemetry::diff_snapshot();
        self.budget = ftui::runtime::evidence_telemetry::budget_snapshot();
        self.summary.update_from_raw(&self.resize, &self.budget);
        self.timeline
            .update_from_snapshots(&self.resize, &self.diff, &self.budget);
    }

    /// Whether any evidence has been captured yet.
    pub fn has_any(&self) -> bool {
        self.resize.is_some() || self.diff.is_some() || self.budget.is_some()
    }

    /// Human-readable label for the current resize regime (if available).
    pub fn resize_regime_label(&self) -> &'static str {
        match &self.resize {
            Some(snap) => match snap.regime {
                ftui::runtime::resize_coalescer::Regime::Steady => "Steady",
                ftui::runtime::resize_coalescer::Regime::Burst => "Burst",
            },
            None => "\u{2014}",
        }
    }

    /// Current degradation level label (if budget evidence is available).
    pub fn degradation_label(&self) -> &'static str {
        match &self.budget {
            Some(snap) => match snap.degradation_after {
                ftui::render::budget::DegradationLevel::Full => "Full",
                ftui::render::budget::DegradationLevel::SimpleBorders => "SimpleBorders",
                ftui::render::budget::DegradationLevel::NoStyling => "NoStyling",
                ftui::render::budget::DegradationLevel::EssentialOnly => "EssentialOnly",
                ftui::render::budget::DegradationLevel::Skeleton => "Skeleton",
                ftui::render::budget::DegradationLevel::SkipFrame => "SkipFrame",
            },
            None => "\u{2014}",
        }
    }

    /// Sync evidence snapshots into cockpit data contracts.
    ///
    /// Translates raw ftui telemetry types into the cockpit's rendering-ready
    /// contracts so the cockpit overlay can render without understanding
    /// internal ftui types.
    pub fn sync_cockpit(&self, cockpit: &mut CockpitState) {
        // Diff strategy contract
        if let Some(diff) = &self.diff {
            cockpit.diff = DiffStrategyContract {
                last_was_full_redraw: matches!(
                    diff.strategy_used,
                    ftui::render::diff_strategy::DiffStrategy::FullRedraw
                ),
                dirty_row_count: diff.span_count as u32,
                total_row_count: (diff.rows as u32).max(1),
                reason: match diff.strategy_used {
                    ftui::render::diff_strategy::DiffStrategy::Full => "full",
                    ftui::render::diff_strategy::DiffStrategy::DirtyRows => "dirty_rows",
                    ftui::render::diff_strategy::DiffStrategy::FullRedraw => "full_redraw",
                },
                consecutive_full_redraws: 0, // not tracked by telemetry yet
                full_redraw_ratio: 0.0,      // not tracked by telemetry yet
            };
        }

        // Resize regime contract
        cockpit.resize = ResizeRegimeContract {
            regime: self.resize_regime_label(),
            terminal_size: self.summary.applied_size,
            bocpd_p_burst: self.summary.bocpd_p_burst,
            bocpd_delay_ms: self.summary.bocpd_delay_ms,
            history_len: self.summary.recent_resizes.len(),
            last_action: if let Some(last) = self.summary.recent_resizes.back() {
                last.action
            } else {
                "\u{2014}"
            },
            last_dt_ms: self.summary.recent_resizes.back().map_or(0.0, |e| e.dt_ms),
            last_event_rate: self
                .summary
                .recent_resizes
                .back()
                .map_or(0.0, |e| e.event_rate),
        };

        // Budget health contract
        cockpit.budget = BudgetHealthContract {
            degradation: self.degradation_label(),
            budget_us: self.summary.budget_us,
            frame_time_us: self.summary.frame_time_us,
            pid_output: self.summary.pid_output,
            in_warmup: self.summary.in_warmup,
            frames_observed: self.summary.frames_observed,
            pressure: if self.summary.budget_us > 0.0 {
                self.summary.frame_time_us / self.summary.budget_us
            } else {
                0.0
            },
        };
    }
}

// ---------------------------------------------------------------------------
// Rendering-ready evidence summary (1mfw3.2.4)
// ---------------------------------------------------------------------------

/// A single resize decision entry for the ring buffer history.
#[derive(Debug, Clone)]
pub struct ResizeDecisionEntry {
    /// Monotonic event counter from the runtime.
    pub event_idx: u64,
    /// What happened: "apply", "defer", "coalesce", etc.
    pub action: &'static str,
    /// Inter-arrival time since previous resize event (ms).
    pub dt_ms: f64,
    /// Resize event rate at decision time (events/sec).
    pub event_rate: f64,
    /// Regime classification at decision time.
    pub regime: &'static str,
    /// Terminal size after this decision (if applied).
    pub applied_size: Option<(u16, u16)>,
    /// BOCPD burst probability (0.0..1.0), if BOCPD was active.
    pub bocpd_p_burst: Option<f64>,
    /// Timestamp when this entry was captured.
    pub captured_at: Instant,
}

/// Rendering-ready resize evidence summary for inspector/cockpit panels.
///
/// Wraps raw `EvidenceSnapshots` into a single coherent typed object that
/// UI renderers can consume without understanding the internal ftui types.
///
/// # Ring buffer policy
///
/// The `recent_resizes` ring buffer holds the last [`RESIZE_HISTORY_CAPACITY`]
/// entries.  Each call to [`update_from`] checks whether the event_idx has
/// advanced and, if so, pushes a new entry.
///
/// # Backfill/default semantics
///
/// All fields default to "no data" states.  When evidence is absent:
/// - `regime` → `"—"`
/// - `degradation` → `"—"`
/// - Numeric fields → `0` / `0.0`
/// - `recent_resizes` → empty VecDeque
pub const RESIZE_HISTORY_CAPACITY: usize = 32;

#[derive(Debug, Clone)]
pub struct ResizeEvidenceSummary {
    /// Current regime label ("Steady", "Burst", or "—" if unavailable).
    pub regime: &'static str,
    /// Current degradation level label (from budget evidence).
    pub degradation: &'static str,
    /// Frame budget in microseconds (target frame time).
    pub budget_us: f64,
    /// Most recent frame time in microseconds.
    pub frame_time_us: f64,
    /// PID controller output (budget headroom indicator).
    pub pid_output: f64,
    /// Whether the budget controller is in warmup phase.
    pub in_warmup: bool,
    /// Total frames observed by the budget controller.
    pub frames_observed: u32,
    /// Latest applied terminal size (w, h), if known.
    pub applied_size: Option<(u16, u16)>,
    /// BOCPD burst probability (0.0..1.0), if BOCPD is active.
    pub bocpd_p_burst: Option<f64>,
    /// BOCPD recommended coalescer delay (ms), if BOCPD is active.
    pub bocpd_delay_ms: Option<u32>,
    /// Ring buffer of recent resize decisions.
    pub recent_resizes: VecDeque<ResizeDecisionEntry>,
    /// Last event_idx seen (for deduplication).
    last_resize_event_idx: u64,
}

impl Default for ResizeEvidenceSummary {
    fn default() -> Self {
        Self {
            regime: "\u{2014}",
            degradation: "\u{2014}",
            budget_us: 0.0,
            frame_time_us: 0.0,
            pid_output: 0.0,
            in_warmup: false,
            frames_observed: 0,
            applied_size: None,
            bocpd_p_burst: None,
            bocpd_delay_ms: None,
            recent_resizes: VecDeque::with_capacity(RESIZE_HISTORY_CAPACITY),
            last_resize_event_idx: 0,
        }
    }
}

impl ResizeEvidenceSummary {
    /// Update from the latest evidence snapshots.
    ///
    /// Idempotent: only pushes to the ring buffer if the resize event_idx
    /// has advanced since the last call.
    pub fn update_from_raw(
        &mut self,
        resize_snap: &Option<ftui::runtime::evidence_telemetry::ResizeDecisionSnapshot>,
        budget_snap: &Option<ftui::runtime::evidence_telemetry::BudgetDecisionSnapshot>,
    ) {
        // --- Resize evidence ---
        if let Some(resize) = resize_snap {
            self.regime = match resize.regime {
                ftui::runtime::resize_coalescer::Regime::Steady => "Steady",
                ftui::runtime::resize_coalescer::Regime::Burst => "Burst",
            };
            self.applied_size = resize.applied_size;
            self.bocpd_p_burst = resize.bocpd.as_ref().map(|b| b.p_burst);
            self.bocpd_delay_ms = resize
                .bocpd
                .as_ref()
                .and_then(|b| b.recommended_delay_ms.map(|d| d as u32));

            // Push to ring buffer if event_idx advanced.
            if resize.event_idx > self.last_resize_event_idx {
                self.last_resize_event_idx = resize.event_idx;
                if self.recent_resizes.len() >= RESIZE_HISTORY_CAPACITY {
                    self.recent_resizes.pop_front();
                }
                self.recent_resizes.push_back(ResizeDecisionEntry {
                    event_idx: resize.event_idx,
                    action: resize.action,
                    dt_ms: resize.dt_ms,
                    event_rate: resize.event_rate,
                    regime: self.regime,
                    applied_size: resize.applied_size,
                    bocpd_p_burst: self.bocpd_p_burst,
                    captured_at: Instant::now(),
                });
            }
        }

        // --- Budget evidence ---
        if let Some(budget) = budget_snap {
            self.degradation = match budget.degradation_after {
                ftui::render::budget::DegradationLevel::Full => "Full",
                ftui::render::budget::DegradationLevel::SimpleBorders => "SimpleBorders",
                ftui::render::budget::DegradationLevel::NoStyling => "NoStyling",
                ftui::render::budget::DegradationLevel::EssentialOnly => "EssentialOnly",
                ftui::render::budget::DegradationLevel::Skeleton => "Skeleton",
                ftui::render::budget::DegradationLevel::SkipFrame => "SkipFrame",
            };
            self.budget_us = budget.budget_us;
            self.frame_time_us = budget.frame_time_us;
            self.pid_output = budget.pid_output;
            self.in_warmup = budget.in_warmup;
            self.frames_observed = budget.frames_observed;
        }
    }

    /// Whether any meaningful data has been captured.
    pub fn has_data(&self) -> bool {
        self.regime != "\u{2014}" || self.degradation != "\u{2014}"
    }

    /// Number of resize decisions in the ring buffer.
    pub fn history_len(&self) -> usize {
        self.recent_resizes.len()
    }
}

/// Named color slots in the theme editor, matching ThemeColorOverrides fields.
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum ThemeColorSlot {
    Primary,
    Secondary,
    Accent,
    Background,
    Surface,
    Overlay,
    Text,
    TextMuted,
    TextSubtle,
    Success,
    Warning,
    Error,
    Info,
    Border,
    BorderFocused,
    SelectionBg,
    SelectionFg,
    ScrollbarTrack,
    ScrollbarThumb,
}

impl ThemeColorSlot {
    pub const ALL: [Self; 19] = [
        Self::Primary,
        Self::Secondary,
        Self::Accent,
        Self::Background,
        Self::Surface,
        Self::Overlay,
        Self::Text,
        Self::TextMuted,
        Self::TextSubtle,
        Self::Success,
        Self::Warning,
        Self::Error,
        Self::Info,
        Self::Border,
        Self::BorderFocused,
        Self::SelectionBg,
        Self::SelectionFg,
        Self::ScrollbarTrack,
        Self::ScrollbarThumb,
    ];

    pub fn label(self) -> &'static str {
        match self {
            Self::Primary => "Primary",
            Self::Secondary => "Secondary",
            Self::Accent => "Accent",
            Self::Background => "Background",
            Self::Surface => "Surface",
            Self::Overlay => "Overlay",
            Self::Text => "Text",
            Self::TextMuted => "Text Muted",
            Self::TextSubtle => "Text Subtle",
            Self::Success => "Success",
            Self::Warning => "Warning",
            Self::Error => "Error",
            Self::Info => "Info",
            Self::Border => "Border",
            Self::BorderFocused => "Border Focus",
            Self::SelectionBg => "Selection BG",
            Self::SelectionFg => "Selection FG",
            Self::ScrollbarTrack => "Scrollbar Trk",
            Self::ScrollbarThumb => "Scrollbar Thm",
        }
    }

    /// Get the current override value from ThemeColorOverrides.
    pub fn get(self, overrides: &style_system::ThemeColorOverrides) -> Option<&str> {
        match self {
            Self::Primary => overrides.primary.as_deref(),
            Self::Secondary => overrides.secondary.as_deref(),
            Self::Accent => overrides.accent.as_deref(),
            Self::Background => overrides.background.as_deref(),
            Self::Surface => overrides.surface.as_deref(),
            Self::Overlay => overrides.overlay.as_deref(),
            Self::Text => overrides.text.as_deref(),
            Self::TextMuted => overrides.text_muted.as_deref(),
            Self::TextSubtle => overrides.text_subtle.as_deref(),
            Self::Success => overrides.success.as_deref(),
            Self::Warning => overrides.warning.as_deref(),
            Self::Error => overrides.error.as_deref(),
            Self::Info => overrides.info.as_deref(),
            Self::Border => overrides.border.as_deref(),
            Self::BorderFocused => overrides.border_focused.as_deref(),
            Self::SelectionBg => overrides.selection_bg.as_deref(),
            Self::SelectionFg => overrides.selection_fg.as_deref(),
            Self::ScrollbarTrack => overrides.scrollbar_track.as_deref(),
            Self::ScrollbarThumb => overrides.scrollbar_thumb.as_deref(),
        }
    }

    /// Set an override value in ThemeColorOverrides.
    pub fn set(self, overrides: &mut style_system::ThemeColorOverrides, value: Option<String>) {
        match self {
            Self::Primary => overrides.primary = value,
            Self::Secondary => overrides.secondary = value,
            Self::Accent => overrides.accent = value,
            Self::Background => overrides.background = value,
            Self::Surface => overrides.surface = value,
            Self::Overlay => overrides.overlay = value,
            Self::Text => overrides.text = value,
            Self::TextMuted => overrides.text_muted = value,
            Self::TextSubtle => overrides.text_subtle = value,
            Self::Success => overrides.success = value,
            Self::Warning => overrides.warning = value,
            Self::Error => overrides.error = value,
            Self::Info => overrides.info = value,
            Self::Border => overrides.border = value,
            Self::BorderFocused => overrides.border_focused = value,
            Self::SelectionBg => overrides.selection_bg = value,
            Self::SelectionFg => overrides.selection_fg = value,
            Self::ScrollbarTrack => overrides.scrollbar_track = value,
            Self::ScrollbarThumb => overrides.scrollbar_thumb = value,
        }
    }

    /// Get the resolved color from the current theme.
    pub fn resolved_color(self, resolved: ftui::ResolvedTheme) -> ftui::Color {
        match self {
            Self::Primary => resolved.primary,
            Self::Secondary => resolved.secondary,
            Self::Accent => resolved.accent,
            Self::Background => resolved.background,
            Self::Surface => resolved.surface,
            Self::Overlay => resolved.overlay,
            Self::Text => resolved.text,
            Self::TextMuted => resolved.text_muted,
            Self::TextSubtle => resolved.text_subtle,
            Self::Success => resolved.success,
            Self::Warning => resolved.warning,
            Self::Error => resolved.error,
            Self::Info => resolved.info,
            Self::Border => resolved.border,
            Self::BorderFocused => resolved.border_focused,
            Self::SelectionBg => resolved.selection_bg,
            Self::SelectionFg => resolved.selection_fg,
            Self::ScrollbarTrack => resolved.scrollbar_track,
            Self::ScrollbarThumb => resolved.scrollbar_thumb,
        }
    }
}

/// State for the interactive theme editor modal.
#[derive(Clone, Debug)]
pub struct ThemeEditorState {
    /// Working copy of color overrides being edited.
    pub overrides: style_system::ThemeColorOverrides,
    /// Base preset the editor started from.
    pub base_preset: style_system::UiThemePreset,
    /// Currently selected color slot index.
    pub selected: usize,
    /// Whether we're editing a color value (hex input mode).
    pub editing: bool,
    /// Hex input buffer when editing a color.
    pub hex_buffer: String,
    /// Scroll offset for the color list.
    pub scroll: usize,
    /// Cached contrast report for the current config.
    pub contrast_warnings: Vec<String>,
}

impl ThemeEditorState {
    pub fn new(preset: style_system::UiThemePreset) -> Self {
        Self {
            overrides: style_system::ThemeColorOverrides::default(),
            base_preset: preset,
            selected: 0,
            editing: false,
            hex_buffer: String::new(),
            scroll: 0,
            contrast_warnings: Vec::new(),
        }
    }

    /// Create a new editor state, loading from a saved config if one exists.
    ///
    /// In test builds, skips disk I/O and returns a fresh state.
    #[allow(unused_mut)]
    pub fn from_data_dir(preset: style_system::UiThemePreset, data_dir: &Path) -> Self {
        let mut state = Self::new(preset);
        #[cfg(test)]
        let _ = data_dir;
        #[cfg(not(test))]
        {
            let cfg_path = data_dir.join("theme.json");
            if let Ok(cfg) = style_system::ThemeConfig::load_from_path(&cfg_path) {
                if let Some(p) = cfg.base_preset {
                    state.base_preset = p;
                }
                state.overrides = cfg.colors;
            }
        }
        state
    }

    #[allow(unused_mut)]
    pub fn from_disk(preset: style_system::UiThemePreset) -> Self {
        let data_dir = dirs::data_dir()
            .unwrap_or_else(|| PathBuf::from("."))
            .join("coding-agent-search");
        Self::from_data_dir(preset, &data_dir)
    }

    /// Get the currently selected color slot.
    pub fn selected_slot(&self) -> ThemeColorSlot {
        ThemeColorSlot::ALL[self.selected.min(ThemeColorSlot::ALL.len() - 1)]
    }

    /// Build a ThemeConfig from the current editor state.
    pub fn to_config(&self) -> style_system::ThemeConfig {
        style_system::ThemeConfig {
            version: style_system::THEME_CONFIG_VERSION,
            base_preset: Some(self.base_preset),
            colors: self.overrides.clone(),
        }
    }

    /// Refresh the contrast warnings from the current theme.
    pub fn refresh_contrast(&mut self, styles: &StyleContext) {
        let report = styles.contrast_report();
        self.contrast_warnings = report
            .checks
            .iter()
            .filter(|c| !c.passes)
            .map(|c| format!("{}: {:.1}:1 (need {:.1}:1)", c.pair, c.ratio, c.minimum))
            .collect();
    }
}

/// Inline find state within the detail pane.
#[derive(Clone, Debug, Default)]
pub struct DetailFindState {
    pub query: String,
    pub matches: Vec<u16>,
    pub current: usize,
}

/// How results are grouped into panes (G to cycle).
#[derive(Clone, Copy, Debug, PartialEq, Eq, Default)]
pub enum ResultsGrouping {
    #[default]
    Agent,
    Conversation,
    Workspace,
    Flat,
}

impl ResultsGrouping {
    pub fn label(self) -> &'static str {
        match self {
            Self::Agent => "by agent",
            Self::Conversation => "by conversation",
            Self::Workspace => "by workspace",
            Self::Flat => "flat",
        }
    }

    pub fn next(self) -> Self {
        match self {
            Self::Agent => Self::Conversation,
            Self::Conversation => Self::Workspace,
            Self::Workspace => Self::Flat,
            Self::Flat => Self::Agent,
        }
    }
}

/// Snapshot of undoable state for undo/redo (Ctrl+Z / Ctrl+Y).
#[derive(Clone, Debug)]
pub struct UndoEntry {
    pub description: &'static str,
    pub query: String,
    pub cursor_pos: usize,
    pub filters: SearchFilters,
    pub time_preset: TimePreset,
    pub ranking_mode: RankingMode,
    pub grouping_mode: ResultsGrouping,
}

/// Fixed-capacity undo/redo history.
#[derive(Clone, Debug)]
pub struct UndoHistory {
    pub undo_stack: Vec<UndoEntry>,
    pub redo_stack: Vec<UndoEntry>,
    pub max_depth: usize,
}

impl Default for UndoHistory {
    fn default() -> Self {
        Self {
            undo_stack: Vec::new(),
            redo_stack: Vec::new(),
            max_depth: 100,
        }
    }
}

impl UndoHistory {
    /// Push a new snapshot. Clears redo stack.
    pub fn push(&mut self, entry: UndoEntry) {
        self.redo_stack.clear();
        self.undo_stack.push(entry);
        if self.undo_stack.len() > self.max_depth {
            self.undo_stack.remove(0);
        }
    }

    /// Pop the most recent undo entry, moving current state to redo.
    pub fn pop_undo(&mut self, current: UndoEntry) -> Option<UndoEntry> {
        let entry = self.undo_stack.pop()?;
        self.redo_stack.push(current);
        Some(entry)
    }

    /// Pop the most recent redo entry, moving current state to undo.
    pub fn pop_redo(&mut self, current: UndoEntry) -> Option<UndoEntry> {
        let entry = self.redo_stack.pop()?;
        self.undo_stack.push(current);
        Some(entry)
    }

    pub fn can_undo(&self) -> bool {
        !self.undo_stack.is_empty()
    }

    pub fn can_redo(&self) -> bool {
        !self.redo_stack.is_empty()
    }
}

/// One column of results, grouped by a key.
#[derive(Clone, Debug)]
pub struct AgentPane {
    pub agent: String,
    pub hits: Vec<SearchHit>,
    pub selected: usize,
    pub total_count: usize,
}

/// Stable identity for a selected search hit.
///
/// Uses source/path/line/hash so selection survives pane reorder and reranking.
#[derive(Clone, Debug, PartialEq, Eq, Hash)]
pub struct SelectedHitKey {
    pub source_id: String,
    pub source_path: String,
    pub line_number: Option<usize>,
    pub content_hash: u64,
}

impl SelectedHitKey {
    fn from_hit(hit: &SearchHit) -> Self {
        Self {
            source_id: hit.source_id.clone(),
            source_path: hit.source_path.clone(),
            line_number: hit.line_number,
            content_hash: hit.content_hash,
        }
    }
}

/// A search result item prepared for rendering in a VirtualizedList.
///
/// Carries all context needed by `RenderItem::render()` so the item can
/// self-render without access to the parent `CassApp`.
#[derive(Clone, Debug)]
pub struct ResultItem {
    /// 1-based display index.
    pub index: usize,
    /// The underlying search hit.
    pub hit: SearchHit,
    /// Row height (from density mode: 2=compact, 4=cozy, 6=spacious).
    pub row_height: u16,
    /// Whether this is an even-indexed row (for alternating stripes).
    pub even: bool,
    /// Maximum content width available.
    pub max_width: u16,
    /// Whether the item is queued for multi-open (Ctrl+Enter).
    pub queued: bool,
    /// Stripe background style for this row (even/odd).
    pub stripe_style: ftui::Style,
    /// Selected row highlight style (selection_fg/bg).
    pub selected_style: ftui::Style,
    /// Agent accent fg + bold (per-agent color from theme).
    pub agent_accent_style: ftui::Style,
    /// Score magnitude style (high/mid/low).
    pub score_style: ftui::Style,
    /// Primary text style.
    pub text_primary_style: ftui::Style,
    /// Muted text style (metadata, location).
    pub text_muted_style: ftui::Style,
    /// Subtle text style (snippets).
    pub text_subtle_style: ftui::Style,
    /// Success style (for queue checkmark).
    pub success_style: ftui::Style,
    /// Source badge style for local sources (muted).
    pub source_local_style: ftui::Style,
    /// Source badge style for remote sources (info + italic).
    pub source_remote_style: ftui::Style,
    /// File location path style (subtle).
    pub location_style: ftui::Style,
    /// Inline mini-analytics for this hit's conversation/session.
    pub mini_analytics: Option<RowMiniAnalytics>,
    /// Per-row reveal progress (0.0 = hidden / 1.0 = fully visible).
    pub reveal_progress: f32,
    /// Focus-flash intensity injected from app animation state (0.0-1.0).
    pub focus_flash_intensity: f32,
    /// Query terms for highlighting matches in title/snippet.
    pub query_terms: Vec<String>,
    /// Style for highlighted query terms.
    pub query_highlight_style: ftui::Style,
    /// Whether this row is currently under the mouse cursor.
    pub hovered: bool,
}

#[derive(Clone, Copy, Debug, Default)]
pub struct RowMiniAnalytics {
    /// Number of matched messages in the current result set for this session.
    pub matched_messages: usize,
}

fn source_display_label(source_id: &str, origin_host: Option<&str>) -> String {
    if source_id == "local" {
        "local".to_string()
    } else {
        origin_host.unwrap_or(source_id).to_string()
    }
}

fn normalized_source_kind(origin_kind: Option<&str>, source_id: &str) -> String {
    if let Some(kind) = origin_kind.map(str::trim).filter(|s| !s.is_empty()) {
        if kind.eq_ignore_ascii_case("local") {
            return "local".to_string();
        }
        if kind.eq_ignore_ascii_case("ssh") || kind.eq_ignore_ascii_case("remote") {
            return "remote".to_string();
        }
        return kind.to_ascii_lowercase();
    }
    if source_id == "local" {
        "local".to_string()
    } else {
        "remote".to_string()
    }
}

fn workspace_original_from_metadata(metadata: &serde_json::Value) -> Option<String> {
    metadata
        .get("cass")
        .and_then(|cass| cass.get("workspace_original"))
        .and_then(|v| v.as_str())
        .map(ToOwned::to_owned)
}

fn display_group_name(key: &str) -> String {
    key.replace(['_', '-'], " ")
        .split_whitespace()
        .map(|word| {
            let mut chars = word.chars();
            if let Some(first) = chars.next() {
                format!("{}{}", first.to_uppercase(), chars.as_str())
            } else {
                String::new()
            }
        })
        .collect::<Vec<_>>()
        .join(" ")
}

fn legacy_agent_color(agent: &str) -> ftui::PackedRgba {
    match agent.to_ascii_lowercase().as_str() {
        "codex" => ftui::PackedRgba::rgb(0, 200, 150), // teal
        "claude" | "claude_code" => ftui::PackedRgba::rgb(204, 119, 34), // amber
        "gemini" | "gemini_cli" => ftui::PackedRgba::rgb(66, 133, 244), // blue
        "cline" => ftui::PackedRgba::rgb(138, 43, 226), // violet
        "opencode" => ftui::PackedRgba::rgb(50, 205, 50), // lime
        "amp" => ftui::PackedRgba::rgb(255, 99, 71),   // tomato
        "cursor" => ftui::PackedRgba::rgb(147, 112, 219), // purple
        "chatgpt" => ftui::PackedRgba::rgb(16, 163, 127), // chatgpt green
        "aider" => ftui::PackedRgba::rgb(255, 165, 0), // orange
        "pi_agent" => ftui::PackedRgba::rgb(255, 140, 0), // dark orange
        _ => ftui::PackedRgba::rgb(169, 169, 169),     // gray fallback
    }
}

fn dim_packed_color(color: ftui::PackedRgba, factor: f32) -> ftui::PackedRgba {
    let f = factor.clamp(0.0, 1.0);
    ftui::PackedRgba::rgb(
        (f32::from(color.r()) * f).round() as u8,
        (f32::from(color.g()) * f).round() as u8,
        (f32::from(color.b()) * f).round() as u8,
    )
}

/// Linear interpolation between two u8 values by `t` (0.0–1.0).
fn lerp_u8(a: u8, b: u8, t: f32) -> u8 {
    let t = t.clamp(0.0, 1.0);
    ((f32::from(a) * (1.0 - t)) + (f32::from(b) * t)).round() as u8
}

fn max_visible_panes_for_width(width: u16) -> usize {
    match width {
        0..=69 => 1,
        70..=109 => 2,
        110..=149 => 3,
        150..=199 => 4,
        200..=239 => 5,
        _ => MAX_VISIBLE_PANES,
    }
}

fn pane_filter_matches_hit(hit: &SearchHit, filter: &str) -> bool {
    if filter.trim().is_empty() {
        return true;
    }
    let needle = filter.to_ascii_lowercase();
    [
        hit.title.as_str(),
        hit.snippet.as_str(),
        hit.content.as_str(),
        hit.source_path.as_str(),
        hit.workspace.as_str(),
        hit.agent.as_str(),
    ]
    .iter()
    .any(|field| field.to_ascii_lowercase().contains(&needle))
}

fn format_number_with_grouping(n: i64) -> String {
    let digits = n.unsigned_abs().to_string();
    let mut out = String::with_capacity(digits.len() + digits.len() / 3);
    for (idx, ch) in digits.chars().rev().enumerate() {
        if idx > 0 && idx % 3 == 0 {
            out.push(',');
        }
        out.push(ch);
    }
    let mut grouped: String = out.chars().rev().collect();
    if n < 0 {
        grouped.insert(0, '-');
    }
    grouped
}

fn format_compact_metric(n: i64) -> String {
    let abs = n.unsigned_abs();
    if abs >= 1_000_000_000 {
        format!("{:.1}B", n as f64 / 1_000_000_000.0)
    } else if abs >= 1_000_000 {
        format!("{:.1}M", n as f64 / 1_000_000.0)
    } else if abs >= 10_000 {
        format!("{:.1}K", n as f64 / 1_000.0)
    } else {
        format_number_with_grouping(n)
    }
}

fn autocomplete_csv_suffix(input: &str, candidates: &BTreeSet<String>) -> Option<String> {
    let (prefix, suffix) = if let Some(idx) = input.rfind(',') {
        (&input[..=idx], &input[idx + 1..])
    } else {
        ("", input)
    };

    let trimmed_start = suffix.trim_start();
    let leading_ws_len = suffix.len().saturating_sub(trimmed_start.len());
    let leading_ws = &suffix[..leading_ws_len];
    let token = trimmed_start.trim();
    if token.is_empty() {
        return None;
    }

    let token_lower = token.to_ascii_lowercase();
    let candidate = candidates
        .iter()
        .find(|value| value.to_ascii_lowercase().starts_with(&token_lower))?;

    if candidate.eq_ignore_ascii_case(token) {
        return None;
    }

    Some(format!("{prefix}{leading_ws}{candidate}"))
}

fn elide_text(text: &str, max_chars: usize) -> String {
    if max_chars == 0 {
        return String::new();
    }
    if text.chars().count() <= max_chars {
        return text.to_string();
    }
    if max_chars <= 3 {
        return ".".repeat(max_chars);
    }
    let kept: String = text.chars().take(max_chars - 3).collect();
    format!("{kept}...")
}

fn clamp_cursor_boundary(text: &str, cursor: usize) -> usize {
    let mut idx = cursor.min(text.len());
    while idx > 0 && !text.is_char_boundary(idx) {
        idx -= 1;
    }
    idx
}

fn prev_cursor_boundary(text: &str, cursor: usize) -> usize {
    let idx = clamp_cursor_boundary(text, cursor);
    if idx == 0 {
        return 0;
    }
    text[..idx]
        .char_indices()
        .last()
        .map(|(pos, _)| pos)
        .unwrap_or(0)
}

fn next_cursor_boundary(text: &str, cursor: usize) -> usize {
    let idx = clamp_cursor_boundary(text, cursor);
    if idx >= text.len() {
        return text.len();
    }
    text[idx..]
        .chars()
        .next()
        .map(|ch| idx + ch.len_utf8())
        .unwrap_or(text.len())
}

fn move_cursor_by_chars(text: &str, cursor: usize, delta: i32) -> usize {
    let mut idx = clamp_cursor_boundary(text, cursor);
    if delta > 0 {
        for _ in 0..delta {
            let next = next_cursor_boundary(text, idx);
            if next == idx {
                break;
            }
            idx = next;
        }
    } else if delta < 0 {
        for _ in 0..delta.unsigned_abs() {
            let prev = prev_cursor_boundary(text, idx);
            if prev == idx {
                break;
            }
            idx = prev;
        }
    }
    idx
}

/// Elide long paths while preserving their tail for faster row-level scanning.
fn elide_path_for_metadata(path: &str, max_chars: usize) -> String {
    if max_chars == 0 {
        return String::new();
    }
    if path.chars().count() <= max_chars {
        return path.to_string();
    }
    if max_chars <= 6 {
        return elide_text(path, max_chars);
    }

    let trimmed = path.trim();
    let tail = trimmed
        .rsplit('/')
        .find(|segment| !segment.is_empty())
        .unwrap_or(trimmed);
    let compact = format!(".../{tail}");
    if compact.chars().count() <= max_chars {
        return compact;
    }

    let tail_budget = max_chars.saturating_sub(4);
    if tail_budget == 0 {
        return elide_text(path, max_chars);
    }
    format!(".../{}", elide_text(tail, tail_budget))
}

impl ResultItem {
    fn source_badge(&self) -> String {
        format!(
            "[{}]",
            source_display_label(&self.hit.source_id, self.hit.origin_host.as_deref())
        )
    }

    fn source_kind(&self) -> &'static str {
        if self.hit.source_id == "local" || self.hit.origin_kind.eq_ignore_ascii_case("local") {
            "local"
        } else {
            "remote"
        }
    }

    fn source_kind_icon(&self) -> &'static str {
        if self.source_kind() == "remote" {
            "\u{21c4}"
        } else {
            "\u{2302}"
        }
    }

    fn location_label(&self) -> String {
        if let Some(line) = self.hit.line_number {
            format!("{}:{line}", self.hit.source_path)
        } else {
            self.hit.source_path.clone()
        }
    }

    fn match_type_label(&self) -> &'static str {
        match self.hit.match_type {
            MatchType::Exact => "exact",
            MatchType::Prefix => "prefix",
            MatchType::Suffix => "suffix",
            MatchType::Substring => "substr",
            MatchType::Wildcard => "wild",
            MatchType::ImplicitWildcard => "auto",
        }
    }

    fn snippet_source(&self) -> &str {
        let snippet = self.hit.snippet.trim();
        if !snippet.is_empty() {
            return snippet;
        }
        let content = self.hit.content.trim();
        if !content.is_empty() {
            return content;
        }
        let title = self.hit.title.trim();
        if !title.is_empty() {
            return title;
        }
        "<no snippet>"
    }

    fn char_boundary_at(text: &str, char_limit: usize) -> usize {
        if char_limit == 0 {
            return 0;
        }
        for (seen, (idx, ch)) in text.char_indices().enumerate() {
            if seen + 1 == char_limit {
                return idx + ch.len_utf8();
            }
        }
        text.len()
    }

    fn wrap_break_index(line: &str, width: usize) -> usize {
        let boundary = Self::char_boundary_at(line, width);
        let mut last_whitespace = None;
        for (idx, ch) in line[..boundary].char_indices() {
            if ch.is_whitespace() {
                last_whitespace = Some(idx);
            }
        }
        last_whitespace.filter(|idx| *idx > 0).unwrap_or(boundary)
    }

    fn snippet_line_budget(&self, max_width: usize) -> usize {
        // Snippet budget per density:
        //   Compact (row_h=2): 0 (uses inline preview instead)
        //   Cozy    (row_h=5): 2 dedicated snippet lines
        //   Spacious(row_h=6): 3 dedicated snippet lines
        let base: usize = match self.row_height {
            0..=3 => 0,
            4..=5 => self.row_height.saturating_sub(3) as usize,
            _ => 3,
        };
        if base == 0 {
            return 0;
        }
        if max_width < 28 {
            base.saturating_sub(1).max(1)
        } else {
            base
        }
    }

    fn compact_snippet_preview(&self, max_width: usize) -> Option<String> {
        if max_width < 10 {
            return None;
        }
        self.snippet_lines(max_width, 1).into_iter().next()
    }

    fn snippet_lines(&self, max_width: usize, max_lines: usize) -> Vec<String> {
        if max_lines == 0 {
            return Vec::new();
        }

        let source = self.snippet_source();
        if source.is_empty() {
            return vec!["<no snippet>".to_string()];
        }

        let width = max_width.max(8);
        let mut out: Vec<String> = Vec::new();
        for raw in source
            .lines()
            .map(str::trim)
            .filter(|line| !line.is_empty())
        {
            let mut remaining = raw;
            while !remaining.is_empty() {
                if out.len() >= max_lines {
                    return out;
                }
                if remaining.chars().count() <= width {
                    out.push(remaining.to_string());
                    break;
                }
                if out.len() + 1 >= max_lines {
                    out.push(elide_text(remaining, width));
                    return out;
                }

                let break_idx = Self::wrap_break_index(remaining, width);
                if break_idx == 0 {
                    out.push(elide_text(remaining, width));
                    break;
                }
                let segment = remaining[..break_idx].trim_end();
                if segment.is_empty() {
                    out.push(elide_text(remaining, width));
                    break;
                }
                out.push(segment.to_string());
                remaining = remaining[break_idx..].trim_start();
            }
            if out.len() >= max_lines {
                return out;
            }
        }

        if out.is_empty() {
            out.push("<no snippet>".to_string());
        }
        out.truncate(max_lines);
        out
    }

    fn mini_analytics_spans(&self) -> Vec<ftui::text::Span<'static>> {
        let Some(analytics) = self.mini_analytics else {
            return Vec::new();
        };
        if analytics.matched_messages == 0 {
            return Vec::new();
        }

        let msg_text = if analytics.matched_messages == 1 {
            "1 msg".to_string()
        } else {
            format!(
                "{} msgs",
                format_compact_metric(analytics.matched_messages as i64)
            )
        };

        match LayoutBreakpoint::from_width(self.max_width) {
            LayoutBreakpoint::Narrow => Vec::new(),
            LayoutBreakpoint::MediumNarrow => vec![
                ftui::text::Span::styled("● ", self.agent_accent_style),
                ftui::text::Span::styled(msg_text.clone(), self.text_primary_style),
            ],
            LayoutBreakpoint::Medium | LayoutBreakpoint::Wide => vec![
                ftui::text::Span::styled("● ", self.agent_accent_style),
                ftui::text::Span::styled(msg_text, self.text_primary_style),
            ],
        }
    }
}

impl RenderItem for ResultItem {
    fn render(&self, area: Rect, frame: &mut super::ftui_adapter::Frame, selected: bool) {
        let hit = &self.hit;
        let location_full = self.location_label();
        let title = if hit.title.trim().is_empty() {
            "<untitled>"
        } else {
            hit.title.trim()
        };

        let bg_style = if selected {
            self.selected_style
        } else if self.hovered {
            // Subtle hover highlight: blend stripe bg 8% toward white to
            // indicate the mouse cursor is on this row.
            let base = self.stripe_style;
            if let Some(bg) = base.bg {
                let t = 0.08;
                base.bg(ftui::PackedRgba::rgb(
                    lerp_u8(bg.r(), 255, t),
                    lerp_u8(bg.g(), 255, t),
                    lerp_u8(bg.b(), 255, t),
                ))
            } else {
                base
            }
        } else {
            self.stripe_style
        };
        let reveal_progress = self.reveal_progress.clamp(0.0, 1.0);
        let reveal_lead = " ".repeat(((1.0 - reveal_progress) * 4.0).round() as usize);

        Block::new().style(bg_style).render(area, frame);

        let content_width = usize::from(area.width.saturating_sub(2)).max(20);

        // Line 1: sel + queue + index + agent icon + agent name + title
        let sel_mark = if selected { "\u{25b6} " } else { "  " };
        let focus_flash_active = selected && self.focus_flash_intensity > 0.08;
        let focus_flash_span = if focus_flash_active {
            Some(ftui::text::Span::styled(
                "\u{2726} ",
                self.success_style.bold(),
            ))
        } else {
            None
        };
        let queue_span = if self.queued {
            ftui::text::Span::styled("\u{2713}", self.success_style)
        } else {
            ftui::text::Span::styled(" ", bg_style)
        };
        let agent_icon = super::components::theme::ThemePalette::agent_icon(&hit.agent);
        let agent_name = format!("@{}", elide_text(&hit.agent, 18));
        let mut title_spans = vec![
            ftui::text::Span::styled(format!("{sel_mark}{reveal_lead}"), bg_style),
            queue_span,
        ];
        if let Some(flash) = focus_flash_span {
            title_spans.push(flash);
        }
        title_spans.push(ftui::text::Span::styled(
            format!("{:>2}. ", self.index),
            self.text_muted_style,
        ));
        title_spans.push(ftui::text::Span::styled(
            format!("{agent_icon} "),
            self.agent_accent_style,
        ));
        title_spans.push(ftui::text::Span::styled(
            format!("{agent_name} "),
            self.agent_accent_style,
        ));
        let title_base = if reveal_progress >= 0.8 {
            self.text_primary_style.bold()
        } else {
            self.text_primary_style
        };
        let elided_title = elide_text(title, content_width.saturating_sub(agent_name.len() + 10));
        let hl_spans = highlight_query_spans(
            &elided_title,
            &self.query_terms,
            title_base,
            self.query_highlight_style,
        );
        for span in hl_spans {
            title_spans.push(span);
        }
        let title_line = ftui::text::Line::from_spans(title_spans);

        // Line 2: score bar + source badge + metadata
        let score_bar = score_bar_str(hit.score);
        let score_bar_chars = score_bar.chars().count();
        let source_badge = self.source_badge();
        let source_badge_chars = source_badge.chars().count();
        let source_is_remote = self.source_kind() == "remote";
        let match_chip_style = match hit.match_type {
            MatchType::Exact => self.success_style.bold(),
            MatchType::Prefix => self.score_style.bold(),
            MatchType::ImplicitWildcard
            | MatchType::Wildcard
            | MatchType::Suffix
            | MatchType::Substring => self.text_subtle_style.bold(),
        };
        let match_chip = format!("mt {}", self.match_type_label());
        let mut meta_spans = vec![
            ftui::text::Span::styled("      ", bg_style),
            ftui::text::Span::styled(score_bar, self.score_style),
            ftui::text::Span::styled(" ", bg_style),
            ftui::text::Span::styled(
                source_badge,
                if source_is_remote {
                    self.source_remote_style
                } else {
                    self.source_local_style
                },
            ),
        ];
        let compact_preview = if self.row_height <= 2 {
            let used = 6 + score_bar_chars + 1 + source_badge_chars + 3;
            self.compact_snippet_preview(content_width.saturating_sub(used))
        } else {
            None
        };
        if let Some(snippet_preview) = compact_preview {
            meta_spans.push(ftui::text::Span::styled(" ", bg_style));
            meta_spans.push(ftui::text::Span::styled(
                match_chip.clone(),
                match_chip_style,
            ));
            let analytics_spans = self.mini_analytics_spans();
            if !analytics_spans.is_empty() {
                meta_spans.push(ftui::text::Span::styled(" · ", self.text_muted_style));
                meta_spans.extend(analytics_spans);
            }
            meta_spans.push(ftui::text::Span::styled(" · ", self.text_muted_style));
            meta_spans.push(ftui::text::Span::styled(
                snippet_preview,
                self.text_muted_style,
            ));
        } else {
            // Structured metadata with per-field styling for visual hierarchy
            let hit = &self.hit;
            let ws_label = elide_path_for_metadata(&hit.workspace, 32);
            meta_spans.push(ftui::text::Span::styled(" ", bg_style));
            meta_spans.push(ftui::text::Span::styled(match_chip, match_chip_style));
            meta_spans.push(ftui::text::Span::styled(
                " \u{2502} ",
                self.text_subtle_style,
            ));
            meta_spans.push(ftui::text::Span::styled(
                format!("ws {ws_label}"),
                self.text_primary_style,
            ));
            if let Some(ts) = hit
                .created_at
                .and_then(|ts| chrono::DateTime::from_timestamp(ts, 0))
                .map(|dt| dt.format("%Y-%m-%d %H:%M").to_string())
            {
                meta_spans.push(ftui::text::Span::styled(
                    " \u{2502} ",
                    self.text_subtle_style,
                ));
                meta_spans.push(ftui::text::Span::styled(ts, self.text_muted_style));
            }
            let analytics_spans = self.mini_analytics_spans();
            if !analytics_spans.is_empty() {
                meta_spans.push(ftui::text::Span::styled(
                    " \u{2502} ",
                    self.text_subtle_style,
                ));
                meta_spans.extend(analytics_spans);
            }
        }
        let meta_line = ftui::text::Line::from_spans(meta_spans);

        let mut lines = vec![title_line, meta_line];

        if self.row_height >= 3 {
            let location = elide_path_for_metadata(&location_full, content_width.saturating_sub(6));
            lines.push(ftui::text::Line::from_spans(vec![
                ftui::text::Span::styled("      ", bg_style),
                ftui::text::Span::styled(location, self.location_style),
            ]));
        }

        if self.row_height >= 5 {
            let mut signal_spans = vec![
                ftui::text::Span::styled("    \u{2570}\u{2500} ", self.text_subtle_style),
                ftui::text::Span::styled(
                    format!("{} {}", self.source_kind_icon(), self.source_kind()),
                    if source_is_remote {
                        self.source_remote_style.bold()
                    } else {
                        self.source_local_style.bold()
                    },
                ),
                ftui::text::Span::styled(" · ", self.text_subtle_style),
                ftui::text::Span::styled(
                    format!("score {}", score_display_label(hit.score)),
                    self.score_style,
                ),
                ftui::text::Span::styled(" · ", self.text_subtle_style),
                ftui::text::Span::styled(format!("idx {}", self.index), self.text_muted_style),
            ];
            let analytics_spans = self.mini_analytics_spans();
            if !analytics_spans.is_empty() {
                signal_spans.push(ftui::text::Span::styled(" · ", self.text_subtle_style));
                signal_spans.extend(analytics_spans);
            }
            lines.push(ftui::text::Line::from_spans(signal_spans));
        }

        if self.row_height >= 4 {
            let mut snippet_budget = self.snippet_line_budget(content_width.saturating_sub(8));
            if self.row_height >= 5 {
                snippet_budget = snippet_budget.saturating_sub(1);
            }
            let snippet_lines = self.snippet_lines(content_width.saturating_sub(8), snippet_budget);
            for snippet in snippet_lines {
                let mut snippet_spans = vec![ftui::text::Span::styled(
                    "    \u{2502} ",
                    self.text_muted_style,
                )];
                let hl = highlight_query_spans(
                    &snippet,
                    &self.query_terms,
                    self.text_muted_style,
                    self.query_highlight_style,
                );
                for s in hl {
                    snippet_spans.push(s);
                }
                lines.push(ftui::text::Line::from_spans(snippet_spans));
            }
        }

        let reveal_line_budget = if reveal_progress < 0.34 {
            1usize
        } else if reveal_progress < 0.67 {
            2usize
        } else {
            self.row_height as usize
        };
        lines.truncate(reveal_line_budget.min(self.row_height as usize));
        let text = ftui::text::Text::from_lines(lines);
        Paragraph::new(text).style(bg_style).render(area, frame);
    }

    fn height(&self) -> u16 {
        self.row_height
    }
}

/// Split `text` into owned spans, highlighting case-insensitive matches of `terms`.
///
/// Returns a `Vec<Span<'static>>` where matched substrings use `highlight_style`
/// and non-matched portions use `base_style`. Terms are matched greedily from
/// left to right with no overlapping. Empty or whitespace-only terms are skipped.
fn highlight_query_spans(
    text: &str,
    terms: &[String],
    base_style: ftui::Style,
    highlight_style: ftui::Style,
) -> Vec<ftui::text::Span<'static>> {
    if terms.is_empty() || text.is_empty() {
        return vec![ftui::text::Span::styled(text.to_string(), base_style)];
    }
    let lower = text.to_ascii_lowercase();
    // Collect (start, end) of all non-overlapping matches, earliest-first
    let mut matches: Vec<(usize, usize)> = Vec::new();
    for term in terms {
        if term.is_empty() {
            continue;
        }
        let term_lower = term.to_ascii_lowercase();
        let mut search_from = 0;
        while let Some(pos) = lower[search_from..].find(&term_lower) {
            let abs_start = search_from + pos;
            let abs_end = abs_start + term_lower.len();
            matches.push((abs_start, abs_end));
            search_from = abs_end;
        }
    }
    if matches.is_empty() {
        return vec![ftui::text::Span::styled(text.to_string(), base_style)];
    }
    matches.sort_by_key(|m| m.0);
    // Merge overlapping ranges
    let mut merged: Vec<(usize, usize)> = Vec::with_capacity(matches.len());
    for (s, e) in matches {
        if let Some(last) = merged.last_mut()
            && s <= last.1
        {
            last.1 = last.1.max(e);
            continue;
        }
        merged.push((s, e));
    }
    let mut spans = Vec::with_capacity(merged.len() * 2 + 1);
    let mut cursor = 0;
    for (s, e) in merged {
        if cursor < s {
            spans.push(ftui::text::Span::styled(
                text[cursor..s].to_string(),
                base_style,
            ));
        }
        spans.push(ftui::text::Span::styled(
            text[s..e].to_string(),
            highlight_style,
        ));
        cursor = e;
    }
    if cursor < text.len() {
        spans.push(ftui::text::Span::styled(
            text[cursor..].to_string(),
            base_style,
        ));
    }
    spans
}

/// Extract non-trivial search terms from a query string for highlighting.
///
/// Attempts to:
/// - ignore boolean operators (`AND`, `OR`, `NOT`, `&&`, `||`)
/// - strip leading negation (`-foo` -> `foo`)
/// - strip common wildcard markers (`*foo*` -> `foo`)
/// - preserve quoted phrases as a single term (`\"error handling\"`)
///
/// Terms shorter than 2 characters are dropped to avoid noisy highlights.
fn extract_query_terms(query: &str) -> Vec<String> {
    fn push_term(out: &mut Vec<String>, raw: &str) {
        let mut term = raw.trim();
        if term.is_empty() {
            return;
        }
        if term == "&&" || term == "||" {
            return;
        }
        let upper = term.to_ascii_uppercase();
        if matches!(upper.as_str(), "AND" | "OR" | "NOT") {
            return;
        }

        // Field queries like `agent:codex` -> highlight value part.
        if let Some((_, rhs)) = term.split_once(':')
            && !rhs.trim().is_empty()
        {
            term = rhs.trim();
        }

        term = term.trim_start_matches('-');
        term = term.trim_matches('*');
        term = term.trim_matches(|c: char| matches!(c, '(' | ')' | '[' | ']' | '{' | '}' | ','));

        if term.len() < 2 {
            return;
        }
        out.push(term.to_string());
    }

    let mut terms: Vec<String> = Vec::new();
    let mut current = String::new();
    let mut in_quote: Option<char> = None;

    for ch in query.chars() {
        if let Some(q) = in_quote {
            if ch == q {
                push_term(&mut terms, &current);
                current.clear();
                in_quote = None;
            } else {
                current.push(ch);
            }
            continue;
        }

        match ch {
            '"' | '\'' => {
                push_term(&mut terms, &current);
                current.clear();
                in_quote = Some(ch);
            }
            ' ' | '\t' | '\n' => {
                push_term(&mut terms, &current);
                current.clear();
            }
            _ => current.push(ch),
        }
    }
    push_term(&mut terms, &current);

    // Dedup case-insensitively while preserving a stable order.
    let mut seen = HashSet::new();
    terms
        .into_iter()
        .filter(|t| seen.insert(t.to_ascii_lowercase()))
        .collect()
}

/// Normalize search scores for UI cues.
///
/// Search backends may emit either fractional `0.0..1.0` relevance or legacy
/// `0.0..10.0` scores. The UI uses a unified `0.0..10.0` scale so score bars
/// and high/mid/low tier styles remain meaningful across both formats.
fn normalize_score_for_visuals(score: f32) -> f32 {
    if !score.is_finite() {
        return 0.0;
    }
    let non_negative = score.max(0.0);
    if non_negative <= 1.0 {
        (non_negative * 10.0).clamp(0.0, 10.0)
    } else {
        non_negative.clamp(0.0, 10.0)
    }
}

fn score_display_label(score: f32) -> String {
    if !score.is_finite() {
        return "n/a".to_string();
    }
    let visual = normalize_score_for_visuals(score);
    if (0.0..=1.0).contains(&score) {
        format!("{score:.3} ({visual:.1}/10)")
    } else {
        format!("{visual:.1}/10")
    }
}

/// Build a Unicode score bar from a score (normalized to `0.0..10.0`).
///
/// Uses progressive fill blocks for a richer visual — each of the 3 columns
/// advances independently so partial fills look like a rising meter rather
/// than a flat row.
fn score_bar_str(score: f32) -> String {
    const BLOCKS: &[char] = &[
        ' ', '\u{2581}', '\u{2582}', '\u{2583}', '\u{2584}', '\u{2585}', '\u{2586}', '\u{2587}',
        '\u{2588}',
    ];
    let clamped = normalize_score_for_visuals(score);
    // Map score into 24 discrete steps (3 columns × 8 levels each)
    let total_steps = ((clamped / 10.0) * 24.0).round() as usize;
    let mut bar = String::with_capacity(6);
    for col in 0..3 {
        let col_level = total_steps.saturating_sub(col * 8).min(8);
        bar.push(BLOCKS[col_level]);
    }
    let tier = if clamped >= 8.0 {
        "H"
    } else if clamped >= 5.0 {
        "M"
    } else {
        "L"
    };
    format!("{tier}{bar}{clamped:.1}")
}

/// Parse a hint string like " | key1=desc key2=desc" into styled spans.
/// Keys get `key_style`, descriptions get `desc_style`.
fn build_styled_hints(
    raw: &str,
    key_style: ftui::Style,
    desc_style: ftui::Style,
) -> Vec<ftui::text::Span<'static>> {
    let mut spans = Vec::new();
    if raw.is_empty() {
        return spans;
    }
    spans.push(ftui::text::Span::styled(" ", desc_style));
    // Hint format: " | key=desc key=desc ..."
    // Split on spaces, then each token is "key=desc" or a separator.
    for token in raw.split_whitespace() {
        if token == "|" {
            spans.push(ftui::text::Span::styled(" | ", desc_style));
            continue;
        }
        if let Some(eq_pos) = token.find('=') {
            let key = &token[..eq_pos];
            let desc = &token[eq_pos + 1..];
            spans.push(ftui::text::Span::styled(key.to_string(), key_style));
            spans.push(ftui::text::Span::styled(format!("={desc} "), desc_style));
        } else {
            spans.push(ftui::text::Span::styled(format!("{token} "), desc_style));
        }
    }
    spans
}

#[derive(Clone)]
struct FooterHudLane {
    key: &'static str,
    value: String,
    value_style: ftui::Style,
}

/// Build a width-aware footer HUD line from semantic lane key/value pairs.
///
/// Lanes are appended in order and dropped when they no longer fit. The first
/// lane is always rendered (with value elision if needed) so the footer keeps a
/// stable anchor even in tight layouts.
fn build_footer_hud_line(
    lanes: &[FooterHudLane],
    width: u16,
    key_style: ftui::Style,
    sep_style: ftui::Style,
) -> ftui::text::Line {
    if width == 0 {
        return ftui::text::Line::raw(String::new());
    }

    let max_chars = width as usize;
    let mut used = 0usize;
    let mut rendered = 0usize;
    let mut spans = Vec::new();

    for lane in lanes {
        let lane_chars = lane.key.chars().count() + 3 + lane.value.chars().count();
        let prefix = 1;

        if rendered == 0 && used + prefix + lane_chars > max_chars {
            let max_value = max_chars.saturating_sub(prefix + lane.key.chars().count() + 3);
            if max_value == 0 {
                continue;
            }
            let truncated = elide_text(&lane.value, max_value);
            spans.push(ftui::text::Span::styled(" ", sep_style));
            spans.push(ftui::text::Span::styled("[", sep_style));
            spans.push(ftui::text::Span::styled(lane.key.to_string(), key_style));
            spans.push(ftui::text::Span::styled(":", sep_style));
            spans.push(ftui::text::Span::styled(truncated, lane.value_style));
            spans.push(ftui::text::Span::styled("]", sep_style));
            break;
        }

        if rendered > 0 && used + prefix + lane_chars > max_chars {
            continue;
        }

        spans.push(ftui::text::Span::styled(" ", sep_style));
        used += 1;
        spans.push(ftui::text::Span::styled("[", sep_style));
        spans.push(ftui::text::Span::styled(lane.key.to_string(), key_style));
        spans.push(ftui::text::Span::styled(":", sep_style));
        spans.push(ftui::text::Span::styled(
            lane.value.clone(),
            lane.value_style,
        ));
        spans.push(ftui::text::Span::styled("]", sep_style));
        used += lane_chars;
        rendered += 1;
    }

    if spans.is_empty() {
        spans.push(ftui::text::Span::styled(" ", sep_style));
    }

    ftui::text::Line::from_spans(spans)
}

/// Build the detail-pane find bar line with styled query + match-state segments.
fn build_detail_find_bar_line(
    find: &DetailFindState,
    width: u16,
    query_style: ftui::Style,
    match_active_style: ftui::Style,
    match_inactive_style: ftui::Style,
) -> ftui::text::Line {
    let max_width = width as usize;
    if max_width == 0 {
        return ftui::text::Line::raw(String::new());
    }

    let mut spans: Vec<ftui::text::Span<'static>> = Vec::new();
    let mut used = 0usize;
    let push_segment = |spans: &mut Vec<ftui::text::Span<'static>>,
                        used: &mut usize,
                        text: &str,
                        style: ftui::Style|
     -> bool {
        if text.is_empty() || *used >= max_width {
            return false;
        }
        let chars = text.chars().count();
        if *used + chars > max_width {
            return false;
        }
        spans.push(ftui::text::Span::styled(text.to_string(), style));
        *used += chars;
        true
    };
    let push_segments_if_fit = |spans: &mut Vec<ftui::text::Span<'static>>,
                                used: &mut usize,
                                segments: &[(&str, ftui::Style)]|
     -> bool {
        let chars: usize = segments.iter().map(|(text, _)| text.chars().count()).sum();
        if *used + chars > max_width {
            return false;
        }
        for (text, style) in segments {
            let _ = push_segment(spans, used, text, *style);
        }
        true
    };

    if find.query.is_empty() {
        let base_hint = "/ type to find";
        if !push_segment(&mut spans, &mut used, "/", query_style)
            || !push_segment(&mut spans, &mut used, " type to find", match_inactive_style)
        {
            return ftui::text::Line::raw(elide_text(base_hint, max_width));
        }

        // Keep close/discoverability affordance visible with compact fallbacks.
        let close_full = [
            (" · ", match_inactive_style),
            ("Esc", match_active_style),
            (" close", match_inactive_style),
        ];
        let close_compact = [(" · ", match_inactive_style), ("Esc", match_active_style)];
        if !push_segments_if_fit(&mut spans, &mut used, &close_full) {
            let _ = push_segments_if_fit(&mut spans, &mut used, &close_compact);
        }

        return ftui::text::Line::from_spans(spans);
    }

    let match_segments: Vec<(String, ftui::Style)> = if find.matches.is_empty() {
        vec![
            (" (".to_string(), match_inactive_style),
            ("0".to_string(), match_active_style),
            ("/0".to_string(), match_inactive_style),
            (" no matches)".to_string(), match_inactive_style),
        ]
    } else {
        vec![
            (" (".to_string(), match_inactive_style),
            ((find.current + 1).to_string(), match_active_style),
            (format!("/{}", find.matches.len()), match_inactive_style),
            (")".to_string(), match_inactive_style),
        ]
    };
    let suffix_chars: usize = match_segments
        .iter()
        .map(|(text, _)| text.chars().count())
        .sum();
    let query_budget = max_width.saturating_sub(1 + suffix_chars);
    if query_budget == 0 {
        return ftui::text::Line::raw(elide_text(&format!("/{}", find.query), max_width));
    }

    let query_text = elide_text(&find.query, query_budget);
    let _ = push_segment(&mut spans, &mut used, "/", query_style);
    let _ = push_segment(&mut spans, &mut used, &query_text, query_style);
    for (text, style) in match_segments {
        let _ = push_segment(&mut spans, &mut used, &text, style);
    }

    // Add key hints with compact fallbacks; under tight widths prefer match state.
    let hint_full = [
        (" · ", match_inactive_style),
        ("Enter", match_active_style),
        (" next", match_inactive_style),
        (" · ", match_inactive_style),
        ("n/N", match_active_style),
        (" prev", match_inactive_style),
        (" · ", match_inactive_style),
        ("Esc", match_active_style),
        (" close", match_inactive_style),
    ];
    let hint_compact = [
        (" · ", match_inactive_style),
        ("Enter", match_active_style),
        (" · ", match_inactive_style),
        ("n/N", match_active_style),
        (" · ", match_inactive_style),
        ("Esc", match_active_style),
    ];
    let hint_minimal = [
        (" · ", match_inactive_style),
        ("n/N", match_active_style),
        (" · ", match_inactive_style),
        ("Esc", match_active_style),
    ];
    let hint_esc_only = [(" · ", match_inactive_style), ("Esc", match_active_style)];
    if !push_segments_if_fit(&mut spans, &mut used, &hint_full)
        && !push_segments_if_fit(&mut spans, &mut used, &hint_compact)
        && !push_segments_if_fit(&mut spans, &mut used, &hint_minimal)
    {
        let _ = push_segments_if_fit(&mut spans, &mut used, &hint_esc_only);
    }

    let line = ftui::text::Line::from_spans(spans);

    let rendered_len: usize = line
        .spans()
        .iter()
        .map(|span| span.content.chars().count())
        .sum();
    if rendered_len > max_width {
        let plain: String = line
            .spans()
            .iter()
            .map(|span| span.content.as_ref())
            .collect();
        ftui::text::Line::raw(elide_text(&plain, max_width))
    } else {
        line
    }
}

fn summarize_filter_values(values: &HashSet<String>, empty_label: &str) -> String {
    if values.is_empty() {
        return empty_label.to_string();
    }
    let mut items: Vec<String> = values.iter().cloned().collect();
    items.sort();
    if items.len() <= 2 {
        return items.join(", ");
    }
    format!("{}, {} +{}", items[0], items[1], items.len() - 2)
}

fn format_time_chip(from: Option<i64>, to: Option<i64>) -> Option<String> {
    match (from, to) {
        (None, None) => None,
        (Some(f), None) => Some(format!("{} -> now", format_time_short(f))),
        (None, Some(t)) => Some(format!("start -> {}", format_time_short(t))),
        (Some(f), Some(t)) => Some(format!(
            "{} -> {}",
            format_time_short(f),
            format_time_short(t)
        )),
    }
}

fn ranking_mode_label(mode: RankingMode) -> &'static str {
    match mode {
        RankingMode::RecentHeavy => "Recent",
        RankingMode::Balanced => "Balanced",
        RankingMode::RelevanceHeavy => "Relevance",
        RankingMode::MatchQualityHeavy => "Quality",
        RankingMode::DateNewest => "Newest",
        RankingMode::DateOldest => "Oldest",
    }
}

fn search_mode_token(mode: SearchMode) -> &'static str {
    match mode {
        SearchMode::Lexical => "LEX",
        SearchMode::Semantic => "SEM",
        SearchMode::Hybrid => "HYB",
    }
}

fn match_mode_token(mode: MatchMode) -> &'static str {
    match mode {
        MatchMode::Standard => "STD",
        MatchMode::Prefix => "PFX",
    }
}

fn context_window_token(window: ContextWindow) -> &'static str {
    match window {
        ContextWindow::Small => "S",
        ContextWindow::Medium => "M",
        ContextWindow::Large => "L",
        ContextWindow::XLarge => "XL",
    }
}

fn compact_i64_for_analytics(value: i64) -> String {
    let value_f = value as f64;
    let abs = value_f.abs();
    if abs >= 1_000_000_000.0 {
        format!("{:.1}B", value_f / 1_000_000_000.0)
    } else if abs >= 1_000_000.0 {
        format!("{:.1}M", value_f / 1_000_000.0)
    } else if abs >= 1_000.0 {
        format!("{:.1}K", value_f / 1_000.0)
    } else {
        value.to_string()
    }
}

fn sparkline_from_values(values: &[f64], max_width: usize) -> String {
    const BLOCKS: &[char] = &[
        '\u{2581}', '\u{2582}', '\u{2583}', '\u{2584}', '\u{2585}', '\u{2586}', '\u{2587}',
        '\u{2588}',
    ];

    if values.is_empty() || max_width == 0 {
        return String::new();
    }

    let width = max_width.clamp(6, 32);
    let sampled: Vec<f64> = if values.len() <= width {
        values.to_vec()
    } else {
        let stride = (values.len() - 1) as f64 / (width - 1) as f64;
        (0..width)
            .map(|idx| {
                let src = (idx as f64 * stride).round() as usize;
                values[src.min(values.len().saturating_sub(1))]
            })
            .collect()
    };

    let mut min_v = f64::INFINITY;
    let mut max_v = f64::NEG_INFINITY;
    for value in &sampled {
        min_v = min_v.min(*value);
        max_v = max_v.max(*value);
    }
    if !min_v.is_finite() || !max_v.is_finite() {
        return String::new();
    }
    if (max_v - min_v).abs() <= f64::EPSILON {
        return std::iter::repeat_n(BLOCKS[3], sampled.len()).collect();
    }

    let range = max_v - min_v;
    sampled
        .iter()
        .map(|value| {
            let t = ((*value - min_v) / range).clamp(0.0, 1.0);
            let idx = (t * (BLOCKS.len() - 1) as f64).round() as usize;
            BLOCKS[idx.min(BLOCKS.len() - 1)]
        })
        .collect()
}

/// Persisted filters+ranking for a saved-view slot.
#[derive(Clone, Debug)]
pub struct SavedView {
    pub slot: u8,
    pub label: Option<String>,
    pub agents: HashSet<String>,
    pub workspaces: HashSet<String>,
    pub created_from: Option<i64>,
    pub created_to: Option<i64>,
    pub ranking: RankingMode,
    pub source_filter: SourceFilter,
}

// =========================================================================
// Screenshot export formats
// =========================================================================

/// Output format for TUI screenshot export.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ScreenshotFormat {
    /// Self-contained HTML with inline CSS styles.
    Html,
    /// Scalable vector graphics.
    Svg,
    /// Plain text (no ANSI codes).
    Text,
}

impl ScreenshotFormat {
    pub fn extension(self) -> &'static str {
        match self {
            Self::Html => "html",
            Self::Svg => "svg",
            Self::Text => "txt",
        }
    }

    pub fn label(self) -> &'static str {
        match self {
            Self::Html => "HTML",
            Self::Svg => "SVG",
            Self::Text => "Text",
        }
    }
}

// =========================================================================
// Sources view state (2noh9.4.9)
// =========================================================================

/// Display-ready row for a configured source in the Sources view.
#[derive(Clone, Debug)]
pub struct SourcesViewItem {
    /// Source name (e.g., "laptop").
    pub name: String,
    /// Connection kind (local / ssh).
    pub kind: crate::sources::SourceKind,
    /// SSH host string (e.g., "user@laptop.local"), if remote.
    pub host: Option<String>,
    /// Sync schedule label.
    pub schedule: String,
    /// Number of paths configured.
    pub path_count: usize,
    /// Last sync timestamp (unix ms), if any.
    pub last_sync: Option<i64>,
    /// Last sync result label ("success", "failed", "partial", "never").
    pub last_result: String,
    /// Files synced in last run.
    pub files_synced: u64,
    /// Bytes transferred in last run.
    pub bytes_transferred: u64,
    /// Whether a sync/doctor action is currently running for this source.
    pub busy: bool,
    /// Doctor diagnostic summary (pass/warn/fail counts), if available.
    pub doctor_summary: Option<(usize, usize, usize)>,
    /// Error message, if the last operation failed.
    pub error: Option<String>,
}

/// State for the Sources management surface.
#[derive(Clone, Debug, Default)]
pub struct SourcesViewState {
    /// All configured sources as display rows.
    pub items: Vec<SourcesViewItem>,
    /// Currently selected index.
    pub selected: usize,
    /// Scroll offset for long lists.
    pub scroll: usize,
    /// Whether a bulk operation is running (e.g., sync-all).
    pub busy: bool,
    /// Path to sources.toml (for display).
    pub config_path: String,
    /// Status line message.
    pub status: String,
}

// =========================================================================
// CassApp — the ftui Model
// =========================================================================

/// Palette query latency instrumentation (1mfw3.1.7).
#[derive(Debug, Clone, Default)]
pub struct PaletteLatencyStats {
    /// Microseconds for the most recent query update.
    pub last_query_us: u64,
    /// Peak query latency observed this session.
    pub peak_us: u64,
    /// Total queries processed (for throughput calculation).
    pub query_count: u64,
    /// Accumulated latency microseconds.
    pub total_us: u64,
    /// Whether micro-bench mode is active.
    pub bench_mode: bool,
    /// Timestamp when bench mode was last activated.
    pub bench_start: Option<std::time::Instant>,
}

impl PaletteLatencyStats {
    /// Record a query latency sample.
    pub fn record(&mut self, us: u64) {
        self.last_query_us = us;
        self.peak_us = self.peak_us.max(us);
        self.query_count += 1;
        self.total_us += us;
    }

    /// Average latency in microseconds, or 0 if no queries.
    pub fn avg_us(&self) -> u64 {
        self.total_us.checked_div(self.query_count).unwrap_or(0)
    }

    /// Queries per second throughput (only meaningful in bench mode).
    pub fn queries_per_sec(&self) -> f64 {
        if let Some(start) = self.bench_start {
            let elapsed = start.elapsed().as_secs_f64();
            if elapsed > 0.0 {
                return self.query_count as f64 / elapsed;
            }
        }
        0.0
    }

    /// Budget health indicator: green (<2ms), yellow (2-8ms), red (>8ms).
    pub fn budget_indicator(&self) -> &'static str {
        if self.last_query_us < 2_000 {
            "OK"
        } else if self.last_query_us < 8_000 {
            "WARN"
        } else {
            "SLOW"
        }
    }

    /// Reset stats (called when bench mode is toggled on).
    pub fn reset(&mut self) {
        self.last_query_us = 0;
        self.peak_us = 0;
        self.query_count = 0;
        self.total_us = 0;
    }
}

/// Top-level application state for the cass TUI.
///
/// Implements `ftui::Model` in the runtime skeleton (bead 2noh9.2.3).
/// Every field here is the single source of truth; rendering and
/// event handling derive all behavior from this struct.
pub struct CassApp {
    // -- View routing -----------------------------------------------------
    /// Top-level surface (Search or Analytics).
    pub surface: AppSurface,
    /// Navigation back-stack (Esc pops, drilldowns push).
    pub view_stack: Vec<AppSurface>,
    /// Current analytics subview.
    pub analytics_view: AnalyticsView,
    /// Analytics-specific filter state.
    pub analytics_filters: AnalyticsFilterState,
    /// Cached analytics chart data (loaded when entering analytics surface).
    pub analytics_cache: Option<AnalyticsChartData>,
    /// Current selection index within the active analytics subview (for drilldown).
    pub analytics_selection: usize,
    /// Explorer metric selector state.
    pub explorer_metric: ExplorerMetric,
    /// Explorer overlay mode.
    pub explorer_overlay: ExplorerOverlay,
    /// Explorer time-bucket granularity (Hour / Day / Week / Month).
    pub explorer_group_by: crate::analytics::GroupBy,
    /// Explorer zoom preset (All / 24h / 7d / 30d / 90d).
    pub explorer_zoom: ExplorerZoom,
    /// Active tab within the Breakdowns view.
    pub breakdown_tab: BreakdownTab,
    /// Active metric for the Heatmap view.
    pub heatmap_metric: HeatmapMetric,

    // -- Search & query ---------------------------------------------------
    /// Current search query text.
    pub query: String,
    /// Active search filters (agents, workspaces, time range, source).
    pub filters: SearchFilters,
    /// Last search results (flat list, before pane grouping).
    pub results: Vec<SearchHit>,
    /// Results grouped into per-agent panes.
    pub panes: Vec<AgentPane>,
    /// Currently active pane index.
    pub active_pane: usize,
    /// Scroll offset within the pane list.
    pub pane_scroll_offset: usize,
    /// Items shown per pane. `0` means unlimited.
    pub per_pane_limit: usize,
    /// Virtualized list state for the active results pane (RefCell for view-time mutation).
    pub results_list_state: RefCell<VirtualizedListState>,
    /// Whether wildcard fallback was triggered for the current query.
    pub wildcard_fallback: bool,
    /// Did-you-mean / filter suggestions for the current query.
    pub suggestions: Vec<QuerySuggestion>,
    /// Elapsed time of the last search (for latency badge).
    pub last_search_ms: Option<u128>,
    /// Monotonic generation id for the current query so stale async results can be ignored.
    pub search_generation: u64,
    /// TUI page size for incremental search loading (infinite scroll).
    pub search_page_size: usize,
    /// Backend offset for incremental search paging.
    ///
    /// This tracks how many raw hits have been consumed from the backend's
    /// ordering. It must be used for `offset` when requesting more results,
    /// because the UI may deduplicate hits before display.
    pub search_backend_offset: usize,
    /// Whether the current query likely has more results beyond `results`.
    pub search_has_more: bool,
    /// Guard against overlapping async search requests (initial or load-more).
    pub search_in_flight: bool,
    /// Which search mode is active (lexical / semantic / hybrid).
    pub search_mode: SearchMode,
    /// Text matching strategy.
    pub match_mode: MatchMode,
    /// Result ordering strategy.
    pub ranking_mode: RankingMode,
    /// Context window size.
    pub context_window: ContextWindow,
    /// Active time filter preset (for Shift+F5 cycling).
    pub time_preset: TimePreset,
    /// How results are grouped into panes.
    pub grouping_mode: ResultsGrouping,

    // -- Focus & input ----------------------------------------------------
    /// What the user is currently typing into.
    pub input_mode: InputMode,
    /// Ephemeral input buffer for filter prompts.
    pub input_buffer: String,
    /// Which pane region has keyboard focus (legacy compat).
    pub focus_region: FocusRegion,
    /// FocusGraph-based navigation manager.
    pub focus_manager: FocusManager,
    /// Cursor position within the query string (byte offset).
    pub cursor_pos: usize,
    /// Cursor position within query history.
    pub history_cursor: Option<usize>,
    /// Past query strings (most recent first), deduplicated.
    pub query_history: VecDeque<String>,
    /// Local pane filter text (/ key in results).
    pub pane_filter: Option<String>,

    // -- Multi-select -----------------------------------------------------
    /// Stable hit IDs for multi-selected items.
    pub selected: HashSet<SelectedHitKey>,
    /// Cursor index in the bulk-actions modal menu.
    pub bulk_action_idx: usize,
    /// Two-press safety flag: armed after first Ctrl+O when >= threshold items.
    pub open_confirm_armed: bool,

    // -- Detail view ------------------------------------------------------
    /// Scroll position in the detail pane.
    pub detail_scroll: u16,
    /// Total content lines in the detail pane (set during render).
    pub detail_content_lines: Cell<u16>,
    /// Visible height of the detail pane viewport (set during render).
    pub detail_visible_height: Cell<u16>,
    /// Line offsets of each message header in the Messages tab (set during render).
    /// Each entry is `(line_offset, role)` for message-level navigation.
    pub detail_message_offsets: RefCell<Vec<(u16, crate::model::types::MessageRole)>>,
    /// Active tab in the detail pane.
    pub detail_tab: DetailTab,
    /// Inline find state within the detail pane.
    pub detail_find: Option<DetailFindState>,
    /// Cache for find-in-detail match line numbers (written during rendering).
    pub detail_find_matches_cache: RefCell<Vec<u16>>,
    /// Message line numbers (1-indexed) for search hits in the active session.
    /// Used to highlight context and drive hit-to-hit navigation in detail modal.
    pub detail_session_hit_lines: Vec<usize>,
    /// Rendered line offsets for session hits in the Messages tab.
    pub detail_session_hit_offsets_cache: RefCell<Vec<u16>>,
    /// Active index in `detail_session_hit_lines`.
    pub detail_session_hit_current: usize,
    /// When true, the next Messages render will schedule an auto-scroll to `detail_session_hit_current`.
    pub detail_session_hit_scroll_pending: Cell<bool>,
    /// Pending scroll target computed during render, applied on the next `Tick`.
    pub detail_pending_scroll_to: Cell<Option<u16>>,
    /// Whether the detail drill-in modal is open.
    pub show_detail_modal: bool,
    /// Scroll position within the detail modal.
    pub modal_scroll: u16,
    /// Cached conversation for the currently selected result.
    pub cached_detail: Option<(String, ConversationView)>,
    /// Whether word-wrap is enabled in the detail pane.
    pub detail_wrap: bool,
    /// Indices of tool/system messages that are collapsed in the detail modal.
    /// When a message index is in this set its content is hidden behind a
    /// one-line summary bar; pressing Enter/Space toggles it.
    pub collapsed_tools: HashSet<usize>,

    /// Whether the aggregate stats bar is visible at the bottom of results pane.
    pub show_stats_bar: bool,

    // -- Display & theming ------------------------------------------------
    /// Whether dark theme is active.
    pub theme_dark: bool,
    /// Active ftui theme preset.
    pub theme_preset: UiThemePreset,
    /// Runtime style options derived from environment + user toggles.
    pub style_options: StyleOptions,
    /// Persisted theme config loaded from `data_dir/theme.json` (if present).
    pub theme_config: Option<style_system::ThemeConfig>,
    /// Whether fancy (rounded) borders are enabled.
    pub fancy_borders: bool,
    /// Visual density mode.
    pub density_mode: DensityMode,
    /// Saved context window before peek-XL override.
    pub peek_window_saved: Option<ContextWindow>,

    // -- Modals & overlays ------------------------------------------------
    /// Whether the help overlay is visible.
    pub show_help: bool,
    /// Scroll position within the help overlay.
    pub help_scroll: u16,
    /// Whether the help strip is pinned.
    pub help_pinned: bool,
    /// Whether help has been shown at least once for this profile.
    pub has_seen_help: bool,
    /// Whether the export modal is visible.
    pub show_export_modal: bool,
    /// State of the export modal form.
    pub export_modal_state: Option<ExportModalState>,
    /// Pending screenshot capture (set in update, consumed in view).
    pub screenshot_pending: Option<ScreenshotFormat>,
    /// Buffer for screenshot data captured during view() (RefCell for &self access).
    pub screenshot_result: RefCell<Option<(ScreenshotFormat, String)>>,
    /// Whether the bulk actions modal is visible.
    pub show_bulk_modal: bool,
    /// Whether the saved views manager modal is visible.
    pub show_saved_views_modal: bool,
    /// Current selected index inside saved views manager.
    pub saved_views_selection: usize,
    /// Active drag state while reordering saved views with the mouse.
    pub saved_view_drag: Option<SavedViewDragState>,
    /// Whether the saved views manager is currently renaming a slot.
    pub saved_view_rename_mode: bool,
    /// Rename buffer used while editing saved view labels.
    pub saved_view_rename_buffer: String,
    /// Whether the consent dialog (model download) is visible.
    pub show_consent_dialog: bool,
    /// Semantic search availability state.
    pub semantic_availability: SemanticAvailability,
    /// Whether the source filter popup menu is open.
    pub source_filter_menu_open: bool,
    /// Current selection index in the source filter menu.
    pub source_filter_menu_selection: usize,
    /// Discovered source IDs shown in the source filter menu.
    pub available_source_ids: Vec<String>,
    /// Command palette state (action registry and legacy open flag).
    pub palette_state: PaletteState,
    /// ftui CommandPalette widget (rendering, filtering, selection, scoring).
    pub command_palette: CommandPalette,
    /// Current palette match-filter mode (All / Exact / Prefix / WordStart / Substring / Fuzzy).
    pub palette_match_mode: PaletteMatchMode,
    /// Whether the palette evidence ledger panel is visible.
    pub show_palette_evidence: bool,
    /// Palette query latency instrumentation.
    pub palette_latency: PaletteLatencyStats,
    /// Latest update check result (if any).
    pub update_info: Option<UpdateInfo>,
    /// Session-only dismissal toggle for update banner.
    pub update_dismissed: bool,
    /// Two-step guard: first upgrade request arms, second confirms.
    pub update_upgrade_armed: bool,
    /// One-shot update-check receiver started at app initialization.
    pub update_check_rx: Option<std::sync::mpsc::Receiver<Option<UpdateInfo>>>,

    // -- Notifications ----------------------------------------------------
    /// Toast notification manager.
    pub toast_manager: ToastManager,

    // -- Undo/redo --------------------------------------------------------
    /// History stack for query/filter state undo/redo (Ctrl+Z / Ctrl+Y).
    pub undo_history: UndoHistory,

    // -- Terminal focus tracking -------------------------------------------
    /// Whether the terminal window has focus (for dim-on-blur).
    pub terminal_focused: bool,
    /// Last known terminal size `(width, height)` for macro metadata and fallbacks.
    pub last_terminal_size: Cell<(u16, u16)>,

    // -- Animation & timing -----------------------------------------------
    /// Spring-based animation state (focus flash, reveal, modal, panel).
    pub anim: AnimationState,
    /// Active view/surface transition state.
    view_transition: Option<ViewTransition>,
    /// Most recently rendered full-frame snapshot for transition blending.
    view_transition_snapshot: RefCell<Option<ViewSnapshot>>,
    /// Start time of the reveal animation (legacy, kept for tui.rs compat).
    pub reveal_anim_start: Option<Instant>,
    /// End time of the focus-flash indicator (legacy, kept for tui.rs compat).
    pub focus_flash_until: Option<Instant>,
    /// End time of the peek badge indicator (legacy, kept for tui.rs compat).
    pub peek_badge_until: Option<Instant>,
    /// Last tick timestamp for animation frame delta.
    pub last_tick: Instant,
    /// When state became dirty (for debounced persistence).
    pub dirty_since: Option<Instant>,
    /// When query/filters changed (for debounced search, 60ms).
    pub search_dirty_since: Option<Instant>,
    /// Current spinner frame index.
    pub spinner_frame: usize,
    /// Active loading indicator context for async/deferred operations.
    loading_context: Option<LoadingContext>,

    // -- Saved views ------------------------------------------------------
    /// Up to 9 saved filter+ranking presets (Ctrl+1..9).
    pub saved_views: Vec<SavedView>,

    // -- Layout hit regions (for mouse) -----------------------------------
    // RefCell enables recording rects from view() which takes &self.
    /// Last rendered search bar area.
    pub last_search_bar_area: RefCell<Option<Rect>>,
    /// Last rendered results inner area (without borders).
    pub last_results_inner: RefCell<Option<Rect>>,
    /// Last rendered detail area rectangle.
    pub last_detail_area: RefCell<Option<Rect>>,
    /// Last rendered pane rectangles.
    pub last_pane_rects: RefCell<Vec<Rect>>,
    /// First pane index represented by `last_pane_rects`.
    pub last_pane_first_index: RefCell<usize>,
    /// Last rendered pill hit-test rectangles.
    pub last_pill_rects: RefCell<Vec<(Rect, Pill)>>,
    /// Last rendered status footer area.
    pub last_status_area: RefCell<Option<Rect>>,
    /// Last rendered content area (results/detail container).
    pub last_content_area: RefCell<Option<Rect>>,
    /// Last rendered pane split handle hit area.
    pub last_split_handle_area: RefCell<Option<Rect>>,
    /// Last rendered saved-view list row hit areas.
    pub last_saved_view_row_areas: RefCell<Vec<(Rect, usize)>>,
    /// Active pane split drag state for mouse-based resize.
    pub pane_split_drag: Option<PaneSplitDragState>,

    // -- Input smoothness (jitter / hover stabilization) ----------------------
    /// Last mouse position for jitter detection (suppresses sub-threshold drag noise).
    pub last_mouse_pos: Option<(u16, u16)>,
    /// Timestamp of last saved-view drag hover change (for stabilization).
    pub drag_hover_settled_at: Option<Instant>,
    /// Index of the result item currently under the mouse cursor (hover highlight).
    pub hovered_result: Option<usize>,

    // -- Lazy-loaded services ---------------------------------------------
    /// Data directory used for runtime state/index operations.
    pub data_dir: PathBuf,
    /// SQLite database path used for indexing/search operations.
    pub db_path: PathBuf,
    /// Database reader (initialized on first use).
    pub db_reader: Option<Arc<SqliteStorage>>,
    /// Known workspace list (populated on first filter prompt).
    pub known_workspaces: Option<Vec<String>>,
    /// Search service for async query dispatch.
    pub search_service: Option<Arc<dyn SearchService>>,

    // -- Macro recording/playback -----------------------------------------
    /// Active macro recorder (when interactive recording is in progress).
    pub macro_recorder: Option<MacroRecorder>,
    /// Active macro playback scheduler (when replaying a macro).
    pub macro_playback: Option<MacroPlayback>,
    /// Whether to redact absolute paths when saving macros.
    pub macro_redact_paths: bool,

    // -- Theme editor -----------------------------------------------------
    /// Whether the theme editor modal is open.
    pub show_theme_editor: bool,
    /// Theme editor state (overrides, selected slot, hex input).
    pub theme_editor: Option<ThemeEditorState>,

    // -- Inspector / debug overlays ---------------------------------------
    /// Whether the inspector overlay is visible.
    pub show_inspector: bool,
    /// Active inspector tab (Timing / Layout / HitRegions).
    pub inspector_tab: InspectorTab,
    /// ftui inspector widget state (mode cycling, hit regions).
    pub inspector_state: InspectorState,
    /// Rolling frame timing statistics.
    pub frame_timing: FrameTimingStats,

    // -- Resize evidence snapshots (1mfw3.2.3) ----------------------------
    /// Latest runtime evidence snapshots for explainability cockpit.
    pub evidence: EvidenceSnapshots,

    // -- Explainability cockpit (1mfw3.3.2) --------------------------------
    /// Cockpit data contracts aggregated from evidence snapshots.
    pub cockpit: CockpitState,

    // -- Sources management (2noh9.4.9) -----------------------------------
    /// Sources management view state.
    pub sources_view: SourcesViewState,

    // -- Status line ------------------------------------------------------
    /// Footer status text.
    pub status: String,
    /// Guard against overlapping index-refresh tasks.
    pub index_refresh_in_flight: bool,
}

impl Default for CassApp {
    fn default() -> Self {
        let mut app = Self {
            surface: AppSurface::default(),
            view_stack: Vec::new(),
            analytics_view: AnalyticsView::default(),
            analytics_filters: AnalyticsFilterState::default(),
            analytics_cache: None,
            analytics_selection: 0,
            explorer_metric: ExplorerMetric::default(),
            explorer_overlay: ExplorerOverlay::default(),
            explorer_group_by: crate::analytics::GroupBy::Day,
            explorer_zoom: ExplorerZoom::default(),
            breakdown_tab: BreakdownTab::default(),
            heatmap_metric: HeatmapMetric::default(),
            query: String::new(),
            filters: SearchFilters::default(),
            results: Vec::new(),
            panes: Vec::new(),
            active_pane: 0,
            pane_scroll_offset: 0,
            per_pane_limit: 0,
            results_list_state: RefCell::new(VirtualizedListState::new()),
            wildcard_fallback: false,
            suggestions: Vec::new(),
            last_search_ms: None,
            search_generation: 0,
            search_page_size: 250,
            search_backend_offset: 0,
            search_has_more: false,
            search_in_flight: false,
            search_mode: SearchMode::default(),
            match_mode: MatchMode::default(),
            ranking_mode: RankingMode::default(),
            context_window: ContextWindow::default(),
            time_preset: TimePreset::default(),
            grouping_mode: ResultsGrouping::default(),
            input_mode: InputMode::Query,
            input_buffer: String::new(),
            focus_region: FocusRegion::default(),
            focus_manager: FocusManager::new(),
            cursor_pos: 0,
            history_cursor: None,
            query_history: VecDeque::with_capacity(50),
            pane_filter: None,
            selected: HashSet::new(),
            bulk_action_idx: 0,
            open_confirm_armed: false,
            detail_scroll: 0,
            detail_content_lines: Cell::new(0),
            detail_visible_height: Cell::new(0),
            detail_message_offsets: RefCell::new(Vec::new()),
            detail_tab: DetailTab::default(),
            detail_find: None,
            detail_find_matches_cache: RefCell::new(Vec::new()),
            detail_session_hit_lines: Vec::new(),
            detail_session_hit_offsets_cache: RefCell::new(Vec::new()),
            detail_session_hit_current: 0,
            detail_session_hit_scroll_pending: Cell::new(false),
            detail_pending_scroll_to: Cell::new(None),
            show_detail_modal: false,
            modal_scroll: 0,
            cached_detail: None,
            detail_wrap: true,
            collapsed_tools: HashSet::new(),
            show_stats_bar: true,
            theme_dark: true,
            theme_preset: UiThemePreset::Dark,
            style_options: StyleOptions::from_env(),
            theme_config: None,
            fancy_borders: true,
            density_mode: DensityMode::default(),
            peek_window_saved: None,
            show_help: false,
            help_scroll: 0,
            help_pinned: false,
            has_seen_help: false,
            show_export_modal: false,
            export_modal_state: None,
            screenshot_pending: None,
            screenshot_result: RefCell::new(None),
            show_bulk_modal: false,
            show_saved_views_modal: false,
            saved_views_selection: 0,
            saved_view_drag: None,
            saved_view_rename_mode: false,
            saved_view_rename_buffer: String::new(),
            show_consent_dialog: false,
            semantic_availability: SemanticAvailability::NotInstalled,
            source_filter_menu_open: false,
            source_filter_menu_selection: 0,
            available_source_ids: Vec::new(),
            palette_state: PaletteState::new(default_actions()),
            command_palette: {
                let mut cp = CommandPalette::new().with_max_visible(12);
                cp.enable_evidence_tracking(true);
                for item in &default_actions() {
                    cp.register_action(
                        ActionItem::new(action_id(&item.action), &item.label)
                            .with_description(&item.hint)
                            .with_category(item.action.group().label()),
                    );
                }
                cp
            },
            palette_match_mode: PaletteMatchMode::default(),
            show_palette_evidence: false,
            palette_latency: PaletteLatencyStats::default(),
            update_info: None,
            update_dismissed: false,
            update_upgrade_armed: false,
            update_check_rx: {
                #[cfg(test)]
                {
                    None
                }
                #[cfg(not(test))]
                {
                    Some(spawn_update_check(env!("CARGO_PKG_VERSION").to_string()))
                }
            },
            toast_manager: ToastManager::default(),
            undo_history: UndoHistory::default(),
            terminal_focused: true,
            last_terminal_size: Cell::new((80, 24)),
            anim: AnimationState::from_env(),
            view_transition: None,
            view_transition_snapshot: RefCell::new(None),
            reveal_anim_start: None,
            focus_flash_until: None,
            peek_badge_until: None,
            last_tick: Instant::now(),
            dirty_since: None,
            search_dirty_since: None,
            spinner_frame: 0,
            loading_context: None,
            saved_views: Vec::new(),
            last_search_bar_area: RefCell::new(None),
            last_results_inner: RefCell::new(None),
            last_detail_area: RefCell::new(None),
            last_pane_rects: RefCell::new(Vec::new()),
            last_pane_first_index: RefCell::new(0),
            last_pill_rects: RefCell::new(Vec::new()),
            last_status_area: RefCell::new(None),
            last_content_area: RefCell::new(None),
            last_split_handle_area: RefCell::new(None),
            last_saved_view_row_areas: RefCell::new(Vec::new()),
            pane_split_drag: None,
            last_mouse_pos: None,
            drag_hover_settled_at: None,
            hovered_result: None,
            data_dir: crate::default_data_dir(),
            db_path: crate::default_db_path(),
            db_reader: None,
            known_workspaces: None,
            search_service: None,
            macro_recorder: None,
            macro_playback: None,
            macro_redact_paths: false,
            show_theme_editor: false,
            theme_editor: None,
            show_inspector: false,
            inspector_tab: InspectorTab::default(),
            inspector_state: InspectorState::default(),
            frame_timing: FrameTimingStats::default(),
            evidence: EvidenceSnapshots::default(),
            cockpit: CockpitState::new(),
            sources_view: SourcesViewState::default(),
            status: String::new(),
            index_refresh_in_flight: false,
        };
        // Load persisted theme config (if any) and apply overrides to initial options.
        app.refresh_theme_config_from_data_dir();
        app.init_focus_graph();
        app
    }
}

impl CassApp {
    /// Reload persisted theme configuration from `self.data_dir/theme.json`.
    ///
    /// Baseline always starts from env-derived style options to keep startup
    /// deterministic. If a valid theme config exists, it may override the base
    /// preset and color slots.
    fn refresh_theme_config_from_data_dir(&mut self) {
        self.theme_config = None;
        self.theme_preset = self.style_options.preset;
        self.theme_dark = !matches!(self.theme_preset, UiThemePreset::Light);
        self.style_options.preset = self.theme_preset;
        self.style_options.dark_mode = self.theme_dark;

        #[cfg(not(test))]
        {
            let theme_path = self.data_dir.join("theme.json");
            if !theme_path.exists() {
                return;
            }
            match style_system::ThemeConfig::load_from_path(&theme_path) {
                Ok(config) => {
                    if let Some(preset) = config.base_preset {
                        self.theme_preset = preset;
                        self.style_options.preset = preset;
                        self.theme_dark = !matches!(preset, UiThemePreset::Light);
                        self.style_options.dark_mode = self.theme_dark;
                    }
                    self.theme_config = Some(config);
                }
                Err(_) => {
                    // Invalid or corrupt theme.json — silently ignore at startup.
                }
            }
        }
    }

    /// Initialize the focus graph with all nodes, edges, and groups.
    ///
    /// Called once after construction. Sets up 3 primary surface nodes
    /// (SearchBar, ResultsList, DetailPane) plus modal overlay nodes,
    /// directional edges between the main nodes, and focus groups for
    /// each modal (used with push_trap/pop_trap).
    fn init_focus_graph(&mut self) {
        use focus_ids::*;
        let g = self.focus_manager.graph_mut();

        // -- Primary surface nodes (participate in global Tab order) ------
        g.insert(FocusNode::new(SEARCH_BAR, Rect::new(0, 0, 80, 1)).with_tab_index(0));
        g.insert(FocusNode::new(RESULTS_LIST, Rect::new(0, 2, 40, 20)).with_tab_index(1));
        g.insert(FocusNode::new(DETAIL_PANE, Rect::new(40, 2, 40, 20)).with_tab_index(2));

        // Directional edges: SearchBar ↕ ResultsList ↔ DetailPane
        g.connect(SEARCH_BAR, NavDirection::Down, RESULTS_LIST);
        g.connect(RESULTS_LIST, NavDirection::Up, SEARCH_BAR);
        g.connect(RESULTS_LIST, NavDirection::Right, DETAIL_PANE);
        g.connect(DETAIL_PANE, NavDirection::Left, RESULTS_LIST);
        g.connect(DETAIL_PANE, NavDirection::Up, SEARCH_BAR);
        g.connect(SEARCH_BAR, NavDirection::Down, RESULTS_LIST);

        // Build wrap-around tab chain for primary nodes
        g.build_tab_chain(true);

        // -- Modal overlay nodes (tab_index -1 = skip global tab order) ---
        g.insert(
            FocusNode::new(COMMAND_PALETTE, Rect::new(10, 5, 60, 15))
                .with_tab_index(-1)
                .with_group(GROUP_PALETTE),
        );
        g.insert(
            FocusNode::new(HELP_OVERLAY, Rect::new(5, 2, 70, 20))
                .with_tab_index(-1)
                .with_group(GROUP_HELP),
        );
        g.insert(
            FocusNode::new(EXPORT_MODAL, Rect::new(10, 5, 60, 15))
                .with_tab_index(-1)
                .with_group(GROUP_EXPORT),
        );
        g.insert(
            FocusNode::new(CONSENT_DIALOG, Rect::new(15, 8, 50, 8))
                .with_tab_index(-1)
                .with_group(GROUP_CONSENT),
        );
        g.insert(
            FocusNode::new(BULK_MODAL, Rect::new(20, 5, 40, 10))
                .with_tab_index(-1)
                .with_group(GROUP_BULK),
        );
        g.insert(
            FocusNode::new(SAVED_VIEWS_MODAL, Rect::new(10, 3, 60, 18))
                .with_tab_index(-1)
                .with_group(GROUP_SAVED_VIEWS),
        );
        g.insert(
            FocusNode::new(SOURCE_FILTER_MENU, Rect::new(0, 1, 30, 10))
                .with_tab_index(-1)
                .with_group(GROUP_SOURCE_FILTER),
        );
        g.insert(
            FocusNode::new(DETAIL_MODAL, Rect::new(5, 2, 70, 20))
                .with_tab_index(-1)
                .with_group(GROUP_DETAIL_MODAL),
        );

        // -- Focus groups (one per modal, used with push_trap/pop_trap) ---
        self.focus_manager
            .create_group(GROUP_MAIN, vec![SEARCH_BAR, RESULTS_LIST, DETAIL_PANE]);
        self.focus_manager
            .create_group(GROUP_PALETTE, vec![COMMAND_PALETTE]);
        self.focus_manager
            .create_group(GROUP_HELP, vec![HELP_OVERLAY]);
        self.focus_manager
            .create_group(GROUP_EXPORT, vec![EXPORT_MODAL]);
        self.focus_manager
            .create_group(GROUP_CONSENT, vec![CONSENT_DIALOG]);
        self.focus_manager
            .create_group(GROUP_BULK, vec![BULK_MODAL]);
        self.focus_manager
            .create_group(GROUP_SAVED_VIEWS, vec![SAVED_VIEWS_MODAL]);
        self.focus_manager
            .create_group(GROUP_SOURCE_FILTER, vec![SOURCE_FILTER_MENU]);
        self.focus_manager
            .create_group(GROUP_DETAIL_MODAL, vec![DETAIL_MODAL]);

        // Start with ResultsList focused (matches legacy default FocusRegion::Results)
        self.focus_manager.focus(RESULTS_LIST);
    }

    /// Derive the legacy FocusRegion from the current FocusManager state.
    ///
    /// This bridges the new graph-based focus system with existing code
    /// that checks `focus_region` for rendering decisions.
    pub fn focused_region(&self) -> FocusRegion {
        match self.focus_manager.current() {
            Some(id) if id == focus_ids::DETAIL_PANE || id == focus_ids::DETAIL_MODAL => {
                FocusRegion::Detail
            }
            _ => FocusRegion::Results,
        }
    }

    fn state_file_path(&self) -> PathBuf {
        self.data_dir.join(TUI_STATE_FILE_NAME)
    }

    fn capture_persisted_state(&self) -> PersistedState {
        PersistedState {
            search_mode: self.search_mode,
            match_mode: self.match_mode,
            ranking_mode: self.ranking_mode,
            context_window: self.context_window,
            theme_dark: self.theme_dark,
            density_mode: self.density_mode,
            per_pane_limit: self.per_pane_limit,
            query_history: self.query_history.clone(),
            saved_views: self.saved_views.clone(),
            analytics_since_ms: self.analytics_filters.since_ms,
            analytics_until_ms: self.analytics_filters.until_ms,
            analytics_agents: self.analytics_filters.agents.clone(),
            analytics_workspaces: self.analytics_filters.workspaces.clone(),
            analytics_source_filter: self.analytics_filters.source_filter.clone(),
            fancy_borders: self.fancy_borders,
            help_pinned: self.help_pinned,
            has_seen_help: self.has_seen_help || self.help_pinned || self.show_help,
        }
    }

    fn resolved_style_context(&self) -> StyleContext {
        let mut options = self.style_options;
        options.preset = self.theme_preset;
        options.dark_mode = self.theme_dark;
        if let Some(config) = &self.theme_config {
            StyleContext::from_options_with_theme_config(options, config)
                .unwrap_or_else(|_| StyleContext::from_options(options))
        } else {
            StyleContext::from_options(options)
        }
    }

    fn persist_theme_selection(&mut self) -> Result<(), String> {
        let mut config = self.theme_config.clone().unwrap_or_default();
        config.base_preset = Some(self.theme_preset);
        self.theme_config = Some(config.clone());

        #[cfg(not(test))]
        {
            let theme_path = self.data_dir.join("theme.json");
            config
                .save_to_path(&theme_path)
                .map_err(|e| format!("failed writing {}: {e}", theme_path.display()))?;
        }

        Ok(())
    }

    fn selected_hit(&self) -> Option<&SearchHit> {
        if let Some(pane) = self.panes.get(self.active_pane) {
            return pane.hits.get(pane.selected);
        }
        self.results.first()
    }

    fn active_hit_key(&self) -> Option<SelectedHitKey> {
        self.selected_hit().map(SelectedHitKey::from_hit)
    }

    fn collect_session_hit_lines(&self, selected_hit: &SearchHit) -> Vec<usize> {
        let iter = if self.panes.is_empty() {
            self.results.iter().collect::<Vec<_>>()
        } else {
            self.panes
                .iter()
                .flat_map(|pane| pane.hits.iter())
                .collect::<Vec<_>>()
        };

        let mut lines: Vec<usize> = iter
            .into_iter()
            .filter(|hit| {
                hit.source_path == selected_hit.source_path
                    && hit.source_id == selected_hit.source_id
            })
            .filter_map(|hit| hit.line_number)
            .filter(|line| *line > 0)
            .collect();

        // Prefer an on-the-fly scan of the loaded conversation when available so the
        // detail modal can navigate all in-session hits, even if the results list
        // is paged/incomplete.
        if let Some((cached_path, cv)) = self.cached_detail.as_ref()
            && cached_path == &selected_hit.source_path
        {
            let terms = extract_query_terms(&self.query);
            if !terms.is_empty() {
                let mut term_lowers: Vec<String> =
                    terms.into_iter().map(|t| t.to_ascii_lowercase()).collect();
                term_lowers.retain(|t| !t.is_empty());

                let mut convo_lines: Vec<usize> = Vec::new();
                for (pos, msg) in cv.messages.iter().enumerate() {
                    let content_lower = msg.content.to_ascii_lowercase();
                    if term_lowers.iter().any(|t| content_lower.contains(t)) {
                        let line = if msg.idx >= 0 {
                            (msg.idx as usize) + 1
                        } else {
                            pos + 1
                        };
                        if line > 0 {
                            convo_lines.push(line);
                        }
                    }
                }

                convo_lines.sort_unstable();
                convo_lines.dedup();
                if !convo_lines.is_empty() {
                    // Union with the result-derived hit lines so we don't lose
                    // semantic-only hits that may not contain the literal query
                    // terms (or hits from other phases/modes).
                    lines.extend(convo_lines);
                }
            }
        }

        // Ensure the selected hit line is always navigable.
        if let Some(line) = selected_hit.line_number
            && line > 0
        {
            lines.push(line);
        }
        lines.sort_unstable();
        lines.dedup();
        lines
    }

    fn sync_detail_session_hit_state(&mut self, selected_hit: &SearchHit) {
        let prior_line = self
            .detail_session_hit_lines
            .get(self.detail_session_hit_current)
            .copied();

        self.detail_session_hit_lines = self.collect_session_hit_lines(selected_hit);

        // Preserve current navigation when possible (e.g. when the conversation finishes
        // loading), otherwise anchor to the selected hit.
        self.detail_session_hit_current = prior_line
            .and_then(|line| {
                self.detail_session_hit_lines
                    .iter()
                    .position(|n| *n == line)
            })
            .or_else(|| {
                selected_hit.line_number.and_then(|line| {
                    self.detail_session_hit_lines
                        .iter()
                        .position(|n| *n == line)
                })
            })
            .unwrap_or(0);
        self.detail_session_hit_offsets_cache.borrow_mut().clear();
    }

    fn selected_hits(&self) -> Vec<SearchHit> {
        let mut hits = Vec::new();
        let mut seen = HashSet::new();
        for pane in &self.panes {
            for hit in &pane.hits {
                let key = SelectedHitKey::from_hit(hit);
                if self.selected.contains(&key) && seen.insert(key) {
                    hits.push(hit.clone());
                }
            }
        }
        hits
    }

    /// Determine which UI region a mouse coordinate falls in.
    fn hit_test(&self, x: u16, y: u16) -> MouseHitRegion {
        if self.show_saved_views_modal {
            if let Some((_, row_idx)) = self
                .last_saved_view_row_areas
                .borrow()
                .iter()
                .find(|(rect, _)| rect.contains(x, y))
            {
                return MouseHitRegion::SavedViewRow { row_idx: *row_idx };
            }
            return MouseHitRegion::None;
        }

        if let Some(rect) = *self.last_split_handle_area.borrow()
            && rect.contains(x, y)
        {
            return MouseHitRegion::SplitHandle;
        }

        // Pane-aware hit testing: when multi-pane is active, each pane gets its own
        // row index mapping and scroll context.
        {
            let pane_rects = self.last_pane_rects.borrow();
            if !pane_rects.is_empty() {
                let first_idx = *self.last_pane_first_index.borrow();
                let term_w = self.last_content_area.borrow().map_or(120, |r| r.width);
                let row_h = self.density_mode.effective(term_w).row_height().max(1);
                for (vis_idx, rect) in pane_rects.iter().copied().enumerate() {
                    if !rect.contains(x, y) {
                        continue;
                    }
                    let pane_idx = first_idx + vis_idx;
                    let inner = Rect::new(
                        rect.x.saturating_add(1),
                        rect.y.saturating_add(1),
                        rect.width.saturating_sub(2),
                        rect.height.saturating_sub(2),
                    );
                    let row_in_viewport = if inner.height == 0 || y < inner.y {
                        0
                    } else {
                        ((y - inner.y) / row_h) as usize
                    };
                    let scroll = if pane_idx == self.active_pane {
                        self.results_list_state.borrow().scroll_offset()
                    } else {
                        0
                    };
                    let item_idx = scroll + row_in_viewport;
                    return MouseHitRegion::Results { pane_idx, item_idx };
                }
            }
        }

        // Single-pane fallback.
        if let Some(rect) = *self.last_results_inner.borrow()
            && rect.contains(x, y)
        {
            let term_w = self.last_content_area.borrow().map_or(120, |r| r.width);
            let row_h = self.density_mode.effective(term_w).row_height();
            let state = self.results_list_state.borrow();
            let scroll = state.scroll_offset();
            let row_in_viewport = ((y - rect.y) / row_h.max(1)) as usize;
            let item_idx = scroll + row_in_viewport;
            return MouseHitRegion::Results {
                pane_idx: self.active_pane,
                item_idx,
            };
        }
        if let Some(rect) = *self.last_detail_area.borrow()
            && rect.contains(x, y)
        {
            return MouseHitRegion::Detail;
        }
        if let Some((idx, _)) = self
            .last_pill_rects
            .borrow()
            .iter()
            .enumerate()
            .find(|(_, (rect, _))| rect.contains(x, y))
        {
            return MouseHitRegion::Pill { index: idx };
        }
        if let Some(rect) = *self.last_search_bar_area.borrow()
            && rect.contains(x, y)
        {
            return MouseHitRegion::SearchBar;
        }
        if let Some(rect) = *self.last_status_area.borrow()
            && rect.contains(x, y)
        {
            return MouseHitRegion::StatusBar;
        }
        MouseHitRegion::None
    }

    fn update_banner_visible(&self) -> bool {
        self.update_info
            .as_ref()
            .is_some_and(UpdateInfo::should_show)
            && !self.update_dismissed
    }

    fn can_handle_update_shortcuts(&self) -> bool {
        self.update_banner_visible()
            && self.input_mode == InputMode::Query
            && !self.show_help
            && !self.show_detail_modal
            && !self.show_bulk_modal
            && !self.show_saved_views_modal
            && !self.show_export_modal
            && !self.show_consent_dialog
            && !self.source_filter_menu_open
            && !self.command_palette.is_visible()
    }

    fn footer_hint_context_key(&self) -> &'static str {
        if self.show_export_modal
            || self.show_bulk_modal
            || self.show_saved_views_modal
            || self.show_consent_dialog
            || self.source_filter_menu_open
            || self.command_palette.is_visible()
            || self.show_help
            || self.show_detail_modal
        {
            return "modal";
        }

        if self.surface == AppSurface::Analytics {
            return match self.analytics_view {
                AnalyticsView::Dashboard => "analytics:dashboard",
                AnalyticsView::Explorer => "analytics:explorer",
                AnalyticsView::Heatmap => "analytics:heatmap",
                AnalyticsView::Breakdowns => "analytics:breakdowns",
                AnalyticsView::Tools => "analytics:tools",
                AnalyticsView::Plans => "analytics:plans",
                AnalyticsView::Coverage => "analytics:coverage",
            };
        }

        if self.surface == AppSurface::Sources {
            return "sources";
        }

        if self.input_mode != InputMode::Query {
            return "filter";
        }

        if self.focused_region() == FocusRegion::Detail {
            return "detail";
        }

        "results"
    }

    /// Translate a [`PaletteResult`] into a concrete `Cmd<CassMsg>`.
    ///
    /// This is the app-side half of the palette adapter layer. Most results
    /// map to a single `CassMsg`; `OpenUpdateBanner` requires `self` access.
    fn palette_result_to_cmd(&mut self, result: PaletteResult) -> ftui::Cmd<CassMsg> {
        match result {
            PaletteResult::ToggleTheme => ftui::Cmd::msg(CassMsg::ThemeToggled),
            PaletteResult::CycleDensity => ftui::Cmd::msg(CassMsg::DensityModeCycled),
            PaletteResult::ToggleHelpStrip => ftui::Cmd::msg(CassMsg::HelpPinToggled),
            PaletteResult::OpenUpdateBanner => {
                if let Some(info) = &self.update_info {
                    if info.should_show() {
                        self.update_dismissed = false;
                        self.update_upgrade_armed = false;
                        self.status = format!(
                            "Update available v{} -> v{} (U=upgrade, N=notes, S=skip, Esc=dismiss)",
                            info.current_version, info.latest_version
                        );
                    } else if info.is_skipped {
                        self.status = format!(
                            "v{} is currently skipped. Clear update_state.json to re-enable prompts.",
                            info.latest_version
                        );
                    } else {
                        self.status = "You're on the latest version.".to_string();
                    }
                } else {
                    self.status =
                        "No update information available yet. Check again shortly.".to_string();
                }
                ftui::Cmd::none()
            }
            PaletteResult::EnterInputMode(target) => {
                let mode = match target {
                    InputModeTarget::Agent => InputMode::Agent,
                    InputModeTarget::Workspace => InputMode::Workspace,
                    InputModeTarget::CreatedFrom => InputMode::CreatedFrom,
                };
                ftui::Cmd::msg(CassMsg::InputModeEntered(mode))
            }
            PaletteResult::SetTimeFilter { from } => {
                let now = chrono::Utc::now().timestamp();
                let from_ts = match from {
                    TimeFilterPreset::Today => now - (now % 86400),
                    TimeFilterPreset::LastWeek => now - (7 * 86400),
                };
                ftui::Cmd::msg(CassMsg::FilterTimeSet {
                    from: Some(from_ts),
                    to: None,
                })
            }
            PaletteResult::OpenSavedViews => ftui::Cmd::msg(CassMsg::SavedViewsOpened),
            PaletteResult::SaveViewSlot(slot) => ftui::Cmd::msg(CassMsg::ViewSaved(slot)),
            PaletteResult::LoadViewSlot(slot) => ftui::Cmd::msg(CassMsg::ViewLoaded(slot)),
            PaletteResult::OpenBulkActions => ftui::Cmd::msg(CassMsg::BulkActionsOpened),
            PaletteResult::ReloadIndex => ftui::Cmd::msg(CassMsg::IndexRefreshRequested),
            PaletteResult::OpenAnalyticsView(target) => {
                let view = match target {
                    AnalyticsTarget::Dashboard => AnalyticsView::Dashboard,
                    AnalyticsTarget::Explorer => AnalyticsView::Explorer,
                    AnalyticsTarget::Heatmap => AnalyticsView::Heatmap,
                    AnalyticsTarget::Breakdowns => AnalyticsView::Breakdowns,
                    AnalyticsTarget::Tools => AnalyticsView::Tools,
                    AnalyticsTarget::Plans => AnalyticsView::Plans,
                    AnalyticsTarget::Coverage => AnalyticsView::Coverage,
                };
                ftui::Cmd::batch(vec![
                    ftui::Cmd::msg(CassMsg::AnalyticsEntered),
                    ftui::Cmd::msg(CassMsg::AnalyticsViewChanged(view)),
                ])
            }
            PaletteResult::Screenshot(target) => {
                let fmt = match target {
                    ScreenshotTarget::Html => ScreenshotFormat::Html,
                    ScreenshotTarget::Svg => ScreenshotFormat::Svg,
                    ScreenshotTarget::Text => ScreenshotFormat::Text,
                };
                ftui::Cmd::msg(CassMsg::ScreenshotRequested(fmt))
            }
            PaletteResult::ToggleMacroRecording => ftui::Cmd::msg(CassMsg::MacroRecordingToggled),
            PaletteResult::OpenSources => ftui::Cmd::msg(CassMsg::SourcesEntered),
            PaletteResult::Noop => ftui::Cmd::none(),
        }
    }

    fn footer_hint_slots(width: u16) -> usize {
        LayoutBreakpoint::from_width(width)
            .visibility_policy()
            .footer_hint_slots as usize
    }

    fn footer_hint_budget(width: u16) -> usize {
        LayoutBreakpoint::from_width(width)
            .visibility_policy()
            .footer_hint_budget as usize
    }

    fn footer_hint_candidates(&self) -> Vec<FooterHintCandidate> {
        let mut hints = Vec::with_capacity(16);
        let contextual = HintContext::Mode(self.footer_hint_context_key().to_string());
        let mut push = |key: &'static str,
                        action: &'static str,
                        context: HintContext,
                        static_priority: u32| {
            hints.push(FooterHintCandidate {
                key,
                action,
                context,
                static_priority,
            });
        };

        match self.footer_hint_context_key() {
            "results" => {
                push(shortcuts::DETAIL_OPEN, "open", contextual.clone(), 1);
                if !self.selected.is_empty() {
                    // Bulk actions are the highest-value next action when
                    // selection exists; keep them ahead of secondary toggles.
                    push(shortcuts::BULK_MENU, "bulk", contextual.clone(), 2);
                    push(shortcuts::TOGGLE_SELECT, "select", contextual.clone(), 3);
                    push("Ctrl+O", "open", contextual.clone(), 4);
                    push(shortcuts::SEARCH_MODE, "mode", contextual.clone(), 5);
                    push(shortcuts::STATS_BAR, "stats", contextual.clone(), 6);
                    push(shortcuts::TAB_FOCUS, "focus", contextual.clone(), 7);
                    push(shortcuts::PANE_FILTER, "filter", contextual.clone(), 8);
                } else {
                    push(shortcuts::TOGGLE_SELECT, "select", contextual.clone(), 2);
                    push(shortcuts::SEARCH_MODE, "mode", contextual.clone(), 3);
                    push(shortcuts::TAB_FOCUS, "focus", contextual.clone(), 4);
                    push(shortcuts::STATS_BAR, "stats", contextual.clone(), 5);
                    push(shortcuts::PANE_FILTER, "filter", contextual.clone(), 6);
                }
            }
            "detail" => {
                push(shortcuts::TAB_FOCUS, "focus", contextual.clone(), 1);
                push(shortcuts::JSON_VIEW, "json", contextual.clone(), 2);
                push(shortcuts::PANE_FILTER, "find", contextual.clone(), 3);
                push(shortcuts::COPY, "copy", contextual.clone(), 4);
            }
            "filter" => {
                push(shortcuts::DETAIL_OPEN, "apply", contextual.clone(), 1);
                push(shortcuts::DETAIL_CLOSE, "cancel", contextual.clone(), 2);
                push(shortcuts::TAB_FOCUS, "next", contextual.clone(), 3);
            }
            ctx if ctx.starts_with("analytics:") => {
                // Common: view navigation + back
                push("←/→", "views", contextual.clone(), 1);

                // Per-subview contextual hints
                match self.analytics_view {
                    AnalyticsView::Dashboard => {
                        // Dashboard is read-only KPI wall — no special keys
                    }
                    AnalyticsView::Explorer => {
                        push("m", "metric", contextual.clone(), 2);
                        push("o", "overlay", contextual.clone(), 3);
                        push("g", "group", contextual.clone(), 4);
                        push("z", "zoom", contextual.clone(), 5);
                    }
                    AnalyticsView::Heatmap => {
                        push("Tab", "metric", contextual.clone(), 2);
                        if self.analytics_selectable_count() > 0 {
                            push("↑/↓", "select", contextual.clone(), 3);
                            push(shortcuts::DETAIL_OPEN, "drill", contextual.clone(), 4);
                        }
                    }
                    AnalyticsView::Breakdowns => {
                        push("Tab", "tab", contextual.clone(), 2);
                        if self.analytics_selectable_count() > 0 {
                            push("↑/↓", "select", contextual.clone(), 3);
                            push(shortcuts::DETAIL_OPEN, "drill", contextual.clone(), 4);
                        }
                    }
                    AnalyticsView::Tools | AnalyticsView::Plans | AnalyticsView::Coverage => {
                        if self.analytics_selectable_count() > 0 {
                            push("↑/↓", "select", contextual.clone(), 2);
                            push(shortcuts::DETAIL_OPEN, "drill", contextual.clone(), 3);
                        }
                    }
                }

                push(shortcuts::DETAIL_CLOSE, "back", contextual.clone(), 10);
            }
            "modal" => {
                push(shortcuts::TAB_FOCUS, "next", contextual.clone(), 1);
                push("Space", "toggle", contextual.clone(), 2);
                push(shortcuts::DETAIL_CLOSE, "close", contextual.clone(), 3);
            }
            _ => {}
        }

        // Global hints are low-priority fallback hints.
        push(shortcuts::HELP, "help", HintContext::Global, 20);
        push(shortcuts::THEME, "theme", HintContext::Global, 21);
        push(shortcuts::SEARCH_MODE, "mode", HintContext::Global, 22);
        push(
            shortcuts::SURFACE_ANALYTICS,
            "analytics",
            HintContext::Global,
            23,
        );
        push(shortcuts::DENSITY, "density", HintContext::Global, 24);
        push(shortcuts::BORDERS, "borders", HintContext::Global, 25);
        push(shortcuts::PALETTE, "palette", HintContext::Global, 26);
        push(shortcuts::DETAIL_CLOSE, "quit", HintContext::Global, 27);

        hints
    }

    fn build_contextual_footer_hints(&self, width: u16) -> String {
        let slots = Self::footer_hint_slots(width);
        if slots == 0 {
            return String::new();
        }

        let budget = Self::footer_hint_budget(width);
        let context_key = self.footer_hint_context_key();
        let mut ranker = HintRanker::new(RankerConfig {
            hysteresis: 0.15,
            voi_weight: 0.0,
            lambda: 0.02,
            ..RankerConfig::default()
        });
        let mut registry = HelpRegistry::new();
        registry.register(FOOTER_HINT_ROOT_ID, HelpContent::short("cass footer hints"));

        for candidate in self.footer_hint_candidates() {
            let token = candidate.token();
            let rank_id = ranker.register(
                token.clone(),
                token.len() as f64,
                candidate.context,
                candidate.static_priority,
            );
            let help_id = HelpId(rank_id as u64 + 1);
            registry.register(
                help_id,
                HelpContent {
                    short: token,
                    long: None,
                    keybindings: vec![Keybinding::new(candidate.key, candidate.action)],
                    see_also: vec![],
                },
            );
            let _ = registry.set_parent(help_id, FOOTER_HINT_ROOT_ID);
        }

        let (ordering, _ledger) = ranker.rank(Some(context_key));
        let mut picked = Vec::with_capacity(slots);
        let mut used = 0usize;
        for rank_id in ordering {
            if picked.len() >= slots {
                break;
            }
            let help_id = HelpId(rank_id as u64 + 1);
            let Some(help) = registry.resolve(help_id) else {
                continue;
            };
            let Some(binding) = help.keybindings.first() else {
                continue;
            };
            let token = format!("{}={}", binding.key, binding.action);
            let extra = if picked.is_empty() {
                token.len()
            } else {
                token.len() + 2
            };
            if used + extra > budget {
                continue;
            }
            used += extra;
            picked.push(token);
        }

        if picked.is_empty() {
            String::new()
        } else {
            format!(" | {}", picked.join("  "))
        }
    }

    fn build_surface_shell_line(
        &self,
        width: u16,
        styles: &StyleContext,
        apply_style: bool,
    ) -> ftui::text::Line {
        if width == 0 {
            return ftui::text::Line::raw(String::new());
        }

        let plain = ftui::Style::default();
        let bracket_style = if apply_style {
            styles.style(style_system::STYLE_TEXT_SUBTLE)
        } else {
            plain
        };
        let inactive_style = if apply_style {
            styles.style(style_system::STYLE_TEXT_MUTED)
        } else {
            plain
        };
        let key_style = if apply_style {
            styles.style(style_system::STYLE_KBD_KEY)
        } else {
            plain
        };
        let desc_style = if apply_style {
            styles.style(style_system::STYLE_KBD_DESC)
        } else {
            plain
        };
        let search_active_style = if apply_style {
            styles.style(style_system::STYLE_STATUS_INFO).bold()
        } else {
            plain
        };
        let analytics_active_style = if apply_style {
            styles.style(style_system::STYLE_STATUS_SUCCESS).bold()
        } else {
            plain
        };
        let sources_active_style = if apply_style {
            styles.style(style_system::STYLE_STATUS_WARNING).bold()
        } else {
            plain
        };

        let max_chars = width as usize;
        let mut used = 0usize;
        let mut spans: Vec<ftui::text::Span<'static>> = Vec::new();
        let mut try_push = |text: String, style: ftui::Style| -> bool {
            let chars = text.chars().count();
            if used + chars > max_chars {
                return false;
            }
            used += chars;
            spans.push(ftui::text::Span::styled(text, style));
            true
        };

        let _ = try_push(" ".to_string(), bracket_style);
        let surface_tabs = [
            (AppSurface::Search, "Search", search_active_style),
            (AppSurface::Analytics, "Analytics", analytics_active_style),
            (AppSurface::Sources, "Sources", sources_active_style),
        ];
        for (idx, (surface, label, active_style)) in surface_tabs.iter().enumerate() {
            if idx > 0 && !try_push(" ".to_string(), bracket_style) {
                break;
            }
            if !try_push("[".to_string(), bracket_style) {
                break;
            }
            let tab_style = if *surface == self.surface {
                *active_style
            } else {
                inactive_style
            };
            let tab_label = if *surface == self.surface {
                format!("● {label}")
            } else {
                (*label).to_string()
            };
            if !try_push(tab_label, tab_style) {
                break;
            }
            if !try_push("]".to_string(), bracket_style) {
                break;
            }
        }

        let hint_pairs = [
            (shortcuts::SURFACE_ANALYTICS, "analytics"),
            (shortcuts::SOURCES, "sources"),
            (shortcuts::PALETTE, "palette"),
            (shortcuts::HELP, "help"),
            (shortcuts::THEME, "theme"),
        ];
        let mut first_hint = true;
        for (key, action) in hint_pairs {
            let joiner = if first_hint { " | " } else { "  " };
            if !try_push(joiner.to_string(), bracket_style) {
                break;
            }
            if !try_push(key.to_string(), key_style) {
                break;
            }
            if !try_push("=".to_string(), bracket_style) {
                break;
            }
            if !try_push(action.to_string(), desc_style) {
                break;
            }
            first_hint = false;
        }

        if spans.is_empty() {
            spans.push(ftui::text::Span::styled(" ".to_string(), bracket_style));
        }
        ftui::text::Line::from_spans(spans)
    }

    fn sort_saved_views(&mut self) {
        self.saved_views.sort_by_key(|v| v.slot);
    }

    fn clamp_saved_views_selection(&mut self) {
        if self.saved_views.is_empty() {
            self.saved_views_selection = 0;
            return;
        }
        self.saved_views_selection = self
            .saved_views_selection
            .min(self.saved_views.len().saturating_sub(1));
    }

    fn selected_saved_view_slot(&self) -> Option<u8> {
        self.saved_views
            .get(self.saved_views_selection)
            .map(|v| v.slot)
    }

    fn selected_saved_view_label(&self) -> Option<String> {
        self.saved_views
            .get(self.saved_views_selection)
            .and_then(|v| v.label.clone())
    }

    fn move_saved_views_selection(&mut self, delta: i32) {
        if self.saved_views.is_empty() {
            self.saved_views_selection = 0;
            return;
        }
        let len = self.saved_views.len() as i64;
        let next = self.saved_views_selection as i64 + delta as i64;
        self.saved_views_selection = next.rem_euclid(len) as usize;
    }

    fn reorder_saved_views(&mut self, from_idx: usize, to_idx: usize) -> bool {
        if self.saved_views.is_empty() || from_idx == to_idx {
            return false;
        }
        if from_idx >= self.saved_views.len() || to_idx >= self.saved_views.len() {
            return false;
        }

        self.sort_saved_views();
        let mut ordered_slots: Vec<u8> = self.saved_views.iter().map(|v| v.slot).collect();
        ordered_slots.sort_unstable();

        let moved = self.saved_views.remove(from_idx);
        self.saved_views.insert(to_idx, moved);
        for (view, slot) in self.saved_views.iter_mut().zip(ordered_slots.into_iter()) {
            view.slot = slot;
        }
        self.saved_views_selection = to_idx.min(self.saved_views.len().saturating_sub(1));
        true
    }

    fn panel_ratio_from_mouse_x(&self, x: u16) -> Option<f64> {
        let area = self.last_content_area.borrow().as_ref().copied()?;
        if area.width < 4 {
            return None;
        }
        let rel_x = x
            .saturating_sub(area.x)
            .min(area.width.saturating_sub(1))
            .max(1);
        let ratio = rel_x as f64 / area.width as f64;
        Some(ratio.clamp(PANEL_RATIO_MIN, PANEL_RATIO_MAX))
    }

    fn apply_panel_ratio_from_mouse_x(&mut self, x: u16) -> bool {
        let Some(ratio) = self.panel_ratio_from_mouse_x(x) else {
            return false;
        };
        self.anim.set_panel_ratio(ratio);
        self.dirty_since = Some(Instant::now());
        true
    }

    /// Transition interaction back to result navigation semantics.
    ///
    /// Used by mouse result-row interactions so Enter behavior stays
    /// deterministic (open selected detail) instead of being captured by an
    /// unrelated non-query input mode.
    fn enter_results_navigation_context(&mut self) {
        self.focus_manager.focus(focus_ids::RESULTS_LIST);
        if self.input_mode != InputMode::Query {
            self.input_mode = InputMode::Query;
            self.input_buffer.clear();
        }
    }

    fn split_content_area(
        &self,
        area: Rect,
        min_left: u16,
        min_right: u16,
    ) -> (Rect, Rect, Option<Rect>) {
        if area.width < 2 {
            return (area, Rect::new(area.x, area.y, 0, area.height), None);
        }

        let width = area.width;
        let ratio = self
            .anim
            .panel_ratio_value()
            .clamp(PANEL_RATIO_MIN, PANEL_RATIO_MAX);
        let mut left_w = ((width as f64) * ratio).round() as u16;
        let lower = min_left.max(1).min(width.saturating_sub(1));
        let upper = width
            .saturating_sub(min_right.max(1))
            .max(1)
            .min(width.saturating_sub(1));
        left_w = if lower <= upper {
            left_w.clamp(lower, upper)
        } else {
            width / 2
        };
        left_w = left_w.clamp(1, width.saturating_sub(1));

        let right_w = width.saturating_sub(left_w);
        let left = Rect::new(area.x, area.y, left_w, area.height);
        let right = Rect::new(area.x + left_w, area.y, right_w, area.height);
        let handle = Rect::new(area.x + left_w.saturating_sub(1), area.y, 1, area.height);

        (left, right, Some(handle))
    }

    /// Capture the current undoable state as an `UndoEntry`.
    fn capture_undo_state(&self, description: &'static str) -> UndoEntry {
        UndoEntry {
            description,
            query: self.query.clone(),
            cursor_pos: self.cursor_pos,
            filters: self.filters.clone(),
            time_preset: self.time_preset,
            ranking_mode: self.ranking_mode,
            grouping_mode: self.grouping_mode,
        }
    }

    /// Restore undoable state from an `UndoEntry`, triggering a search if query/filters changed.
    fn restore_undo_state(&mut self, entry: UndoEntry) -> ftui::Cmd<CassMsg> {
        let search_changed = self.query != entry.query
            || self.filters != entry.filters
            || self.ranking_mode != entry.ranking_mode;
        let grouping_changed = self.grouping_mode != entry.grouping_mode;

        self.query = entry.query;
        self.cursor_pos = entry.cursor_pos;
        self.filters = entry.filters;
        self.time_preset = entry.time_preset;
        self.ranking_mode = entry.ranking_mode;
        self.grouping_mode = entry.grouping_mode;

        if grouping_changed {
            self.regroup_panes();
        }

        if search_changed {
            ftui::Cmd::msg(CassMsg::SearchRequested)
        } else {
            ftui::Cmd::none()
        }
    }

    /// Push current state onto undo stack before a mutation.
    fn push_undo(&mut self, description: &'static str) {
        let entry = self.capture_undo_state(description);
        self.undo_history.push(entry);
    }

    /// Re-group results into panes using the current `grouping_mode`.
    fn regroup_panes(&mut self) {
        let prev_active_key = self
            .panes
            .get(self.active_pane)
            .map(|pane| pane.agent.clone());
        let prev_active_hit = self.selected_hit().map(SelectedHitKey::from_hit);

        let mut pane_map: std::collections::BTreeMap<String, Vec<SearchHit>> =
            std::collections::BTreeMap::new();
        for hit in &self.results {
            if let Some(filter) = self.pane_filter.as_deref().filter(|s| !s.trim().is_empty())
                && !pane_filter_matches_hit(hit, filter)
            {
                continue;
            }
            let key = match self.grouping_mode {
                ResultsGrouping::Agent => hit.agent.clone(),
                ResultsGrouping::Conversation => {
                    // Use last path component of source_path as conversation key.
                    hit.source_path
                        .rsplit('/')
                        .next()
                        .unwrap_or(&hit.source_path)
                        .to_string()
                }
                ResultsGrouping::Workspace => {
                    let w = &hit.workspace;
                    if w.is_empty() {
                        "(none)".to_string()
                    } else {
                        w.rsplit('/').next().unwrap_or(w).to_string()
                    }
                }
                ResultsGrouping::Flat => "All".to_string(),
            };
            pane_map.entry(key).or_default().push(hit.clone());
        }
        self.panes = pane_map
            .into_iter()
            .map(|(key, hits)| {
                let total = hits.len();
                AgentPane {
                    agent: key,
                    hits,
                    selected: 0,
                    total_count: total,
                }
            })
            .collect();

        if let Some(active_key) = prev_active_key
            && let Some(idx) = self.panes.iter().position(|pane| pane.agent == active_key)
        {
            self.active_pane = idx;
        }
        if self.active_pane >= self.panes.len() {
            self.active_pane = self.panes.len().saturating_sub(1);
        }

        if let Some(key) = prev_active_hit
            && let Some(pane) = self.panes.get_mut(self.active_pane)
            && let Some(idx) = pane
                .hits
                .iter()
                .position(|hit| SelectedHitKey::from_hit(hit) == key)
        {
            pane.selected = idx;
        }

        for pane in &mut self.panes {
            if pane.hits.is_empty() {
                pane.selected = 0;
            } else if pane.selected >= pane.hits.len() {
                pane.selected = pane.hits.len() - 1;
            }
        }

        if let Some(pane) = self.panes.get(self.active_pane) {
            let mut state = self.results_list_state.borrow_mut();
            state.select(Some(pane.selected));
        }

        self.adjust_pane_scroll_offset();
    }

    fn visible_pane_capacity(&self) -> usize {
        self.last_content_area
            .borrow()
            .map_or(MAX_VISIBLE_PANES, |rect| {
                max_visible_panes_for_width(rect.width)
            })
            .max(1)
    }

    fn adjust_pane_scroll_offset(&mut self) {
        if self.panes.is_empty() {
            self.pane_scroll_offset = 0;
            return;
        }

        let visible = self.visible_pane_capacity().min(self.panes.len()).max(1);
        let max_start = self.panes.len().saturating_sub(visible);
        if self.pane_scroll_offset > max_start {
            self.pane_scroll_offset = max_start;
        }

        if self.active_pane < self.pane_scroll_offset {
            self.pane_scroll_offset = self.active_pane;
        } else if self.active_pane >= self.pane_scroll_offset + visible {
            self.pane_scroll_offset = self.active_pane.saturating_sub(visible - 1);
        }
    }

    /// Find the index of the next/previous day boundary in the active pane.
    fn timeline_jump_index(&self, forward: bool) -> Option<usize> {
        let pane = self.panes.get(self.active_pane)?;
        if pane.hits.is_empty() {
            return None;
        }
        let current_idx = pane.selected;
        let current_day = pane.hits.get(current_idx)?.created_at.unwrap_or(0) / 86400;

        if forward {
            for i in (current_idx + 1)..pane.hits.len() {
                let day = pane.hits[i].created_at.unwrap_or(0) / 86400;
                if day != current_day {
                    return Some(i);
                }
            }
        } else {
            for i in (0..current_idx).rev() {
                let day = pane.hits[i].created_at.unwrap_or(0) / 86400;
                if day != current_day {
                    // Jump to the first hit of that previous day.
                    let first = (0..=i)
                        .rev()
                        .take_while(|&j| pane.hits[j].created_at.unwrap_or(0) / 86400 == day)
                        .last()
                        .unwrap_or(i);
                    return Some(first);
                }
            }
        }
        None
    }

    fn input_autocomplete_candidates(&self) -> BTreeSet<String> {
        let mut candidates = BTreeSet::new();
        match self.input_mode {
            InputMode::Agent => {
                for slug in INPUT_AUTOCOMPLETE_AGENT_HINTS {
                    candidates.insert((*slug).to_string());
                }
                for agent in &self.filters.agents {
                    let trimmed = agent.trim();
                    if !trimmed.is_empty() {
                        candidates.insert(trimmed.to_string());
                    }
                }
                for pane in &self.panes {
                    let trimmed = pane.agent.trim();
                    if !trimmed.is_empty() {
                        candidates.insert(trimmed.to_string());
                    }
                }
                for hit in &self.results {
                    let trimmed = hit.agent.trim();
                    if !trimmed.is_empty() {
                        candidates.insert(trimmed.to_string());
                    }
                }
            }
            InputMode::Workspace => {
                for workspace in &self.filters.workspaces {
                    let trimmed = workspace.trim();
                    if !trimmed.is_empty() {
                        candidates.insert(trimmed.to_string());
                    }
                }
                if let Some(known_workspaces) = &self.known_workspaces {
                    for workspace in known_workspaces {
                        let trimmed = workspace.trim();
                        if !trimmed.is_empty() {
                            candidates.insert(trimmed.to_string());
                        }
                    }
                }
                for hit in &self.results {
                    let trimmed = hit.workspace.trim();
                    if !trimmed.is_empty() {
                        candidates.insert(trimmed.to_string());
                    }
                    if let Some(workspace_original) = &hit.workspace_original {
                        let trimmed = workspace_original.trim();
                        if !trimmed.is_empty() {
                            candidates.insert(trimmed.to_string());
                        }
                    }
                }
            }
            _ => {}
        }
        candidates
    }

    fn autocomplete_input_buffer(&self) -> Option<String> {
        let candidates = self.input_autocomplete_candidates();
        autocomplete_csv_suffix(&self.input_buffer, &candidates)
    }

    fn refresh_available_source_ids(&mut self) {
        let mut ids = BTreeSet::new();
        for hit in &self.results {
            if hit.source_id != "local" {
                ids.insert(hit.source_id.clone());
            }
        }
        if let SourceFilter::SourceId(id) = &self.filters.source_filter {
            ids.insert(id.clone());
        }
        self.available_source_ids = ids.into_iter().collect();
    }

    fn source_menu_items(&self) -> Vec<(String, SourceFilter)> {
        let mut items = vec![
            ("All sources".to_string(), SourceFilter::All),
            ("Local only".to_string(), SourceFilter::Local),
            ("Remote only".to_string(), SourceFilter::Remote),
        ];
        items.extend(
            self.available_source_ids
                .iter()
                .cloned()
                .map(|id| (format!("Source: {id}"), SourceFilter::SourceId(id))),
        );
        items
    }

    fn source_menu_total_items(&self) -> usize {
        3 + self.available_source_ids.len()
    }

    fn move_source_menu_selection(&mut self, delta: i32) {
        let total = self.source_menu_total_items().max(1);
        let cur = self.source_filter_menu_selection as i32 + delta;
        self.source_filter_menu_selection = cur.clamp(0, total as i32 - 1) as usize;
    }

    fn source_filter_from_menu_selection(&self) -> SourceFilter {
        match self.source_filter_menu_selection {
            0 => SourceFilter::All,
            1 => SourceFilter::Local,
            2 => SourceFilter::Remote,
            n => self
                .available_source_ids
                .get(n.saturating_sub(3))
                .cloned()
                .map(SourceFilter::SourceId)
                .unwrap_or(SourceFilter::All),
        }
    }

    fn source_filter_status(filter: &SourceFilter) -> String {
        match filter {
            SourceFilter::All => "all sources".to_string(),
            SourceFilter::Local => "local only".to_string(),
            SourceFilter::Remote => "remote only".to_string(),
            SourceFilter::SourceId(id) => format!("source '{id}'"),
        }
    }

    fn filter_pills(&self) -> Vec<Pill> {
        let mut pills = Vec::new();

        // Agent filter — active if set, inactive placeholder otherwise
        if !self.filters.agents.is_empty() {
            pills.push(Pill {
                label: "agent".to_string(),
                value: summarize_filter_values(&self.filters.agents, "all"),
                active: true,
                editable: true,
            });
        } else {
            pills.push(Pill {
                label: "agent".to_string(),
                value: "any".to_string(),
                active: false,
                editable: true,
            });
        }

        // Workspace filter
        if !self.filters.workspaces.is_empty() {
            pills.push(Pill {
                label: "ws".to_string(),
                value: summarize_filter_values(&self.filters.workspaces, "all"),
                active: true,
                editable: true,
            });
        } else {
            pills.push(Pill {
                label: "ws".to_string(),
                value: "any".to_string(),
                active: false,
                editable: true,
            });
        }

        // Time filter
        if let Some(time) = format_time_chip(self.filters.created_from, self.filters.created_to) {
            pills.push(Pill {
                label: "time".to_string(),
                value: time,
                active: true,
                editable: true,
            });
        } else {
            pills.push(Pill {
                label: "time".to_string(),
                value: "all".to_string(),
                active: false,
                editable: true,
            });
        }

        // Source filter
        if !self.filters.source_filter.is_all() {
            pills.push(Pill {
                label: "source".to_string(),
                value: self.filters.source_filter.to_string(),
                active: true,
                editable: true,
            });
        } else {
            pills.push(Pill {
                label: "source".to_string(),
                value: "all".to_string(),
                active: false,
                editable: true,
            });
        }

        // Pane filter — only shown when active (no inactive placeholder)
        if let Some(pane_filter) = self.pane_filter.as_deref().filter(|s| !s.trim().is_empty()) {
            pills.push(Pill {
                label: "pane".to_string(),
                value: pane_filter.to_string(),
                active: true,
                editable: true,
            });
        }

        pills
    }

    fn build_pills_row(
        &self,
        area: Rect,
        pills: &[Pill],
        active_style: ftui::Style,
        inactive_style: ftui::Style,
        label_style: ftui::Style,
        separator_style: ftui::Style,
    ) -> (ftui::text::Line, Vec<(Rect, Pill)>) {
        if area.is_empty() {
            return (ftui::text::Line::from_spans(vec![]), Vec::new());
        }
        if pills.is_empty() {
            return (
                ftui::text::Line::from_spans(vec![ftui::text::Span::styled(
                    "No active filters",
                    separator_style,
                )]),
                Vec::new(),
            );
        }

        let mut spans: Vec<ftui::text::Span> = Vec::new();
        let mut rects: Vec<(Rect, Pill)> = Vec::new();
        let mut x = area.x;
        let end_x = area.x.saturating_add(area.width);

        for (idx, pill) in pills.iter().enumerate() {
            if x >= end_x {
                break;
            }
            if idx > 0 {
                spans.push(ftui::text::Span::styled(" ", separator_style));
                x = x.saturating_add(1);
            }

            let raw = format!("[{}:{}]", pill.label, pill.value);
            // Reserve 1 char for the edit-cue glyph on editable inactive pills
            // so the pill text + glyph never overflows the available area.
            let cue_reserve: usize = if pill.editable && !pill.active { 1 } else { 0 };
            let max_chars = usize::from(end_x.saturating_sub(x)).saturating_sub(cue_reserve);
            let rendered = elide_text(&raw, max_chars);
            if rendered.is_empty() {
                break;
            }
            let base_width = rendered.chars().count() as u16;
            // Editable inactive pills get a 1-char pencil glyph; account for
            // it in both hit-rect width and x-advance so click targets stay
            // accurate and subsequent pills don't overlap.
            let cue_extra: u16 = if pill.editable && !pill.active { 1 } else { 0 };
            let width = base_width.saturating_add(cue_extra);

            // Per-pill styling:
            // - active pills: bold accent fg + tinted bg (via active_style)
            // - inactive pills: dim muted fg + faint bg (via inactive_style)
            // - editable pills: underlined label + italic value as "click-to-edit" cue
            // - editable + inactive: pencil glyph prefix on value to reinforce editability
            let mut value_style = if pill.active {
                active_style
            } else {
                inactive_style
            };
            let mut label_part_style = if pill.active {
                if let Some(bg) = active_style.bg {
                    label_style.bg(bg)
                } else {
                    label_style
                }
            } else {
                inactive_style
            };
            if pill.editable {
                label_part_style = label_part_style.underline();
                value_style = value_style.italic();
            }

            // Split rendered text into label and value parts at the ':'
            if let Some(colon_pos) = rendered.find(':') {
                let label_part = &rendered[..=colon_pos];
                let value_part = &rendered[colon_pos + 1..];
                spans.push(ftui::text::Span::styled(
                    label_part.to_string(),
                    label_part_style,
                ));
                // Editable inactive pills show a pencil glyph to reinforce
                // that clicking will open an editor, even in the inactive state.
                if pill.editable && !pill.active {
                    spans.push(ftui::text::Span::styled("\u{270E}", label_part_style));
                }
                spans.push(ftui::text::Span::styled(
                    value_part.to_string(),
                    value_style,
                ));
            } else {
                spans.push(ftui::text::Span::styled(rendered, value_style));
            }

            rects.push((Rect::new(x, area.y, width, 1), pill.clone()));
            x = x.saturating_add(width);
        }

        if spans.is_empty() {
            spans.push(ftui::text::Span::styled(
                "No active filters",
                separator_style,
            ));
        }
        (ftui::text::Line::from_spans(spans), rects)
    }

    fn breadcrumb_line(
        &self,
        width: u16,
        active_style: ftui::Style,
        inactive_style: ftui::Style,
        separator_style: ftui::Style,
    ) -> ftui::text::Line {
        let agent_text = summarize_filter_values(&self.filters.agents, "All agents");
        let agent_active = !self.filters.agents.is_empty();

        let ws_text = summarize_filter_values(&self.filters.workspaces, "All workspaces");
        let ws_active = !self.filters.workspaces.is_empty();

        let time_text = format_time_chip(self.filters.created_from, self.filters.created_to)
            .unwrap_or_else(|| "Any time".to_string());
        let time_active = self.filters.created_from.is_some() || self.filters.created_to.is_some();

        let ranking_text = ranking_mode_label(self.ranking_mode).to_string();

        let source_text = if self.filters.source_filter.is_all() {
            "all sources".to_string()
        } else {
            format!("source {}", self.filters.source_filter)
        };
        let source_active = !self.filters.source_filter.is_all();

        let sep = " \u{203a} "; // ›

        // Build segments: (text, is_active)
        let segments = [
            (agent_text, agent_active),
            (ws_text, ws_active),
            (time_text, time_active),
            (ranking_text, true), // ranking mode is always "active" context
            (source_text, source_active),
        ];

        // Check total width — if it fits, render with spans; if not, elide
        let total_len: usize =
            segments.iter().map(|(t, _)| t.len()).sum::<usize>() + sep.len() * (segments.len() - 1);

        if total_len > width as usize {
            // Fall back to elided flat text with per-crumb styling
            let mut spans = Vec::new();
            let mut used = 0usize;
            let budget = width as usize;

            for (i, (text, is_active)) in segments.iter().enumerate() {
                if i > 0 {
                    if used + sep.len() > budget {
                        break;
                    }
                    spans.push(ftui::text::Span::styled(sep, separator_style));
                    used += sep.len();
                }
                let remaining = budget.saturating_sub(used);
                let elided = elide_text(text, remaining);
                if elided.is_empty() {
                    break;
                }
                used += elided.chars().count();
                let style = if *is_active {
                    active_style
                } else {
                    inactive_style
                };
                spans.push(ftui::text::Span::styled(elided, style));
            }
            ftui::text::Line::from_spans(spans)
        } else {
            let mut spans = Vec::new();
            for (i, (text, is_active)) in segments.iter().enumerate() {
                if i > 0 {
                    spans.push(ftui::text::Span::styled(sep, separator_style));
                }
                let style = if *is_active {
                    active_style
                } else {
                    inactive_style
                };
                spans.push(ftui::text::Span::styled(text.clone(), style));
            }
            ftui::text::Line::from_spans(spans)
        }
    }

    fn results_reveal_motion_enabled(
        &self,
        degradation: ftui::render::budget::DegradationLevel,
        hit_count: usize,
    ) -> bool {
        self.anim.enabled
            && degradation.is_full()
            && (RESULTS_REVEAL_MIN_HITS..=RESULTS_REVEAL_MAX_HITS).contains(&hit_count)
    }

    fn loading_spinner_glyph(&self) -> &'static str {
        const FRAMES: [&str; 4] = ["|", "/", "-", "\\"];
        FRAMES[self.spinner_frame % FRAMES.len()]
    }

    fn loading_hud_token(&self) -> Option<String> {
        self.loading_context
            .map(|ctx| format!("{} {}", self.loading_spinner_glyph(), ctx.label()))
    }

    fn set_loading_context(&mut self, context: LoadingContext) {
        self.loading_context = Some(context);
    }

    fn clear_loading_context(&mut self, context: LoadingContext) {
        if self.loading_context.is_some_and(|active| active == context) {
            self.loading_context = None;
        }
    }

    fn schedule_analytics_reload(&mut self) -> ftui::Cmd<CassMsg> {
        if self.db_reader.is_none() {
            self.clear_loading_context(LoadingContext::Analytics);
            return ftui::Cmd::none();
        }
        self.set_loading_context(LoadingContext::Analytics);
        ftui::Cmd::msg(CassMsg::AnalyticsLoadRequested)
    }

    fn view_transition_motion_enabled(
        &self,
        degradation: ftui::render::budget::DegradationLevel,
    ) -> bool {
        self.anim.enabled
            && !matches!(
                degradation,
                ftui::render::budget::DegradationLevel::EssentialOnly
                    | ftui::render::budget::DegradationLevel::Skeleton
                    | ftui::render::budget::DegradationLevel::SkipFrame
            )
    }

    fn capture_view_transition_snapshot(&self, frame: &super::ftui_adapter::Frame) {
        let snapshot = ViewSnapshot {
            surface: self.surface,
            analytics_view: if self.surface == AppSurface::Analytics {
                Some(self.analytics_view)
            } else {
                None
            },
            buffer: frame.buffer.clone(),
        };
        *self.view_transition_snapshot.borrow_mut() = Some(snapshot);
    }

    fn latest_surface_snapshot(&self, surface: AppSurface) -> Option<ftui::Buffer> {
        self.view_transition_snapshot
            .borrow()
            .as_ref()
            .filter(|snapshot| snapshot.surface == surface)
            .map(|snapshot| snapshot.buffer.clone())
    }

    fn latest_analytics_snapshot(&self, view: AnalyticsView) -> Option<ftui::Buffer> {
        self.view_transition_snapshot
            .borrow()
            .as_ref()
            .filter(|snapshot| {
                snapshot.surface == AppSurface::Analytics
                    && snapshot
                        .analytics_view
                        .is_some_and(|analytics| analytics == view)
            })
            .map(|snapshot| snapshot.buffer.clone())
    }

    fn shifted_copy_geometry(area: Rect, shift_cols: i16) -> Option<(Rect, u16)> {
        if area.is_empty() || area.width == 0 {
            return None;
        }
        if shift_cols == 0 {
            return Some((area, area.x));
        }
        let shift_abs = shift_cols.unsigned_abs();
        if shift_abs >= area.width {
            return None;
        }
        let visible_w = area.width.saturating_sub(shift_abs);
        if shift_cols > 0 {
            Some((
                Rect::new(area.x, area.y, visible_w, area.height),
                area.x.saturating_add(shift_abs),
            ))
        } else {
            Some((
                Rect::new(
                    area.x.saturating_add(shift_abs),
                    area.y,
                    visible_w,
                    area.height,
                ),
                area.x,
            ))
        }
    }

    fn start_surface_transition(&mut self, from: AppSurface, to: AppSurface) {
        if from == to || !self.anim.enabled {
            self.view_transition = None;
            return;
        }
        let slide_direction = if to.nav_order() >= from.nav_order() {
            -1
        } else {
            1
        };
        self.view_transition = Some(ViewTransition::new(
            from.label(),
            to.label(),
            SURFACE_TRANSITION_DURATION,
            self.latest_surface_snapshot(from),
            slide_direction,
        ));
    }

    fn start_analytics_view_transition(&mut self, from: AnalyticsView, to: AnalyticsView) {
        if from == to || !self.anim.enabled {
            return;
        }
        let slide_direction = if to.nav_order() >= from.nav_order() {
            -1
        } else {
            1
        };
        self.view_transition = Some(ViewTransition::new(
            format!("Analytics {}", from.label()),
            format!("Analytics {}", to.label()),
            ANALYTICS_VIEW_TRANSITION_DURATION,
            self.latest_analytics_snapshot(from),
            slide_direction,
        ));
    }

    fn render_view_transition_overlay(
        &self,
        frame: &mut super::ftui_adapter::Frame,
        area: Rect,
        styles: &StyleContext,
        degradation: ftui::render::budget::DegradationLevel,
        apply_style: bool,
    ) {
        if !apply_style || !self.view_transition_motion_enabled(degradation) {
            return;
        }
        let Some(transition) = self.view_transition.as_ref() else {
            return;
        };
        if area.is_empty() || area.height == 0 {
            return;
        }

        let now = Instant::now();
        let progress = transition.progress(now);
        if progress >= 1.0 {
            return;
        }
        let eased = transition.eased_progress(now);

        if let Some(snapshot) = transition.from_snapshot.as_ref() {
            let copy_area = area.intersection(&snapshot.bounds());
            if !copy_area.is_empty() {
                let max_slide = ((copy_area.width as f32) * 0.16).round().clamp(4.0, 18.0) as i16;
                let slide_cols = ((max_slide as f32) * eased).round() as i16;
                let shift = transition.slide_direction * slide_cols;
                if let Some((src_rect, dst_x)) = Self::shifted_copy_geometry(copy_area, shift) {
                    let outgoing_opacity = ((1.0 - eased) * 0.92).clamp(0.0, 1.0);
                    if outgoing_opacity > 0.01 {
                        frame.buffer.push_scissor(copy_area);
                        frame.buffer.push_opacity(outgoing_opacity);
                        frame
                            .buffer
                            .copy_from(snapshot, src_rect, dst_x, src_rect.y);
                        frame.buffer.pop_opacity();
                        frame.buffer.pop_scissor();
                    }
                }
            }
        }

        let edge_mix = (1.0 - eased).clamp(0.0, 1.0);
        if edge_mix <= 0.01 {
            return;
        }
        let accent = styles
            .style(style_system::STYLE_STATUS_INFO)
            .fg
            .unwrap_or(ftui::PackedRgba::rgb(80, 160, 240));
        let pane_bg = styles
            .style(style_system::STYLE_PANE_BASE)
            .bg
            .unwrap_or(ftui::PackedRgba::rgb(10, 12, 16));
        let edge_color = ftui::PackedRgba::rgb(
            lerp_u8(pane_bg.r(), accent.r(), 0.35 + edge_mix * 0.45),
            lerp_u8(pane_bg.g(), accent.g(), 0.35 + edge_mix * 0.45),
            lerp_u8(pane_bg.b(), accent.b(), 0.35 + edge_mix * 0.45),
        );
        let max_slide = ((area.width as f32) * 0.16).round().clamp(4.0, 18.0) as i16;
        let slide_cols = ((max_slide as f32) * eased).round() as i16;
        let shift = transition.slide_direction * slide_cols;
        let edge_x = if shift <= 0 {
            area.x
                .saturating_add(area.width.saturating_sub(1))
                .saturating_sub(shift.unsigned_abs())
        } else {
            area.x
                .saturating_add(shift.unsigned_abs().saturating_sub(1))
        }
        .min(area.x.saturating_add(area.width.saturating_sub(1)));
        Block::new()
            .style(ftui::Style::new().bg(edge_color))
            .render(Rect::new(edge_x, area.y, 1, area.height), frame);

        let label = format!(" {} -> {} ", transition.from_label, transition.to_label);
        let label_w = label.chars().count() as u16;
        if label_w > 0 && label_w < area.width {
            let label_x = area
                .x
                .saturating_add(area.width.saturating_sub(label_w))
                .saturating_sub(1);
            let label_area = Rect::new(label_x, area.y, label_w, 1);
            Paragraph::new(label)
                .style(styles.style(style_system::STYLE_KBD_KEY))
                .render(label_area, frame);
        }
    }

    fn results_focus_flash_intensity(
        &self,
        degradation: ftui::render::budget::DegradationLevel,
        results_focused: bool,
    ) -> f32 {
        if !results_focused || !self.anim.enabled || !degradation.is_full() {
            return 0.0;
        }
        (1.0 - self.anim.focus_flash_progress()).clamp(0.0, 1.0)
    }

    fn filtered_result_hits_for_stats(&self) -> Vec<&SearchHit> {
        let pane_filter = self.pane_filter.as_deref().filter(|s| !s.trim().is_empty());
        if !self.results.is_empty() {
            self.results
                .iter()
                .filter(|hit| {
                    if let Some(filter) = pane_filter {
                        pane_filter_matches_hit(hit, filter)
                    } else {
                        true
                    }
                })
                .collect()
        } else {
            self.panes
                .iter()
                .flat_map(|pane| pane.hits.iter())
                .filter(|hit| {
                    if let Some(filter) = pane_filter {
                        pane_filter_matches_hit(hit, filter)
                    } else {
                        true
                    }
                })
                .collect()
        }
    }

    fn build_result_row_mini_analytics_map(&self) -> HashMap<(String, String), RowMiniAnalytics> {
        let mut by_session: HashMap<(String, String), RowMiniAnalytics> = HashMap::new();
        for hit in self.filtered_result_hits_for_stats() {
            let key = (hit.source_id.clone(), hit.source_path.clone());
            let entry = by_session.entry(key).or_default();
            entry.matched_messages += 1;
        }
        by_session
    }

    /// Build the aggregate stats line for the results pane bottom bar.
    fn build_results_stats_line(&self, width: u16, styles: &StyleContext) -> ftui::text::Line {
        let label_s = styles.style(style_system::STYLE_TEXT_SUBTLE);
        let value_s = styles.style(style_system::STYLE_TEXT_PRIMARY);
        let sep = ftui::text::Span::styled(" \u{2502} ", label_s);
        let stats_hits = self.filtered_result_hits_for_stats();

        let total_messages: usize = stats_hits.len();
        let mut session_keys: HashSet<(String, String)> = HashSet::new();
        let mut timestamps: Vec<i64> = Vec::new();
        for hit in &stats_hits {
            session_keys.insert((hit.source_id.clone(), hit.source_path.clone()));
            if let Some(ts) = hit.created_at {
                timestamps.push(ts);
            }
        }
        let mut spans: Vec<ftui::text::Span> = vec![
            ftui::text::Span::styled(format_compact_metric(session_keys.len() as i64), value_s),
            ftui::text::Span::styled(" sessions", label_s),
            sep.clone(),
            ftui::text::Span::styled(format_compact_metric(total_messages as i64), value_s),
            ftui::text::Span::styled(" msgs", label_s),
        ];

        if !timestamps.is_empty() {
            timestamps.sort_unstable();
            let newest = timestamps.last().copied().unwrap_or(0);
            let newest_dt = if newest.abs() >= 10_000_000_000 {
                chrono::DateTime::from_timestamp_millis(newest)
            } else {
                chrono::DateTime::from_timestamp(newest, 0)
            };
            if let Some(dt) = newest_dt {
                spans.push(sep.clone());
                spans.push(ftui::text::Span::styled(
                    format!("newest: {}", dt.format("%Y-%m-%d")),
                    label_s,
                ));
            }
        }

        if timestamps.len() >= 3 {
            let spark_width = (width as usize).saturating_sub(70).clamp(8, 30);
            let t_min = timestamps[0];
            let t_max = timestamps[timestamps.len() - 1];
            if t_max > t_min {
                let blocks: &[char] = &[
                    ' ', '\u{2581}', '\u{2582}', '\u{2583}', '\u{2584}', '\u{2585}', '\u{2586}',
                    '\u{2587}', '\u{2588}',
                ];
                let mut buckets = vec![0u32; spark_width];
                let range = (t_max - t_min) as f64;
                for &ts in &timestamps {
                    let idx = (((ts - t_min) as f64 / range) * (spark_width - 1) as f64) as usize;
                    buckets[idx.min(spark_width - 1)] += 1;
                }
                let max_bucket = *buckets.iter().max().unwrap_or(&1);
                if max_bucket > 0 {
                    let sparkline: String = buckets
                        .iter()
                        .map(|&bucket| {
                            let level = (bucket as f64 / max_bucket as f64 * 8.0) as usize;
                            blocks[level.min(8)]
                        })
                        .collect();
                    spans.push(sep);
                    spans.push(ftui::text::Span::styled(sparkline, value_s));
                }
            }
        }

        ftui::text::Line::from_spans(spans)
    }

    /// Build a compact "overview strip" for the top of the results pane.
    ///
    /// This complements the bottom stats bar with at-a-glance routing signals:
    /// active pane, hit/selection totals, match-quality mix, and source scope.
    fn build_results_overview_line(
        &self,
        width: u16,
        total_hits: usize,
        pane_count: usize,
        styles: &StyleContext,
    ) -> ftui::text::Line {
        if width == 0 {
            return ftui::text::Line::raw(String::new());
        }

        let label_s = styles.style(style_system::STYLE_TEXT_SUBTLE);
        let value_s = styles.style(style_system::STYLE_TEXT_PRIMARY);
        let success_s = styles.style(style_system::STYLE_STATUS_SUCCESS);
        let info_s = styles.style(style_system::STYLE_STATUS_INFO);
        let warn_s = styles.style(style_system::STYLE_STATUS_WARNING);

        let mut exact = 0usize;
        let mut prefix = 0usize;
        let mut fuzzy = 0usize;
        for hit in self.filtered_result_hits_for_stats() {
            match hit.match_type {
                MatchType::Exact => exact += 1,
                MatchType::Prefix => prefix += 1,
                MatchType::ImplicitWildcard
                | MatchType::Wildcard
                | MatchType::Suffix
                | MatchType::Substring => fuzzy += 1,
            }
        }
        let total_match_kinds = exact + prefix + fuzzy;
        let mix_token = if total_match_kinds == 0 {
            "···".to_string()
        } else {
            const BLOCKS: [char; 9] = [
                ' ', '\u{2581}', '\u{2582}', '\u{2583}', '\u{2584}', '\u{2585}', '\u{2586}',
                '\u{2587}', '\u{2588}',
            ];
            let level = |count: usize| -> char {
                let ratio = count as f64 / total_match_kinds as f64;
                let idx = (ratio * 8.0).round() as usize;
                BLOCKS[idx.min(8)]
            };
            format!("{}{}{}", level(exact), level(prefix), level(fuzzy))
        };
        let mix_style = if total_match_kinds == 0 {
            value_s
        } else if fuzzy * 2 >= total_match_kinds {
            warn_s
        } else if exact >= prefix && exact >= fuzzy {
            success_s
        } else {
            info_s
        };

        let active_pane_label = if pane_count > 1 {
            self.panes
                .get(self.active_pane)
                .map(|pane| display_group_name(&pane.agent))
                .unwrap_or_else(|| "Mixed".to_string())
        } else {
            "Mixed".to_string()
        };
        let active_pane_idx = if pane_count == 0 {
            "0/0".to_string()
        } else {
            format!(
                "{}/{}",
                self.active_pane.saturating_add(1).min(pane_count),
                pane_count
            )
        };
        let source_scope = if self.filters.source_filter.is_all() {
            "all".to_string()
        } else {
            self.filters.source_filter.to_string()
        };

        let lanes = vec![
            ("pane", active_pane_label, value_s),
            ("idx", active_pane_idx, info_s),
            ("hits", total_hits.to_string(), value_s),
            ("sel", self.selected.len().to_string(), info_s),
            ("exact", exact.to_string(), success_s),
            ("prefix", prefix.to_string(), info_s),
            ("fuzzy", fuzzy.to_string(), warn_s),
            ("mix", mix_token, mix_style),
            ("src", source_scope, value_s),
        ];

        let max_chars = width as usize;
        let mut used = 0usize;
        let mut spans: Vec<ftui::text::Span<'static>> = Vec::new();
        for (key, value, style) in lanes {
            let lane_chars = key.chars().count() + value.chars().count() + 3; // [k:v]
            let prefix = 1;
            if used + prefix + lane_chars > max_chars {
                break;
            }
            spans.push(ftui::text::Span::styled(" ", label_s));
            spans.push(ftui::text::Span::styled("[", label_s));
            spans.push(ftui::text::Span::styled(key.to_string(), label_s));
            spans.push(ftui::text::Span::styled(":", label_s));
            spans.push(ftui::text::Span::styled(value, style));
            spans.push(ftui::text::Span::styled("]", label_s));
            used += prefix + lane_chars;
        }

        if spans.is_empty() {
            spans.push(ftui::text::Span::styled(" ", label_s));
        }
        ftui::text::Line::from_spans(spans)
    }

    /// Render the results list pane using VirtualizedList for O(visible) rendering.
    #[allow(clippy::too_many_arguments)]
    fn render_results_pane(
        &self,
        frame: &mut super::ftui_adapter::Frame,
        area: Rect,
        row_h: u16,
        border_type: BorderType,
        borders: Borders,
        styles: &StyleContext,
        pane_style: ftui::Style,
        pane_focused_style: ftui::Style,
        title_focused_style: ftui::Style,
        title_unfocused_style: ftui::Style,
        row_style: ftui::Style,
        row_alt_style: ftui::Style,
        row_selected_style: ftui::Style,
        text_muted_style: ftui::Style,
        reveal_motion_enabled: bool,
        focus_flash_intensity: f32,
    ) {
        let grouping_suffix = match self.grouping_mode {
            ResultsGrouping::Agent | ResultsGrouping::Flat => String::new(),
            other => format!(" [{}]", other.label()),
        };
        let total_hits: usize = self.panes.iter().map(|pane| pane.total_count).sum();
        let pane_count = self.panes.len();
        let single_pane = pane_count <= 1;
        let results_title = if single_pane {
            if self.selected.is_empty() {
                format!("Results ({total_hits}){grouping_suffix}")
            } else {
                format!(
                    "Results ({total_hits}) \u{2022} {} selected{grouping_suffix}",
                    self.selected.len()
                )
            }
        } else if self.selected.is_empty() {
            format!("Results ({total_hits} hits · {pane_count} panes){grouping_suffix}")
        } else {
            format!(
                "Results ({total_hits} hits · {pane_count} panes) \u{2022} {} selected{grouping_suffix}",
                self.selected.len()
            )
        };
        let focused = self.focused_region() == FocusRegion::Results;
        let styleful = title_focused_style.fg.is_some()
            || title_unfocused_style.fg.is_some()
            || pane_focused_style.bg.is_some()
            || pane_style.bg.is_some();
        let focus_pulse = if focused {
            focus_flash_intensity.clamp(0.0, 1.0)
        } else {
            0.0
        };
        let pane_accent = self
            .panes
            .get(self.active_pane)
            .map(|pane| legacy_agent_color(&pane.agent));
        let mut results_border_style = if focused {
            title_focused_style
        } else {
            title_unfocused_style
        };
        let mut results_surface_style = if focused {
            pane_focused_style
        } else {
            pane_style
        };
        if styleful && let Some(accent) = pane_accent {
            let focused_accent = if focus_pulse > 0.01 {
                let t = (0.10 + focus_pulse * 0.32).clamp(0.0, 0.45);
                ftui::PackedRgba::rgb(
                    lerp_u8(accent.r(), 255, t),
                    lerp_u8(accent.g(), 255, t),
                    lerp_u8(accent.b(), 255, t),
                )
            } else {
                accent
            };
            results_border_style = if focused {
                results_border_style.fg(focused_accent).bold()
            } else {
                results_border_style.fg(dim_packed_color(accent, 0.62))
            };
            results_surface_style = results_surface_style.bg(dim_packed_color(
                accent,
                if focused {
                    (0.10 + focus_pulse * 0.08).clamp(0.0, 0.22)
                } else {
                    0.05
                },
            ));
        }
        let results_block = Block::new()
            .borders(borders)
            .border_type(border_type)
            .title(&results_title)
            .title_alignment(Alignment::Left)
            .border_style(results_border_style)
            .style(results_surface_style);
        let inner = results_block.inner(area);
        results_block.render(area, frame);

        *self.last_results_inner.borrow_mut() = None;
        self.last_pane_rects.borrow_mut().clear();
        *self.last_pane_first_index.borrow_mut() = 0;

        if inner.is_empty() {
            return;
        }

        // Stats bar: 1 line at the bottom of results pane (when enabled and has results)
        let inner = if self.show_stats_bar && !self.panes.is_empty() && inner.height >= 4 {
            let stats_row = Rect::new(inner.x, inner.y + inner.height - 1, inner.width, 1);
            let stats_line = self.build_results_stats_line(inner.width, styles);
            Paragraph::new(ftui::text::Text::from_lines(vec![stats_line]))
                .style(styles.style(style_system::STYLE_TEXT_MUTED))
                .render(stats_row, frame);
            Rect::new(inner.x, inner.y, inner.width, inner.height - 1)
        } else {
            inner
        };
        let inner = if !self.panes.is_empty() && inner.height >= 5 {
            let overview_row = Rect::new(inner.x, inner.y, inner.width, 1);
            let overview =
                self.build_results_overview_line(inner.width, total_hits, pane_count, styles);
            Paragraph::new(ftui::text::Text::from_lines(vec![overview]))
                .style(styles.style(style_system::STYLE_TEXT_MUTED))
                .render(overview_row, frame);
            Rect::new(inner.x, inner.y + 1, inner.width, inner.height - 1)
        } else {
            inner
        };

        if self.panes.is_empty() {
            // Centered empty-state message with magnifying glass icon.
            let msg = "\u{1f50d} No results yet \u{2014} type a query and press Enter";
            let msg_line = ftui::text::Line::from_spans(vec![ftui::text::Span::styled(
                msg.to_string(),
                text_muted_style,
            )]);
            let y_offset = inner.height / 3;
            if y_offset < inner.height {
                let row = Rect::new(inner.x, inner.y + y_offset, inner.width, 1);
                Paragraph::new(ftui::text::Text::from_lines(vec![msg_line]))
                    .style(text_muted_style)
                    .alignment(Alignment::Center)
                    .render(row, frame);
            }
            return;
        }

        let mini_analytics_by_session = self.build_result_row_mini_analytics_map();

        // Legacy-parity rendering path: when there's only one pane, render a single
        // unified list without per-pane chrome.
        if self.panes.len() == 1 {
            let pane = &self.panes[0];
            *self.last_results_inner.borrow_mut() = Some(inner);

            if pane.hits.is_empty() {
                let msg = "\u{2205} No results match the current filters";
                Paragraph::new(msg)
                    .style(text_muted_style)
                    .alignment(Alignment::Center)
                    .render(inner, frame);
                return;
            }

            let items: Vec<ResultItem> = pane
                .hits
                .iter()
                .enumerate()
                .map(|(i, hit)| {
                    let even = i % 2 == 0;
                    let queued = self.selected.contains(&SelectedHitKey::from_hit(hit));
                    let mini_analytics = mini_analytics_by_session
                        .get(&(hit.source_id.clone(), hit.source_path.clone()))
                        .copied();
                    ResultItem {
                        index: i + 1,
                        hit: hit.clone(),
                        row_height: row_h,
                        even,
                        max_width: inner.width,
                        queued,
                        stripe_style: styles.result_row_style_for_agent(
                            if even { row_style } else { row_alt_style },
                            &hit.agent,
                        ),
                        selected_style: row_selected_style,
                        agent_accent_style: ftui::Style::new()
                            .fg(legacy_agent_color(&hit.agent))
                            .bold(),
                        score_style: styles.score_style(normalize_score_for_visuals(hit.score)),
                        text_primary_style: styles.style(style_system::STYLE_TEXT_PRIMARY),
                        text_muted_style: styles.style(style_system::STYLE_TEXT_MUTED),
                        text_subtle_style: styles.style(style_system::STYLE_TEXT_SUBTLE),
                        success_style: styles.style(style_system::STYLE_STATUS_SUCCESS),
                        source_local_style: styles.style(style_system::STYLE_SOURCE_LOCAL),
                        source_remote_style: styles.style(style_system::STYLE_SOURCE_REMOTE),
                        location_style: styles.style(style_system::STYLE_LOCATION),
                        mini_analytics,
                        reveal_progress: if reveal_motion_enabled {
                            self.anim.reveal_progress(i) as f32
                        } else {
                            1.0
                        },
                        focus_flash_intensity,
                        query_terms: extract_query_terms(&self.query),
                        query_highlight_style: styles.style(style_system::STYLE_QUERY_HIGHLIGHT),
                        hovered: self.hovered_result == Some(i),
                    }
                })
                .collect();

            let list = VirtualizedList::new(&items)
                .fixed_height(row_h)
                .highlight_style(row_selected_style)
                .show_scrollbar(true);
            let mut state = self.results_list_state.borrow_mut();
            state.select(Some(pane.selected.min(items.len().saturating_sub(1))));
            list.render(inner, frame, &mut state);
            return;
        }

        let max_visible = max_visible_panes_for_width(inner.width)
            .min(self.panes.len())
            .max(1);
        let safe_scroll_offset = self
            .pane_scroll_offset
            .min(self.panes.len().saturating_sub(max_visible));
        let visible_end = (safe_scroll_offset + max_visible).min(self.panes.len());
        let visible_count = visible_end.saturating_sub(safe_scroll_offset).max(1);
        let pane_chunks = Flex::horizontal()
            .constraints(
                (0..visible_count)
                    .map(|_| Constraint::Percentage(100.0 / visible_count as f32))
                    .collect::<Vec<_>>(),
            )
            .split(inner);
        *self.last_pane_rects.borrow_mut() = pane_chunks.to_vec();
        *self.last_pane_first_index.borrow_mut() = safe_scroll_offset;

        for (vis_idx, pane_idx) in (safe_scroll_offset..visible_end).enumerate() {
            let Some(pane) = self.panes.get(pane_idx) else {
                continue;
            };
            let Some(pane_rect) = pane_chunks.get(vis_idx).copied() else {
                continue;
            };

            let pane_color = legacy_agent_color(&pane.agent);
            let dimmed_pane_color = dim_packed_color(pane_color, 0.52);
            let is_active = pane_idx == self.active_pane;
            let is_focused = focused && is_active;
            let pane_focus_pulse = if is_focused {
                focus_flash_intensity.clamp(0.0, 1.0)
            } else {
                0.0
            };
            let focused_accent = if pane_focus_pulse > 0.01 {
                let t = (0.08 + pane_focus_pulse * 0.30).clamp(0.0, 0.42);
                ftui::PackedRgba::rgb(
                    lerp_u8(pane_color.r(), 255, t),
                    lerp_u8(pane_color.g(), 255, t),
                    lerp_u8(pane_color.b(), 255, t),
                )
            } else {
                pane_color
            };
            let accent_color = if is_focused {
                focused_accent
            } else {
                dimmed_pane_color
            };
            let pane_bg = if is_focused {
                dim_packed_color(
                    pane_color,
                    (0.10 + pane_focus_pulse * 0.08).clamp(0.0, 0.20),
                )
            } else {
                dim_packed_color(pane_color, 0.06)
            };
            let pane_border_style = if is_focused {
                title_focused_style.fg(accent_color)
            } else {
                title_unfocused_style.fg(accent_color)
            };
            let count_display = if pane.total_count > pane.hits.len() {
                format!("{}/{}", pane.hits.len(), pane.total_count)
            } else {
                pane.hits.len().to_string()
            };
            let pane_title = format!("{} ({count_display})", display_group_name(&pane.agent));

            let pane_block = Block::new()
                .borders(borders)
                .border_type(border_type)
                .title(&pane_title)
                .title_alignment(Alignment::Left)
                .border_style(pane_border_style.bold())
                .style(if is_focused {
                    pane_focused_style.bg(pane_bg)
                } else {
                    pane_style.bg(pane_bg)
                });
            let pane_inner = pane_block.inner(pane_rect);
            pane_block.render(pane_rect, frame);

            if is_active {
                *self.last_results_inner.borrow_mut() = Some(pane_inner);
            }

            if pane_inner.is_empty() || pane.hits.is_empty() {
                continue;
            }

            let selected_row_style = row_selected_style
                .bg(accent_color)
                .fg(ftui::PackedRgba::rgb(14, 16, 24))
                .bold();
            let items: Vec<ResultItem> = pane
                .hits
                .iter()
                .enumerate()
                .map(|(i, hit)| {
                    let even = i % 2 == 0;
                    let queued = self.selected.contains(&SelectedHitKey::from_hit(hit));
                    let mini_analytics = mini_analytics_by_session
                        .get(&(hit.source_id.clone(), hit.source_path.clone()))
                        .copied();
                    ResultItem {
                        index: i + 1,
                        hit: hit.clone(),
                        row_height: row_h,
                        even,
                        max_width: pane_inner.width,
                        queued,
                        stripe_style: styles.result_row_style_for_agent(
                            if even { row_style } else { row_alt_style },
                            &hit.agent,
                        ),
                        selected_style: selected_row_style,
                        agent_accent_style: ftui::Style::new()
                            .fg(legacy_agent_color(&hit.agent))
                            .bold(),
                        score_style: styles.score_style(normalize_score_for_visuals(hit.score)),
                        text_primary_style: styles.style(style_system::STYLE_TEXT_PRIMARY),
                        text_muted_style: styles.style(style_system::STYLE_TEXT_MUTED),
                        text_subtle_style: styles.style(style_system::STYLE_TEXT_SUBTLE),
                        success_style: styles.style(style_system::STYLE_STATUS_SUCCESS),
                        source_local_style: styles.style(style_system::STYLE_SOURCE_LOCAL),
                        source_remote_style: styles.style(style_system::STYLE_SOURCE_REMOTE),
                        location_style: styles.style(style_system::STYLE_LOCATION),
                        mini_analytics,
                        reveal_progress: if reveal_motion_enabled {
                            self.anim.reveal_progress(i) as f32
                        } else {
                            1.0
                        },
                        focus_flash_intensity: if is_active {
                            focus_flash_intensity
                        } else {
                            0.0
                        },
                        query_terms: extract_query_terms(&self.query),
                        query_highlight_style: styles.style(style_system::STYLE_QUERY_HIGHLIGHT),
                        hovered: is_active && self.hovered_result == Some(i),
                    }
                })
                .collect();

            let list = VirtualizedList::new(&items)
                .fixed_height(row_h)
                .highlight_style(selected_row_style)
                .show_scrollbar(is_active);
            if is_active {
                let mut state = self.results_list_state.borrow_mut();
                state.select(Some(pane.selected.min(items.len().saturating_sub(1))));
                list.render(pane_inner, frame, &mut state);
            } else {
                let mut state = VirtualizedListState::default();
                state.select(Some(pane.selected.min(items.len().saturating_sub(1))));
                list.render(pane_inner, frame, &mut state);
            }
        }

        if safe_scroll_offset > 0 {
            let hidden_left = safe_scroll_offset;
            Paragraph::new(format!("\u{25c0} +{hidden_left}"))
                .style(title_focused_style)
                .render(Rect::new(inner.x, inner.y, 8.min(inner.width), 1), frame);
        }
        if visible_end < self.panes.len() {
            let hidden_right = self.panes.len() - visible_end;
            let text = format!("+{hidden_right} \u{25b6}");
            let width = text.chars().count() as u16;
            let start_x = inner.x + inner.width.saturating_sub(width);
            Paragraph::new(text).style(title_focused_style).render(
                Rect::new(start_x, inner.y, width.min(inner.width), 1),
                frame,
            );
        }

        // Render role gutter markers if a11y mode is on
        if styles.options.a11y {
            let marker = styles.role_markers.assistant;
            if !marker.is_empty() && inner.width > 4 {
                let marker_area = Rect::new(inner.x, inner.y, 3, inner.height);
                Paragraph::new(marker)
                    .style(styles.style(style_system::STYLE_ROLE_GUTTER_ASSISTANT))
                    .render(marker_area, frame);
            }
        }
    }

    /// Style for a message role (User/Agent/Tool/System).
    fn role_style(role: &MessageRole, styles: &StyleContext) -> ftui::Style {
        match role {
            MessageRole::User => styles.style(style_system::STYLE_ROLE_USER),
            MessageRole::Agent => styles.style(style_system::STYLE_ROLE_ASSISTANT),
            MessageRole::Tool => styles.style(style_system::STYLE_ROLE_TOOL),
            MessageRole::System => styles.style(style_system::STYLE_ROLE_SYSTEM),
            MessageRole::Other(_) => styles.style(style_system::STYLE_TEXT_MUTED),
        }
    }

    /// Gutter style for a message role — colored left-margin indicator.
    fn role_gutter_style(role: &MessageRole, styles: &StyleContext) -> ftui::Style {
        match role {
            MessageRole::User => styles.style(style_system::STYLE_ROLE_GUTTER_USER),
            MessageRole::Agent => styles.style(style_system::STYLE_ROLE_GUTTER_ASSISTANT),
            MessageRole::Tool => styles.style(style_system::STYLE_ROLE_GUTTER_TOOL),
            MessageRole::System => styles.style(style_system::STYLE_ROLE_GUTTER_SYSTEM),
            MessageRole::Other(_) => styles.style(style_system::STYLE_TEXT_MUTED),
        }
    }

    /// Role prefix symbol for message rendering.
    fn role_prefix(role: &MessageRole) -> &'static str {
        match role {
            MessageRole::User => "\u{f061} ",     // arrow-right →
            MessageRole::Agent => "\u{2713} ",    // checkmark ✓
            MessageRole::Tool => "\u{2699} ",     // gear ⚙
            MessageRole::System => "\u{2139} ",   // info ℹ
            MessageRole::Other(_) => "\u{2022} ", // bullet •
        }
    }

    /// Build sticky header lines for the detail modal metadata bar.
    ///
    /// Renders 2-3 lines: agent/workspace/source, timestamps/duration/tokens,
    /// and a text-based mini sparkline of message activity over the session.
    fn build_detail_header_lines(
        &self,
        hit: &SearchHit,
        inner_width: u16,
        styles: &StyleContext,
    ) -> Vec<ftui::text::Line> {
        let label_style = styles.style(style_system::STYLE_TEXT_SUBTLE);
        let value_style = styles.style(style_system::STYLE_TEXT_PRIMARY);
        let muted_style = styles.style(style_system::STYLE_TEXT_MUTED);
        let info_style = styles.style(style_system::STYLE_STATUS_INFO);
        let success_style = styles.style(style_system::STYLE_STATUS_SUCCESS);
        let warning_style = styles.style(style_system::STYLE_STATUS_WARNING);
        let agent_style = styles.agent_accent_style(&hit.agent);
        let mut lines: Vec<ftui::text::Line> = Vec::new();
        let source_kind = normalized_source_kind(Some(hit.origin_kind.as_str()), &hit.source_id);
        let source_style = if source_kind == "remote" {
            styles.style(style_system::STYLE_SOURCE_REMOTE).bold()
        } else {
            styles.style(style_system::STYLE_SOURCE_LOCAL).bold()
        };
        let source_icon = if source_kind == "remote" {
            "\u{21c4}"
        } else {
            "\u{2302}"
        };
        let source_label = source_display_label(&hit.source_id, hit.origin_host.as_deref());
        let source_chip = if let Some(host) = hit.origin_host.as_deref() {
            format!("{source_icon} {source_label}@{host}")
        } else {
            format!("{source_icon} {source_label}")
        };
        let workspace_room = inner_width.saturating_sub(44).clamp(16, 56) as usize;
        let workspace_chip = elide_path_for_metadata(&hit.workspace, workspace_room);
        let score_style = styles.score_style(normalize_score_for_visuals(hit.score));
        let (match_label, match_style) = match hit.match_type {
            MatchType::Exact => ("exact", success_style.bold()),
            MatchType::Prefix => ("prefix", info_style.bold()),
            MatchType::ImplicitWildcard => ("auto", warning_style.bold()),
            MatchType::Wildcard => ("wildcard", warning_style),
            MatchType::Suffix => ("suffix", muted_style),
            MatchType::Substring => ("substring", muted_style),
        };
        let top_lanes = vec![
            FooterHudLane {
                key: "agent",
                value: format!("\u{2713} {}", hit.agent),
                value_style: agent_style.bold(),
            },
            FooterHudLane {
                key: "ws",
                value: workspace_chip,
                value_style,
            },
            FooterHudLane {
                key: "src",
                value: source_chip,
                value_style: source_style,
            },
            FooterHudLane {
                key: "score",
                value: score_display_label(hit.score),
                value_style: score_style,
            },
            FooterHudLane {
                key: "mt",
                value: match_label.to_string(),
                value_style: match_style,
            },
        ];
        lines.push(build_footer_hud_line(
            &top_lanes,
            inner_width,
            label_style,
            label_style,
        ));

        let mut line2_spans: Vec<ftui::text::Span> =
            vec![ftui::text::Span::styled(" ", label_style)];
        let mut push_chip = |key: &str, value: String, value_style_chip: ftui::Style| {
            line2_spans.push(ftui::text::Span::styled("[", label_style));
            line2_spans.push(ftui::text::Span::styled(key.to_string(), label_style));
            line2_spans.push(ftui::text::Span::styled(":", label_style));
            line2_spans.push(ftui::text::Span::styled(value, value_style_chip));
            line2_spans.push(ftui::text::Span::styled("] ", label_style));
        };

        let mut sparkline_data: Option<(String, usize)> = None;
        if let Some((_, ref cv)) = self.cached_detail {
            if let Some(started) = cv.convo.started_at {
                let ts_s = started / 1000; // ms → s
                if let Some(dt) = chrono::DateTime::from_timestamp(ts_s, 0) {
                    push_chip("at", dt.format("%Y-%m-%d %H:%M").to_string(), value_style);
                }
                if let Some(ended) = cv.convo.ended_at {
                    let dur_secs = (ended.saturating_sub(started)) / 1000;
                    let dur_str = if dur_secs >= 3600 {
                        format!("{}h {}m", dur_secs / 3600, (dur_secs % 3600) / 60)
                    } else if dur_secs >= 60 {
                        format!("{}m {}s", dur_secs / 60, dur_secs % 60)
                    } else {
                        format!("{dur_secs}s")
                    };
                    push_chip("dur", dur_str, muted_style);
                }
            } else if let Some(ts) = hit.created_at
                && let Some(dt) = chrono::DateTime::from_timestamp(ts, 0)
            {
                push_chip("at", dt.format("%Y-%m-%d %H:%M").to_string(), value_style);
            }

            let (mut n_user, mut n_agent, mut n_tool, mut n_sys) = (0u32, 0, 0, 0);
            for m in &cv.messages {
                match m.role {
                    crate::model::types::MessageRole::User => n_user += 1,
                    crate::model::types::MessageRole::Agent => n_agent += 1,
                    crate::model::types::MessageRole::Tool => n_tool += 1,
                    crate::model::types::MessageRole::System => n_sys += 1,
                    _ => {}
                }
            }
            let total = cv.messages.len();
            push_chip("msgs", format!("{total} msgs"), value_style);
            push_chip(
                "mix",
                format!("u:{n_user} a:{n_agent} t:{n_tool} s:{n_sys}"),
                muted_style,
            );
            if cv.messages.len() >= 2 {
                let sparkline = Self::build_text_sparkline(
                    &cv.messages,
                    inner_width.saturating_sub(18) as usize,
                );
                if !sparkline.is_empty() {
                    sparkline_data = Some((sparkline, total));
                }
            }
        } else if let Some(ts) = hit.created_at
            && let Some(dt) = chrono::DateTime::from_timestamp(ts, 0)
        {
            push_chip("at", dt.format("%Y-%m-%d %H:%M").to_string(), value_style);
            push_chip("score", score_display_label(hit.score), score_style);
            push_chip("mt", match_label.to_string(), match_style);
        }

        if line2_spans.len() > 1 {
            lines.push(ftui::text::Line::from_spans(line2_spans));
        }

        if let Some((sparkline, total)) = sparkline_data {
            lines.push(ftui::text::Line::from_spans(vec![
                ftui::text::Span::styled(" ", label_style),
                ftui::text::Span::styled("activity ", label_style),
                ftui::text::Span::styled(sparkline, info_style),
                ftui::text::Span::styled(format!("  {total} msgs"), muted_style),
            ]));
        }

        let sep_len = (inner_width.saturating_sub(2) as usize).clamp(20, 96);
        let sep_line = "\u{2500}".repeat(sep_len);
        lines.push(ftui::text::Line::from_spans(vec![
            ftui::text::Span::styled(sep_line, label_style),
        ]));

        lines
    }

    /// Build a text-based sparkline from message timestamps.
    /// Uses Unicode block characters ▁▂▃▄▅▆▇█ to show message density.
    fn build_text_sparkline(messages: &[crate::model::types::Message], max_width: usize) -> String {
        const BLOCKS: &[char] = &[
            ' ', '\u{2581}', '\u{2582}', '\u{2583}', '\u{2584}', '\u{2585}', '\u{2586}',
            '\u{2587}', '\u{2588}',
        ];
        let width = max_width.clamp(8, 60);

        // Collect timestamps
        let mut timestamps: Vec<i64> = messages.iter().filter_map(|m| m.created_at).collect();
        if timestamps.len() < 2 {
            return String::new();
        }
        timestamps.sort_unstable();
        let t_min = timestamps[0];
        let t_max = timestamps[timestamps.len() - 1];
        if t_max <= t_min {
            return String::new();
        }

        // Bucket messages into bins
        let mut buckets = vec![0u32; width];
        let range = (t_max - t_min) as f64;
        for &ts in &timestamps {
            let idx = (((ts - t_min) as f64 / range) * (width - 1) as f64) as usize;
            buckets[idx.min(width - 1)] += 1;
        }

        let max_count = *buckets.iter().max().unwrap_or(&1);
        if max_count == 0 {
            return String::new();
        }

        buckets
            .iter()
            .map(|&count| {
                let level = (count as f64 / max_count as f64 * 8.0) as usize;
                BLOCKS[level.min(8)]
            })
            .collect()
    }

    /// Build rendered lines for Messages tab.
    fn build_messages_lines(
        &self,
        hit: &SearchHit,
        inner_width: u16,
        styles: &StyleContext,
    ) -> Vec<ftui::text::Line> {
        let mut lines: Vec<ftui::text::Line> = Vec::new();
        let session_hit_lines = &self.detail_session_hit_lines;
        let session_hit_total = session_hit_lines.len();
        let session_hit_lookup: HashSet<usize> = session_hit_lines.iter().copied().collect();
        let session_hit_rank: HashMap<usize, usize> = session_hit_lines
            .iter()
            .enumerate()
            .map(|(idx, line)| (*line, idx + 1))
            .collect();
        let mut session_hit_offsets: Vec<u16> = Vec::with_capacity(session_hit_total);
        let session_hit_badge_style = styles.style(style_system::STYLE_QUERY_HIGHLIGHT).bold();
        let session_hit_active_style = styles.style(style_system::STYLE_DETAIL_FIND_MATCH_ACTIVE);
        let current_session_hit_rank = if session_hit_total > 0 {
            self.detail_session_hit_current
                .min(session_hit_total.saturating_sub(1))
                + 1
        } else {
            0
        };

        // Header: title + metadata
        let title = if hit.title.is_empty() {
            "(untitled)"
        } else {
            &hit.title
        };
        let header_style = styles.style(style_system::STYLE_TEXT_PRIMARY).bold();
        lines.push(ftui::text::Line::from_spans(vec![
            ftui::text::Span::styled(title.to_string(), header_style),
        ]));

        // Metadata line: agent, workspace, timestamp, score — with per-field styling
        let meta_style = styles.style(style_system::STYLE_TEXT_MUTED);
        let label_style = styles.style(style_system::STYLE_TEXT_SUBTLE);
        let agent_style = styles.agent_accent_style(&hit.agent);
        let score_s = styles.score_style(normalize_score_for_visuals(hit.score));
        let source_label = source_display_label(&hit.source_id, hit.origin_host.as_deref());
        let source_kind = normalized_source_kind(Some(hit.origin_kind.as_str()), &hit.source_id);
        let sep = ftui::text::Span::styled(" \u{2502} ", label_style);
        let mut meta_spans = vec![
            ftui::text::Span::styled("agent=", label_style),
            ftui::text::Span::styled(hit.agent.clone(), agent_style),
            sep.clone(),
            ftui::text::Span::styled("ws=", label_style),
            ftui::text::Span::styled(hit.workspace.clone(), meta_style),
            sep.clone(),
            ftui::text::Span::styled("source=", label_style),
            ftui::text::Span::styled(
                format!("{source_label} ({source_kind})"),
                if source_kind == "remote" {
                    styles.style(style_system::STYLE_SOURCE_REMOTE)
                } else {
                    styles.style(style_system::STYLE_SOURCE_LOCAL)
                },
            ),
            sep.clone(),
            ftui::text::Span::styled("score=", label_style),
            ftui::text::Span::styled(score_display_label(hit.score), score_s),
        ];
        if let Some(ws_original) = hit.workspace_original.as_deref()
            && ws_original != hit.workspace
        {
            meta_spans.push(sep.clone());
            meta_spans.push(ftui::text::Span::styled(
                format!("ws_orig={ws_original}"),
                meta_style,
            ));
        }
        if let Some(ts) = hit.created_at.map(|ts| {
            chrono::DateTime::from_timestamp(ts, 0)
                .map(|dt| dt.format("%Y-%m-%d %H:%M").to_string())
                .unwrap_or_else(|| ts.to_string())
        }) {
            meta_spans.push(sep);
            meta_spans.push(ftui::text::Span::styled(ts, meta_style));
        }
        lines.push(ftui::text::Line::from_spans(meta_spans));

        // Separator
        let sep = "\u{2500}".repeat(inner_width.saturating_sub(2) as usize);
        lines.push(ftui::text::Line::from_spans(vec![
            ftui::text::Span::styled(sep, meta_style),
        ]));

        // Session hit navigation hint (only when we have in-session hits).
        if session_hit_total > 0 {
            let mut hint_spans: Vec<ftui::text::Span> = Vec::new();
            hint_spans.push(ftui::text::Span::styled("hits ", label_style));
            hint_spans.push(ftui::text::Span::styled(
                format!("{}/{}", current_session_hit_rank, session_hit_total),
                session_hit_badge_style,
            ));
            hint_spans.push(ftui::text::Span::styled(
                "  (Enter/n next, N prev, Esc close)",
                meta_style,
            ));
            lines.push(ftui::text::Line::from_spans(hint_spans));
            lines.push(ftui::text::Line::from(""));
        }

        // If we have a cached conversation, render full messages
        if let Some((_, ref cv)) = self.cached_detail {
            let md_renderer = MarkdownRenderer::new(styles.markdown_theme())
                .with_syntax_theme(styles.syntax_highlight_theme());

            let msg_count = cv.messages.len();
            let subtle_style = styles.style(style_system::STYLE_TEXT_SUBTLE);
            let mut msg_offsets: Vec<(u16, crate::model::types::MessageRole)> =
                Vec::with_capacity(msg_count);
            for (msg_idx, msg) in cv.messages.iter().enumerate() {
                // Record line offset for message-level navigation
                msg_offsets.push((lines.len() as u16, msg.role.clone()));
                let msg_line_from_idx = (msg.idx >= 0).then_some((msg.idx as usize) + 1);
                let msg_line_from_pos = msg_idx + 1;
                let msg_is_session_hit = msg_line_from_idx
                    .is_some_and(|line| session_hit_lookup.contains(&line))
                    || session_hit_lookup.contains(&msg_line_from_pos);
                let msg_hit_rank = msg_line_from_idx
                    .and_then(|line| session_hit_rank.get(&line).copied())
                    .or_else(|| session_hit_rank.get(&msg_line_from_pos).copied());
                let msg_is_current_session_hit =
                    msg_hit_rank.is_some_and(|rank| rank == current_session_hit_rank && rank > 0);
                let role_s = Self::role_style(&msg.role, styles);
                let gutter_s = Self::role_gutter_style(&msg.role, styles);
                let prefix = Self::role_prefix(&msg.role);
                let role_label = format!("{prefix}{}", msg.role);
                let author_suffix = msg
                    .author
                    .as_ref()
                    .map(|a| format!(" ({a})"))
                    .unwrap_or_default();
                let ts_label = msg
                    .created_at
                    .and_then(|ts| chrono::DateTime::from_timestamp(ts, 0))
                    .map(|dt| format!(" {}", dt.format("%H:%M:%S")))
                    .unwrap_or_default();

                // Thin separator between messages (not before the first)
                if msg_idx > 0 {
                    let thin_sep =
                        "\u{2500}".repeat((inner_width.saturating_sub(4) as usize).min(60));
                    lines.push(ftui::text::Line::from_spans(vec![
                        ftui::text::Span::styled("  ", subtle_style),
                        ftui::text::Span::styled(thin_sep, subtle_style),
                    ]));
                }

                // Check if this message is collapsed (tool/system messages)
                let is_collapsed = self.collapsed_tools.contains(&msg_idx);

                // Role header line with gutter + message counter + collapse indicator
                let counter = format!(" [{}/{}]", msg_idx + 1, msg_count);
                let collapse_indicator = if matches!(
                    msg.role,
                    crate::model::types::MessageRole::Tool
                        | crate::model::types::MessageRole::System
                ) {
                    if is_collapsed {
                        " \u{25b6} "
                    } else {
                        " \u{25bc} "
                    }
                } else {
                    ""
                };
                if msg_is_session_hit {
                    session_hit_offsets.push(lines.len() as u16);
                }
                let header_gutter = if msg_is_current_session_hit {
                    "\u{258c}\u{25b6}"
                } else {
                    "\u{258c} "
                };
                let mut header_role_style = role_s.bold();
                if msg_is_session_hit {
                    header_role_style = header_role_style.underline();
                }
                if msg_is_current_session_hit && let Some(bg) = session_hit_active_style.bg {
                    header_role_style = header_role_style.bg(bg);
                }
                let mut header_spans = vec![
                    ftui::text::Span::styled(header_gutter, gutter_s),
                    ftui::text::Span::styled(
                        format!("{role_label}{author_suffix}{ts_label}"),
                        header_role_style,
                    ),
                    ftui::text::Span::styled(counter, subtle_style),
                    ftui::text::Span::styled(collapse_indicator, subtle_style),
                ];
                if let Some(rank) = msg_hit_rank {
                    let badge_style = if msg_is_current_session_hit {
                        session_hit_active_style.bold()
                    } else {
                        session_hit_badge_style
                    };
                    header_spans.push(ftui::text::Span::styled("  \u{25ce} ", badge_style));
                    header_spans.push(ftui::text::Span::styled(
                        format!("search hit {rank}/{session_hit_total}"),
                        badge_style,
                    ));
                }
                lines.push(ftui::text::Line::from_spans(header_spans));

                if is_collapsed {
                    // Collapsed: show truncated first-line summary
                    let content = msg.content.trim();
                    let first_line = content
                        .lines()
                        .next()
                        .unwrap_or("")
                        .chars()
                        .take(80)
                        .collect::<String>();
                    let ellipsis = if first_line.len() < content.len() {
                        "\u{2026}"
                    } else {
                        ""
                    };
                    lines.push(ftui::text::Line::from_spans(vec![
                        ftui::text::Span::styled("\u{258c} ", gutter_s),
                        ftui::text::Span::styled(format!("  {first_line}{ellipsis}"), subtle_style),
                    ]));
                } else {
                    // Expanded: render full message content
                    let content = msg.content.trim();
                    if !content.is_empty() {
                        // In the drill-in detail modal we always render through the
                        // GFM renderer for a consistently rich session view.
                        let force_markdown = self.show_detail_modal;
                        if force_markdown || is_likely_markdown(content).is_likely() {
                            let rendered = md_renderer.render(content);
                            for line in rendered.into_iter() {
                                let mut spans =
                                    vec![ftui::text::Span::styled("\u{258c} ", gutter_s)];
                                spans.extend(line.spans().iter().cloned());
                                lines.push(ftui::text::Line::from_spans(spans));
                            }
                        } else {
                            // Plain text — wrap if enabled
                            for text_line in content.lines() {
                                if self.detail_wrap && !text_line.is_empty() {
                                    let w = inner_width.saturating_sub(4) as usize;
                                    for chunk in text_line
                                        .as_bytes()
                                        .chunks(w.max(20))
                                        .map(|c| std::str::from_utf8(c).unwrap_or(""))
                                    {
                                        lines.push(ftui::text::Line::from_spans(vec![
                                            ftui::text::Span::styled("\u{258c} ", gutter_s),
                                            ftui::text::Span::raw(chunk.to_string()),
                                        ]));
                                    }
                                } else {
                                    lines.push(ftui::text::Line::from_spans(vec![
                                        ftui::text::Span::styled("\u{258c} ", gutter_s),
                                        ftui::text::Span::raw(text_line.to_string()),
                                    ]));
                                }
                            }
                        }
                    }
                }

                // Blank line between messages
                lines.push(ftui::text::Line::from(""));
            }
            let pending_scroll_target = if self.detail_session_hit_scroll_pending.get()
                && !session_hit_offsets.is_empty()
            {
                let total = session_hit_offsets.len();
                let current = self.detail_session_hit_current.min(total.saturating_sub(1));
                Some(session_hit_offsets[current].saturating_sub(3))
            } else {
                None
            };
            *self.detail_message_offsets.borrow_mut() = msg_offsets;
            *self.detail_session_hit_offsets_cache.borrow_mut() = session_hit_offsets;
            if let Some(target) = pending_scroll_target {
                self.detail_pending_scroll_to.set(Some(target));
                self.detail_session_hit_scroll_pending.set(false);
            }
        } else {
            // No cached conversation: show the hit's content directly
            self.detail_message_offsets.borrow_mut().clear();
            self.detail_session_hit_offsets_cache.borrow_mut().clear();
            let content = if hit.content.is_empty() {
                &hit.snippet
            } else {
                &hit.content
            };
            if self.show_detail_modal || is_likely_markdown(content).is_likely() {
                let md_renderer = MarkdownRenderer::new(styles.markdown_theme())
                    .with_syntax_theme(styles.syntax_highlight_theme());
                let rendered = md_renderer.render(content);
                for line in rendered.into_iter() {
                    lines.push(line);
                }
            } else {
                for text_line in content.lines() {
                    lines.push(ftui::text::Line::from(text_line.to_string()));
                }
            }
        }

        lines
    }

    /// Build rendered lines for Snippets tab.
    fn build_snippets_lines(
        &self,
        hit: &SearchHit,
        styles: &StyleContext,
    ) -> Vec<ftui::text::Line> {
        let mut lines: Vec<ftui::text::Line> = Vec::new();
        let header_style = styles.style(style_system::STYLE_TEXT_PRIMARY).bold();
        let meta_style = styles.style(style_system::STYLE_TEXT_MUTED);

        lines.push(ftui::text::Line::from_spans(vec![
            ftui::text::Span::styled("Snippets", header_style),
        ]));
        lines.push(ftui::text::Line::from(""));

        // If we have a cached conversation, show per-message snippets
        if let Some((_, ref cv)) = self.cached_detail {
            let mut any = false;
            for (i, msg) in cv.messages.iter().enumerate() {
                if msg.snippets.is_empty() {
                    continue;
                }
                any = true;
                let role_s = Self::role_style(&msg.role, styles);
                lines.push(ftui::text::Line::from_spans(vec![
                    ftui::text::Span::styled(
                        format!("Message {} ({})", i + 1, msg.role),
                        role_s.bold(),
                    ),
                ]));
                for snippet in &msg.snippets {
                    let path_str = snippet
                        .file_path
                        .as_ref()
                        .map(|p| p.display().to_string())
                        .unwrap_or_default();
                    if !path_str.is_empty() {
                        lines.push(ftui::text::Line::from_spans(vec![
                            ftui::text::Span::styled(format!("  {path_str}"), meta_style),
                        ]));
                    }
                }
                lines.push(ftui::text::Line::from(""));
            }
            if !any {
                lines.push(ftui::text::Line::from_spans(vec![
                    ftui::text::Span::styled("No snippets extracted.", meta_style),
                ]));
            }
        } else {
            // Fallback: show the search snippet
            let snippet = &hit.snippet;
            if snippet.is_empty() {
                lines.push(ftui::text::Line::from_spans(vec![
                    ftui::text::Span::styled("No snippet available.", meta_style),
                ]));
            } else {
                for line in snippet.lines() {
                    lines.push(ftui::text::Line::from(line.to_string()));
                }
            }
        }

        lines
    }

    /// Build rendered lines for Raw tab.
    fn build_raw_lines(&self, hit: &SearchHit, styles: &StyleContext) -> Vec<ftui::text::Line> {
        let mut lines: Vec<ftui::text::Line> = Vec::new();
        let header_style = styles.style(style_system::STYLE_TEXT_PRIMARY).bold();
        let code_style = styles.style(style_system::STYLE_TEXT_SUBTLE);

        lines.push(ftui::text::Line::from_spans(vec![
            ftui::text::Span::styled("Raw Data", header_style),
        ]));
        lines.push(ftui::text::Line::from(""));

        // If we have a cached conversation, serialize the full conversation
        if let Some((_, ref cv)) = self.cached_detail {
            let source_kind = normalized_source_kind(None, &cv.convo.source_id);
            let workspace_original = workspace_original_from_metadata(&cv.convo.metadata_json);
            // Show conversation metadata as JSON
            let json = serde_json::json!({
                "agent": cv.convo.agent_slug,
                "external_id": cv.convo.external_id,
                "title": cv.convo.title,
                "source_path": cv.convo.source_path.display().to_string(),
                "started_at": cv.convo.started_at,
                "ended_at": cv.convo.ended_at,
                "approx_tokens": cv.convo.approx_tokens,
                "source_id": cv.convo.source_id,
                "source_kind": source_kind,
                "origin_host": cv.convo.origin_host,
                "workspace_original": workspace_original,
                "message_count": cv.messages.len(),
            });
            if let Ok(pretty) = serde_json::to_string_pretty(&json) {
                for line in pretty.lines() {
                    lines.push(ftui::text::Line::from_spans(vec![
                        ftui::text::Span::styled(line.to_string(), code_style),
                    ]));
                }
            }

            // Per-message raw data
            for (i, msg) in cv.messages.iter().enumerate() {
                lines.push(ftui::text::Line::from(""));
                lines.push(ftui::text::Line::from_spans(vec![
                    ftui::text::Span::styled(
                        format!("--- Message {} ({}) ---", i + 1, msg.role),
                        header_style,
                    ),
                ]));
                let msg_json = serde_json::json!({
                    "role": msg.role.to_string(),
                    "author": msg.author,
                    "created_at": msg.created_at,
                    "content_length": msg.content.len(),
                    "extra": msg.extra_json,
                });
                if let Ok(pretty) = serde_json::to_string_pretty(&msg_json) {
                    for line in pretty.lines() {
                        lines.push(ftui::text::Line::from_spans(vec![
                            ftui::text::Span::styled(line.to_string(), code_style),
                        ]));
                    }
                }
            }
        } else {
            // Fallback: show the hit itself as JSON
            let hit_json = serde_json::json!({
                "title": hit.title,
                "agent": hit.agent,
                "workspace": hit.workspace,
                "workspace_original": hit.workspace_original,
                "source_path": hit.source_path,
                "score": hit.score,
                "content_length": hit.content.len(),
                "source_id": hit.source_id,
                "source_kind": normalized_source_kind(Some(hit.origin_kind.as_str()), &hit.source_id),
                "origin_kind": hit.origin_kind,
                "origin_host": hit.origin_host,
                "created_at": hit.created_at,
            });
            if let Ok(pretty) = serde_json::to_string_pretty(&hit_json) {
                for line in pretty.lines() {
                    lines.push(ftui::text::Line::from_spans(vec![
                        ftui::text::Span::styled(line.to_string(), code_style),
                    ]));
                }
            }
        }

        lines
    }

    /// Build syntax-highlighted JSON lines for the Json tab using ftui JsonView.
    fn build_json_lines(&self, hit: &SearchHit, styles: &StyleContext) -> Vec<ftui::text::Line> {
        let mut lines: Vec<ftui::text::Line> = Vec::new();
        let header_style = styles.style(style_system::STYLE_TEXT_PRIMARY).bold();

        // Style mapping for JSON tokens
        let key_style = styles.style(style_system::STYLE_ROLE_USER).bold();
        let string_style = styles.style(style_system::STYLE_STATUS_SUCCESS);
        let number_style = styles.style(style_system::STYLE_STATUS_WARNING);
        let literal_style = styles.style(style_system::STYLE_STATUS_INFO);
        let punct_style = styles.style(style_system::STYLE_TEXT_MUTED);
        let error_style = styles.style(style_system::STYLE_STATUS_ERROR);

        // Header
        lines.push(ftui::text::Line::from_spans(vec![
            ftui::text::Span::styled("JSON Viewer", header_style),
        ]));
        lines.push(ftui::text::Line::from(""));

        // Helper: convert JsonView formatted_lines into styled ftui Lines.
        let convert_tokens = |token_lines: Vec<Vec<JsonToken>>, out: &mut Vec<ftui::text::Line>| {
            for token_line in token_lines {
                let mut spans = Vec::new();
                for token in token_line {
                    let (text, style) = match token {
                        JsonToken::Key(s) => (s, key_style),
                        JsonToken::StringVal(s) => (s, string_style),
                        JsonToken::Number(s) => (s, number_style),
                        JsonToken::Literal(s) => (s, literal_style),
                        JsonToken::Punctuation(s) => (s, punct_style),
                        JsonToken::Whitespace(s) => (s, ftui::Style::default()),
                        JsonToken::Newline => continue,
                        JsonToken::Error(s) => (s, error_style),
                    };
                    spans.push(ftui::text::Span::styled(text, style));
                }
                out.push(ftui::text::Line::from_spans(spans));
            }
        };

        if let Some((_, ref cv)) = self.cached_detail {
            // Build the full conversation JSON including metadata and messages
            let source_kind = normalized_source_kind(None, &cv.convo.source_id);
            let workspace_original = workspace_original_from_metadata(&cv.convo.metadata_json);

            let mut messages_json = Vec::new();
            for msg in &cv.messages {
                messages_json.push(serde_json::json!({
                    "role": msg.role.to_string(),
                    "author": msg.author,
                    "created_at": msg.created_at,
                    "content_length": msg.content.len(),
                    "extra": msg.extra_json,
                }));
            }

            let full_json = serde_json::json!({
                "agent": cv.convo.agent_slug,
                "external_id": cv.convo.external_id,
                "title": cv.convo.title,
                "source_path": cv.convo.source_path.display().to_string(),
                "started_at": cv.convo.started_at,
                "ended_at": cv.convo.ended_at,
                "approx_tokens": cv.convo.approx_tokens,
                "source_id": cv.convo.source_id,
                "source_kind": source_kind,
                "origin_host": cv.convo.origin_host,
                "workspace_original": workspace_original,
                "message_count": cv.messages.len(),
                "messages": messages_json,
            });

            if let Ok(json_str) = serde_json::to_string(&full_json) {
                let jv = JsonView::new(json_str)
                    .with_indent(2)
                    .with_key_style(key_style)
                    .with_string_style(string_style)
                    .with_number_style(number_style)
                    .with_literal_style(literal_style)
                    .with_punct_style(punct_style)
                    .with_error_style(error_style);
                convert_tokens(jv.formatted_lines(), &mut lines);
            }
        } else {
            // Fallback: show the hit as JSON
            let hit_json = serde_json::json!({
                "title": hit.title,
                "agent": hit.agent,
                "workspace": hit.workspace,
                "workspace_original": hit.workspace_original,
                "source_path": hit.source_path,
                "score": hit.score,
                "content_length": hit.content.len(),
                "source_id": hit.source_id,
                "source_kind": normalized_source_kind(Some(hit.origin_kind.as_str()), &hit.source_id),
                "origin_kind": hit.origin_kind,
                "origin_host": hit.origin_host,
                "created_at": hit.created_at,
            });

            if let Ok(json_str) = serde_json::to_string(&hit_json) {
                let jv = JsonView::new(json_str)
                    .with_indent(2)
                    .with_key_style(key_style)
                    .with_string_style(string_style)
                    .with_number_style(number_style)
                    .with_literal_style(literal_style)
                    .with_punct_style(punct_style)
                    .with_error_style(error_style);
                convert_tokens(jv.formatted_lines(), &mut lines);
            }
        }

        lines
    }

    /// Apply find-in-detail highlighting to rendered lines.
    fn apply_find_highlight(
        lines: &mut [ftui::text::Line],
        query: &str,
        current_match: usize,
        styles: &StyleContext,
    ) -> Vec<u16> {
        let highlight_style = if styles.options.color_profile.supports_color() {
            styles.style(style_system::STYLE_DETAIL_FIND_MATCH_INACTIVE)
        } else {
            ftui::Style::default().underline().bold()
        };
        let current_style = if styles.options.color_profile.supports_color() {
            styles.style(style_system::STYLE_DETAIL_FIND_MATCH_ACTIVE)
        } else {
            ftui::Style::default().underline().bold().italic()
        };

        let mut query_terms = extract_query_terms(query);
        if query_terms.is_empty() {
            let fallback = query.trim();
            if !fallback.is_empty() {
                query_terms.push(fallback.to_string());
            }
        }
        if query_terms.is_empty() {
            return Vec::new();
        }

        let mut query_terms_lower: Vec<String> = query_terms
            .into_iter()
            .map(|t| t.to_ascii_lowercase())
            .filter(|t| !t.is_empty())
            .collect();
        if query_terms_lower.is_empty() {
            return Vec::new();
        }
        // Prefer longer matches first so specific terms win over overlaps.
        query_terms_lower.sort_by(|a, b| b.len().cmp(&a.len()).then_with(|| a.cmp(b)));
        query_terms_lower.dedup();

        let mut match_positions: Vec<u16> = Vec::new();
        let mut match_idx = 0usize;

        for (line_no, line) in lines.iter_mut().enumerate() {
            let spans: Vec<ftui::text::Span<'static>> = line.spans().to_vec();
            let mut rebuilt: Vec<ftui::text::Span<'static>> = Vec::with_capacity(spans.len() + 4);

            for span in spans {
                let text = span.content.to_string();
                let base_style = span.style;
                if text.is_empty() {
                    rebuilt.push(span);
                    continue;
                }

                let lower = text.to_ascii_lowercase();
                let lower_bytes = lower.as_bytes();
                let mut pos = 0usize;

                while pos < text.len() {
                    let mut matched_len: Option<usize> = None;
                    for term in &query_terms_lower {
                        let term_bytes = term.as_bytes();
                        if term_bytes.is_empty() {
                            continue;
                        }
                        if pos + term_bytes.len() <= lower_bytes.len()
                            && &lower_bytes[pos..pos + term_bytes.len()] == term_bytes
                        {
                            matched_len = Some(term_bytes.len());
                            break;
                        }
                    }

                    if let Some(len) = matched_len {
                        let end = pos + len;
                        let is_current = match_idx == current_match;
                        let overlay = if is_current {
                            current_style
                        } else {
                            highlight_style
                        };

                        // Preserve markdown/syntax styling while layering match emphasis.
                        let mut merged = base_style.unwrap_or_default();
                        if merged.fg.is_none()
                            && let Some(fg) = overlay.fg
                        {
                            merged = merged.fg(fg);
                        }
                        if let Some(bg) = overlay.bg {
                            merged = merged.bg(bg);
                        }
                        merged = if is_current {
                            merged.bold().underline().italic()
                        } else {
                            merged.bold().underline()
                        };

                        rebuilt.push(ftui::text::Span::styled(text[pos..end].to_string(), merged));
                        match_positions.push(line_no as u16);
                        match_idx += 1;
                        pos = end;
                        continue;
                    }

                    let start = pos;
                    let mut cursor = pos;
                    while cursor < text.len() {
                        let mut starts_match = false;
                        for term in &query_terms_lower {
                            let term_bytes = term.as_bytes();
                            if term_bytes.is_empty() {
                                continue;
                            }
                            if cursor + term_bytes.len() <= lower_bytes.len()
                                && &lower_bytes[cursor..cursor + term_bytes.len()] == term_bytes
                            {
                                starts_match = true;
                                break;
                            }
                        }
                        if starts_match {
                            break;
                        }
                        if let Some(ch) = text[cursor..].chars().next() {
                            cursor += ch.len_utf8();
                        } else {
                            break;
                        }
                    }
                    if cursor > start {
                        let chunk = text[start..cursor].to_string();
                        if let Some(style) = base_style {
                            rebuilt.push(ftui::text::Span::styled(chunk, style));
                        } else {
                            rebuilt.push(ftui::text::Span::raw(chunk));
                        }
                    }
                    pos = cursor.max(start + 1).min(text.len());
                }
            }

            *line = ftui::text::Line::from_spans(rebuilt);
        }

        match_positions
    }

    /// Build rendered lines for the Analytics tab in the detail modal.
    ///
    /// Shows per-session analytics: token timeline, tool call frequency,
    /// message length distribution, and model breakdown.
    fn build_analytics_lines(
        &self,
        hit: &SearchHit,
        inner_width: u16,
        styles: &StyleContext,
    ) -> Vec<ftui::text::Line> {
        let mut lines: Vec<ftui::text::Line> = Vec::new();
        let header_style = styles.style(style_system::STYLE_TEXT_PRIMARY).bold();
        let label_style = styles.style(style_system::STYLE_TEXT_SUBTLE);
        let value_style = styles.style(style_system::STYLE_TEXT_PRIMARY);
        let muted_style = styles.style(style_system::STYLE_TEXT_MUTED);
        let bar_width = (inner_width.saturating_sub(20) as usize).clamp(10, 40);

        lines.push(ftui::text::Line::from_spans(vec![
            ftui::text::Span::styled("Session Analytics", header_style),
        ]));
        lines.push(ftui::text::Line::from(""));

        let Some((_, ref cv)) = self.cached_detail else {
            lines.push(ftui::text::Line::from_spans(vec![
                ftui::text::Span::styled("No conversation data loaded for analytics.", muted_style),
            ]));
            return lines;
        };

        if cv.messages.is_empty() {
            lines.push(ftui::text::Line::from_spans(vec![
                ftui::text::Span::styled("No messages in this session.", muted_style),
            ]));
            return lines;
        }

        // -- Section 1: Overview stats ----------------------------------------
        lines.push(ftui::text::Line::from_spans(vec![
            ftui::text::Span::styled("\u{2501} Overview", label_style.bold()),
        ]));

        // Duration
        if let (Some(started), Some(ended)) = (cv.convo.started_at, cv.convo.ended_at) {
            let dur_secs = (ended.saturating_sub(started)) / 1000;
            let dur_str = if dur_secs >= 3600 {
                format!(
                    "{}h {}m {}s",
                    dur_secs / 3600,
                    (dur_secs % 3600) / 60,
                    dur_secs % 60
                )
            } else if dur_secs >= 60 {
                format!("{}m {}s", dur_secs / 60, dur_secs % 60)
            } else {
                format!("{dur_secs}s")
            };
            lines.push(ftui::text::Line::from_spans(vec![
                ftui::text::Span::styled("  Duration: ", label_style),
                ftui::text::Span::styled(dur_str, value_style),
            ]));
        }

        // Token count
        if let Some(tokens) = cv.convo.approx_tokens {
            let tok_str = if tokens >= 1_000_000 {
                format!("{:.2}M", tokens as f64 / 1_000_000.0)
            } else if tokens >= 1_000 {
                format!("{:.1}K", tokens as f64 / 1_000.0)
            } else {
                format!("{tokens}")
            };
            lines.push(ftui::text::Line::from_spans(vec![
                ftui::text::Span::styled("  Tokens:   ", label_style),
                ftui::text::Span::styled(tok_str, value_style),
            ]));
        }

        lines.push(ftui::text::Line::from(""));

        // -- Section 2: Message role breakdown --------------------------------
        lines.push(ftui::text::Line::from_spans(vec![
            ftui::text::Span::styled("\u{2501} Message Breakdown", label_style.bold()),
        ]));

        let mut role_counts: Vec<(&str, u32)> = Vec::new();
        let (mut n_user, mut n_agent, mut n_tool, mut n_sys, mut n_other) =
            (0u32, 0u32, 0u32, 0u32, 0u32);
        for m in &cv.messages {
            match m.role {
                crate::model::types::MessageRole::User => n_user += 1,
                crate::model::types::MessageRole::Agent => n_agent += 1,
                crate::model::types::MessageRole::Tool => n_tool += 1,
                crate::model::types::MessageRole::System => n_sys += 1,
                crate::model::types::MessageRole::Other(_) => n_other += 1,
            }
        }
        role_counts.push(("User", n_user));
        role_counts.push(("Agent", n_agent));
        role_counts.push(("Tool", n_tool));
        role_counts.push(("System", n_sys));
        if n_other > 0 {
            role_counts.push(("Other", n_other));
        }

        let max_count = role_counts
            .iter()
            .map(|(_, c)| *c)
            .max()
            .unwrap_or(1)
            .max(1);
        for (role_name, count) in &role_counts {
            let bar_len = (*count as f64 / max_count as f64 * bar_width as f64) as usize;
            let bar = "\u{2588}".repeat(bar_len);
            let pad = " ".repeat(bar_width.saturating_sub(bar_len));
            lines.push(ftui::text::Line::from_spans(vec![
                ftui::text::Span::styled(format!("  {role_name:<7}"), label_style),
                ftui::text::Span::styled(
                    bar,
                    Self::role_style(
                        &match *role_name {
                            "User" => crate::model::types::MessageRole::User,
                            "Agent" => crate::model::types::MessageRole::Agent,
                            "Tool" => crate::model::types::MessageRole::Tool,
                            "System" => crate::model::types::MessageRole::System,
                            _ => crate::model::types::MessageRole::Other(role_name.to_string()),
                        },
                        styles,
                    ),
                ),
                ftui::text::Span::styled(pad, muted_style),
                ftui::text::Span::styled(format!(" {count}"), value_style),
            ]));
        }

        lines.push(ftui::text::Line::from(""));

        // -- Section 3: Message activity timeline -----------------------------
        if cv.messages.len() >= 2 {
            lines.push(ftui::text::Line::from_spans(vec![
                ftui::text::Span::styled("\u{2501} Activity Timeline", label_style.bold()),
            ]));
            let sparkline =
                Self::build_text_sparkline(&cv.messages, inner_width.saturating_sub(4) as usize);
            if !sparkline.is_empty() {
                lines.push(ftui::text::Line::from_spans(vec![
                    ftui::text::Span::styled("  ", label_style),
                    ftui::text::Span::styled(sparkline, value_style),
                ]));
                lines.push(ftui::text::Line::from_spans(vec![
                    ftui::text::Span::styled("  start", muted_style),
                    ftui::text::Span::styled(
                        " ".repeat((inner_width.saturating_sub(16) as usize).min(50)),
                        muted_style,
                    ),
                    ftui::text::Span::styled("end", muted_style),
                ]));
            }
            lines.push(ftui::text::Line::from(""));
        }

        // -- Section 4: Message length distribution ---------------------------
        lines.push(ftui::text::Line::from_spans(vec![
            ftui::text::Span::styled("\u{2501} Message Length Distribution", label_style.bold()),
        ]));

        let mut lengths_by_role: Vec<(String, usize)> = Vec::new();
        let mut total_chars: usize = 0;
        for m in &cv.messages {
            let len = m.content.len();
            total_chars += len;
            let role_str = format!("{}", m.role);
            lengths_by_role.push((role_str, len));
        }
        let avg_len = if cv.messages.is_empty() {
            0
        } else {
            total_chars / cv.messages.len()
        };
        let max_len = lengths_by_role.iter().map(|(_, l)| *l).max().unwrap_or(0);
        let min_len = lengths_by_role.iter().map(|(_, l)| *l).min().unwrap_or(0);

        lines.push(ftui::text::Line::from_spans(vec![
            ftui::text::Span::styled("  Total chars: ", label_style),
            ftui::text::Span::styled(format!("{total_chars}"), value_style),
            ftui::text::Span::styled(
                format!("  avg: {avg_len}  min: {min_len}  max: {max_len}"),
                muted_style,
            ),
        ]));

        lines.push(ftui::text::Line::from(""));

        // -- Section 5: Tool call analysis ------------------------------------
        if n_tool > 0 {
            lines.push(ftui::text::Line::from_spans(vec![
                ftui::text::Span::styled("\u{2501} Tool Calls", label_style.bold()),
            ]));

            // Extract tool names from tool messages (first line often has tool name)
            let mut tool_names: std::collections::HashMap<String, u32> =
                std::collections::HashMap::new();
            for m in &cv.messages {
                if matches!(m.role, crate::model::types::MessageRole::Tool) {
                    let first_line = m
                        .content
                        .lines()
                        .next()
                        .unwrap_or("(unnamed)")
                        .chars()
                        .take(40)
                        .collect::<String>();
                    *tool_names.entry(first_line).or_default() += 1;
                }
            }

            let mut tool_list: Vec<(String, u32)> = tool_names.into_iter().collect();
            tool_list.sort_by_key(|entry| std::cmp::Reverse(entry.1));

            let tool_max = tool_list.iter().map(|(_, c)| *c).max().unwrap_or(1).max(1);
            for (name, count) in tool_list.iter().take(10) {
                let bar_len = (*count as f64 / tool_max as f64 * bar_width as f64) as usize;
                let bar = "\u{2588}".repeat(bar_len.max(1));
                lines.push(ftui::text::Line::from_spans(vec![
                    ftui::text::Span::styled("  ", label_style),
                    ftui::text::Span::styled(bar, value_style),
                    ftui::text::Span::styled(format!(" {count}\u{00d7} "), value_style),
                    ftui::text::Span::styled(name.to_string(), muted_style),
                ]));
            }
            lines.push(ftui::text::Line::from(""));
        }

        // -- Section 6: Cumulative token usage curve --------------------------
        // Approximate per-message token contribution using content length
        if cv.messages.len() >= 3 {
            lines.push(ftui::text::Line::from_spans(vec![
                ftui::text::Span::styled("\u{2501} Cumulative Content Curve", label_style.bold()),
            ]));

            let cumulative: Vec<usize> = cv
                .messages
                .iter()
                .scan(0usize, |acc, m| {
                    *acc += m.content.len();
                    Some(*acc)
                })
                .collect();
            let max_cum = *cumulative.last().unwrap_or(&1);
            if max_cum > 0 {
                let spark_width = (inner_width.saturating_sub(4) as usize).clamp(8, 60);
                let blocks: &[char] = &[
                    ' ', '\u{2581}', '\u{2582}', '\u{2583}', '\u{2584}', '\u{2585}', '\u{2586}',
                    '\u{2587}', '\u{2588}',
                ];

                // Resample cumulative curve to spark_width buckets
                let mut spark_str = String::with_capacity(spark_width * 3);
                for i in 0..spark_width {
                    let idx =
                        (i as f64 / spark_width as f64 * (cumulative.len() - 1) as f64) as usize;
                    let level = (cumulative[idx.min(cumulative.len() - 1)] as f64 / max_cum as f64
                        * 8.0) as usize;
                    spark_str.push(blocks[level.min(8)]);
                }
                lines.push(ftui::text::Line::from_spans(vec![
                    ftui::text::Span::styled("  ", label_style),
                    ftui::text::Span::styled(spark_str, value_style),
                ]));
                lines.push(ftui::text::Line::from_spans(vec![
                    ftui::text::Span::styled("  0%", muted_style),
                    ftui::text::Span::styled(
                        " ".repeat((inner_width.saturating_sub(14) as usize).min(50)),
                        muted_style,
                    ),
                    ftui::text::Span::styled("100%", muted_style),
                ]));
            }
            lines.push(ftui::text::Line::from(""));
        }

        // -- Footer: help text ------------------------------------------------
        lines.push(ftui::text::Line::from_spans(vec![
            ftui::text::Span::styled(
                format!(
                    "Session: {} \u{2502} {} messages \u{2502} {}",
                    hit.agent,
                    cv.messages.len(),
                    hit.workspace,
                ),
                muted_style,
            ),
        ]));

        lines
    }

    /// Render the detail/preview pane with rich content (Messages/Snippets/Raw).
    #[allow(clippy::too_many_arguments)]
    fn render_detail_pane(
        &self,
        frame: &mut super::ftui_adapter::Frame,
        area: Rect,
        border_type: BorderType,
        borders: Borders,
        styles: &StyleContext,
        pane_style: ftui::Style,
        pane_focused_style: ftui::Style,
        title_focused_style: ftui::Style,
        title_unfocused_style: ftui::Style,
        text_muted_style: ftui::Style,
    ) {
        // Keep the title explicit: include the active tab + wrap state.
        let wrap_indicator = if self.detail_wrap { " \u{21a9}" } else { "" };
        let tab_label = match self.detail_tab {
            DetailTab::Messages => "Messages",
            DetailTab::Snippets => "Snippets",
            DetailTab::Raw => "Raw",
            DetailTab::Json => "Json",
            DetailTab::Analytics => "Analytics",
        };
        let title = format!("Detail [{tab_label}]{wrap_indicator}");

        let detail_focused = self.focused_region() == FocusRegion::Detail;
        let styleful = title_focused_style.fg.is_some()
            || title_unfocused_style.fg.is_some()
            || pane_focused_style.bg.is_some()
            || pane_style.bg.is_some();
        let detail_focus_pulse = if detail_focused && self.anim.enabled {
            (1.0 - self.anim.focus_flash_progress()).clamp(0.0, 1.0)
        } else {
            0.0
        };
        let tab_semantic_accent = match self.detail_tab {
            DetailTab::Messages => styles
                .style(style_system::STYLE_STATUS_INFO)
                .fg
                .unwrap_or(ftui::PackedRgba::rgb(90, 180, 255)),
            DetailTab::Snippets => styles
                .style(style_system::STYLE_STATUS_SUCCESS)
                .fg
                .unwrap_or(ftui::PackedRgba::rgb(120, 220, 160)),
            DetailTab::Raw => styles
                .style(style_system::STYLE_STATUS_WARNING)
                .fg
                .unwrap_or(ftui::PackedRgba::rgb(255, 195, 110)),
            DetailTab::Json => styles
                .style(style_system::STYLE_ROLE_TOOL)
                .fg
                .unwrap_or(ftui::PackedRgba::rgb(190, 175, 255)),
            DetailTab::Analytics => styles
                .style(style_system::STYLE_ROLE_ASSISTANT)
                .fg
                .unwrap_or(ftui::PackedRgba::rgb(120, 220, 220)),
        };
        let detail_accent = if let Some(hit) = self.selected_hit() {
            let agent_accent = legacy_agent_color(&hit.agent);
            ftui::PackedRgba::rgb(
                lerp_u8(agent_accent.r(), tab_semantic_accent.r(), 0.42),
                lerp_u8(agent_accent.g(), tab_semantic_accent.g(), 0.42),
                lerp_u8(agent_accent.b(), tab_semantic_accent.b(), 0.42),
            )
        } else {
            tab_semantic_accent
        };
        let mut block_style = if detail_focused {
            pane_focused_style
        } else {
            pane_style
        };
        let mut detail_border_style = if detail_focused {
            title_focused_style
        } else {
            title_unfocused_style
        };
        if styleful {
            let border_accent = if detail_focus_pulse > 0.01 {
                let t = (0.08 + detail_focus_pulse * 0.30).clamp(0.0, 0.42);
                ftui::PackedRgba::rgb(
                    lerp_u8(detail_accent.r(), 255, t),
                    lerp_u8(detail_accent.g(), 255, t),
                    lerp_u8(detail_accent.b(), 255, t),
                )
            } else {
                detail_accent
            };
            block_style = block_style.bg(dim_packed_color(
                detail_accent,
                if detail_focused {
                    (0.11 + detail_focus_pulse * 0.07).clamp(0.0, 0.22)
                } else {
                    0.06
                },
            ));
            detail_border_style = if detail_focused {
                detail_border_style.fg(border_accent).bold()
            } else {
                detail_border_style.fg(dim_packed_color(detail_accent, 0.60))
            };
        }
        let detail_block = Block::new()
            .borders(borders)
            .border_type(border_type)
            .title(&title)
            .title_alignment(Alignment::Left)
            .border_style(detail_border_style)
            .style(block_style);
        let full_inner = detail_block.inner(area);
        detail_block.render(area, frame);

        *self.last_detail_area.borrow_mut() = Some(area);

        if full_inner.is_empty() {
            return;
        }

        // Render styled tab bar inside the pane (first row).
        let inner = if full_inner.height >= 3 {
            let mut tab_active_s = styles.style(style_system::STYLE_TAB_ACTIVE);
            let mut tab_inactive_s = styles.style(style_system::STYLE_TAB_INACTIVE);
            let mut tab_divider_s = text_muted_style;
            let mut tab_row_style = block_style;
            if styleful {
                tab_active_s = tab_active_s
                    .fg(detail_accent)
                    .bg(dim_packed_color(
                        detail_accent,
                        if detail_focused {
                            (0.22 + detail_focus_pulse * 0.10).clamp(0.0, 0.34)
                        } else {
                            0.16
                        },
                    ))
                    .bold()
                    .underline();
                tab_inactive_s = tab_inactive_s.fg(dim_packed_color(detail_accent, 0.72));
                tab_divider_s = text_muted_style.fg(dim_packed_color(
                    detail_accent,
                    if detail_focused {
                        (0.52 + detail_focus_pulse * 0.14).clamp(0.0, 0.72)
                    } else {
                        0.52
                    },
                ));
                tab_row_style = tab_row_style.bg(dim_packed_color(
                    detail_accent,
                    if detail_focused {
                        (0.13 + detail_focus_pulse * 0.07).clamp(0.0, 0.24)
                    } else {
                        0.08
                    },
                ));
            }
            let tab_items = [
                ("Messages", DetailTab::Messages),
                ("Snippets", DetailTab::Snippets),
                ("Raw", DetailTab::Raw),
                ("Json", DetailTab::Json),
                ("Analytics", DetailTab::Analytics),
            ];
            let mut tab_spans: Vec<ftui::text::Span> =
                vec![ftui::text::Span::styled(" ", block_style)];
            for (i, (lbl, variant)) in tab_items.iter().enumerate() {
                if i > 0 {
                    tab_spans.push(ftui::text::Span::styled(" \u{2502} ", tab_divider_s));
                }
                if self.detail_tab == *variant {
                    tab_spans.push(ftui::text::Span::styled(
                        format!(" \u{25cf} {lbl} "),
                        tab_active_s,
                    ));
                } else {
                    tab_spans.push(ftui::text::Span::styled(format!(" {lbl} "), tab_inactive_s));
                }
            }
            let tab_row = Rect::new(full_inner.x, full_inner.y, full_inner.width, 1);
            Paragraph::new(ftui::text::Text::from_lines(vec![
                ftui::text::Line::from_spans(tab_spans),
            ]))
            .style(tab_row_style)
            .render(tab_row, frame);
            Rect::new(
                full_inner.x,
                full_inner.y + 1,
                full_inner.width,
                full_inner.height - 1,
            )
        } else {
            full_inner
        };

        if inner.is_empty() {
            return;
        }

        // Reserve space for the find bar whenever a find state exists.
        // This keeps query + match context visible even when the user is not actively editing.
        let find_bar_visible = self.detail_find.is_some();
        let (content_area, find_area) = if find_bar_visible {
            let find_h = if inner.height >= 4 { 2u16 } else { 1u16 };
            if inner.height <= find_h + 1 {
                (inner, None)
            } else {
                let content = Rect::new(inner.x, inner.y, inner.width, inner.height - find_h);
                let find = Rect::new(inner.x, inner.y + content.height, inner.width, find_h);
                (content, Some(find))
            }
        } else {
            (inner, None)
        };

        if !content_area.is_empty() {
            Block::new().style(block_style).render(content_area, frame);
        }
        if let Some(find_rect) = find_area
            && !find_rect.is_empty()
        {
            Block::new().style(block_style).render(find_rect, frame);
        }

        if let Some(hit) = self.selected_hit() {
            if self.loading_context == Some(LoadingContext::DetailModal) {
                let loading_line = format!(
                    "{} Loading conversation details...",
                    self.loading_spinner_glyph()
                );
                Paragraph::new(loading_line)
                    .style(text_muted_style)
                    .render(content_area, frame);
                return;
            }
            // Render sticky metadata header on Messages tab
            let content_area = if self.detail_tab == DetailTab::Messages && content_area.height >= 6
            {
                let header_lines = self.build_detail_header_lines(hit, content_area.width, styles);
                let header_h = header_lines.len().min(5) as u16;
                if header_h > 0 && content_area.height > header_h + 2 {
                    let header_rect =
                        Rect::new(content_area.x, content_area.y, content_area.width, header_h);
                    let header_text = ftui::text::Text::from_lines(header_lines);
                    Paragraph::new(header_text)
                        .style(styles.style(style_system::STYLE_TEXT_PRIMARY))
                        .render(header_rect, frame);
                    Rect::new(
                        content_area.x,
                        content_area.y + header_h,
                        content_area.width,
                        content_area.height - header_h,
                    )
                } else {
                    content_area
                }
            } else {
                content_area
            };

            // Build lines based on active tab
            let mut lines = match self.detail_tab {
                DetailTab::Messages => self.build_messages_lines(hit, content_area.width, styles),
                DetailTab::Snippets => self.build_snippets_lines(hit, styles),
                DetailTab::Raw => self.build_raw_lines(hit, styles),
                DetailTab::Json => self.build_json_lines(hit, styles),
                DetailTab::Analytics => self.build_analytics_lines(hit, content_area.width, styles),
            };

            // Apply find-in-detail highlighting and cache match positions.
            //
            // Find highlighting stays active regardless of whether the user is editing;
            // the current match index controls the "active" emphasis.
            if let Some(ref find) = self.detail_find {
                let matches =
                    Self::apply_find_highlight(&mut lines, &find.query, find.current, styles);
                // Deduplicate: match_positions has one entry per occurrence; we want
                // unique line numbers for navigation.
                let mut unique_lines: Vec<u16> = Vec::new();
                for &ln in &matches {
                    if unique_lines.last() != Some(&ln) {
                        unique_lines.push(ln);
                    }
                }
                *self.detail_find_matches_cache.borrow_mut() = unique_lines;
            } else {
                self.detail_find_matches_cache.borrow_mut().clear();
            }

            // Apply scroll offset — skip `detail_scroll` lines
            let scroll = self.detail_scroll as usize;
            let visible_height = content_area.height as usize;
            let total_lines = lines.len();

            // Store content metrics for scroll clamping in update handlers
            self.detail_content_lines.set(total_lines as u16);
            self.detail_visible_height.set(content_area.height);

            // Clamp scroll
            let effective_scroll = scroll.min(total_lines.saturating_sub(1));
            let visible_lines: Vec<ftui::text::Line> = lines
                .into_iter()
                .skip(effective_scroll)
                .take(visible_height)
                .collect();

            // Render the text
            let text = ftui::text::Text::from_lines(visible_lines);
            Paragraph::new(text)
                .style(styles.style(style_system::STYLE_TEXT_PRIMARY))
                .render(content_area, frame);

            // Scroll position indicator in bottom-right if content exceeds viewport
            if total_lines > visible_height {
                let pct = if total_lines <= 1 {
                    100
                } else {
                    (effective_scroll * 100) / (total_lines.saturating_sub(visible_height))
                };
                let indicator = format!(" {}/{} ({pct}%) ", effective_scroll + 1, total_lines);
                let ind_w = indicator.len().min(content_area.width as usize);
                let ind_x = content_area.x + content_area.width.saturating_sub(ind_w as u16);
                let ind_y = content_area.y + content_area.height.saturating_sub(1);
                let ind_area = Rect::new(ind_x, ind_y, ind_w as u16, 1);
                let ind_style = styles.style(style_system::STYLE_TEXT_MUTED);
                Paragraph::new(&*indicator)
                    .style(ind_style)
                    .render(ind_area, frame);
            }
        } else {
            Paragraph::new("Select a result to preview context and metadata.")
                .style(text_muted_style)
                .render(content_area, frame);
        }

        // Render find bar only while actively editing find text.
        if let (Some(find), Some(find_rect)) = (&self.detail_find, find_area) {
            let container_style = styles.style(style_system::STYLE_DETAIL_FIND_CONTAINER);
            let query_style = styles.style(style_system::STYLE_DETAIL_FIND_QUERY);
            let match_active_style = styles.style(style_system::STYLE_DETAIL_FIND_MATCH_ACTIVE);
            let match_inactive_style = styles.style(style_system::STYLE_DETAIL_FIND_MATCH_INACTIVE);

            if find_rect.height > 1 {
                let find_block = Block::new()
                    .borders(Borders::TOP)
                    .border_type(border_type)
                    .border_style(if detail_focused {
                        title_focused_style
                    } else {
                        title_unfocused_style
                    })
                    .title(if detail_focused { " Find / " } else { " Find " })
                    .title_alignment(Alignment::Left)
                    .style(container_style);
                let find_inner = find_block.inner(find_rect);
                find_block.render(find_rect, frame);

                if !find_inner.is_empty() {
                    let text_area = if find_inner.width > 2 {
                        Rect::new(
                            find_inner.x + 1,
                            find_inner.y,
                            find_inner.width - 2,
                            find_inner.height,
                        )
                    } else {
                        find_inner
                    };
                    let line = build_detail_find_bar_line(
                        find,
                        text_area.width,
                        query_style,
                        match_active_style,
                        match_inactive_style,
                    );
                    Paragraph::new(ftui::text::Text::from_lines(vec![line]))
                        .style(container_style)
                        .render(text_area, frame);
                }
            } else {
                Block::new().style(container_style).render(find_rect, frame);
                let line = build_detail_find_bar_line(
                    find,
                    find_rect.width,
                    query_style,
                    match_active_style,
                    match_inactive_style,
                );
                Paragraph::new(ftui::text::Text::from_lines(vec![line]))
                    .style(container_style)
                    .render(find_rect, frame);
            }
        }
    }

    /// Render the theme editor modal (centered, with color slots and contrast report).
    fn render_theme_editor_overlay(
        &self,
        frame: &mut super::ftui_adapter::Frame,
        area: Rect,
        styles: &StyleContext,
    ) {
        let Some(editor) = self.theme_editor.as_ref() else {
            return;
        };

        let popup_w = 60u16.min(area.width.saturating_sub(4));
        let popup_h = (ThemeColorSlot::ALL.len() as u16 + 8).min(area.height.saturating_sub(4));
        if popup_w < 30 || popup_h < 10 {
            return;
        }

        let px = area.x + (area.width.saturating_sub(popup_w)) / 2;
        let py = area.y + (area.height.saturating_sub(popup_h)) / 2;
        let popup_area = Rect::new(px, py, popup_w, popup_h);

        let bg_style = styles.style(style_system::STYLE_PANE_BASE);
        let border_style = styles.style(style_system::STYLE_PANE_FOCUSED);
        let muted_style = styles.style(style_system::STYLE_TEXT_MUTED);
        let primary_style = styles.style(style_system::STYLE_TEXT_PRIMARY);
        let warn_style = styles.style(style_system::STYLE_STATUS_WARNING);
        let selected_style = styles.style(style_system::STYLE_RESULT_ROW_SELECTED);

        Block::new().style(bg_style).render(popup_area, frame);

        let title = format!(
            " Theme Editor [{}] (Ctrl+Shift+T) ",
            editor.base_preset.name()
        );
        let block = Block::new()
            .borders(Borders::ALL)
            .border_type(BorderType::Rounded)
            .title(&title)
            .title_alignment(Alignment::Left)
            .style(border_style);
        let inner = block.inner(popup_area);
        block.render(popup_area, frame);

        if inner.is_empty() {
            return;
        }

        let mut y = inner.y;
        let max_y = inner.y + inner.height;

        // Header line
        if y < max_y {
            let header = format!(" {:14} {:9} {:7}", "Slot", "Override", "Resolved");
            Paragraph::new(&*header)
                .style(muted_style)
                .render(Rect::new(inner.x, y, inner.width, 1), frame);
            y += 1;
        }

        // Color slot rows
        let visible_start = editor.scroll;
        let visible_count = (max_y.saturating_sub(y).saturating_sub(3)) as usize;

        for (i, slot) in ThemeColorSlot::ALL
            .iter()
            .enumerate()
            .skip(visible_start)
            .take(visible_count)
        {
            if y >= max_y.saturating_sub(3) {
                break;
            }

            let is_selected = i == editor.selected;
            let override_val = slot.get(&editor.overrides);
            let resolved = slot.resolved_color(styles.resolved);
            let rgb = resolved.to_rgb();
            let resolved_hex = format!("#{:02x}{:02x}{:02x}", rgb.r, rgb.g, rgb.b);

            let pointer = if is_selected { ">" } else { " " };
            let override_str = override_val.unwrap_or("-");

            let row_text = if is_selected && editor.editing {
                format!("{pointer} {:14} #{:<8}", slot.label(), editor.hex_buffer)
            } else {
                format!(
                    "{pointer} {:14} {:9} {}",
                    slot.label(),
                    override_str,
                    resolved_hex
                )
            };

            let row_style = if is_selected {
                selected_style
            } else {
                primary_style
            };
            let row_area = Rect::new(inner.x, y, inner.width, 1);
            Paragraph::new(&*row_text)
                .style(row_style)
                .render(row_area, frame);

            // Color swatch at end of row (3 chars wide)
            if inner.width > 40 {
                let swatch_x = inner.x + inner.width - 4;
                let swatch_area = Rect::new(swatch_x, y, 3, 1);
                let swatch_style =
                    ftui::Style::default().bg(ftui::PackedRgba::rgb(rgb.r, rgb.g, rgb.b));
                Paragraph::new("   ")
                    .style(swatch_style)
                    .render(swatch_area, frame);
            }

            y += 1;
        }

        // Contrast warnings
        if !editor.contrast_warnings.is_empty() && y < max_y.saturating_sub(1) {
            let warn_text = format!("! {} contrast warning(s)", editor.contrast_warnings.len());
            Paragraph::new(&*warn_text)
                .style(warn_style)
                .render(Rect::new(inner.x, y, inner.width, 1), frame);
            y += 1;
        }

        // Footer hints
        let hint = if editor.editing {
            "Enter:apply  Esc:cancel"
        } else {
            "j/k:nav  Enter:edit  Del:clear  p:preset  s:save  Esc:close"
        };
        let hint_y = max_y.saturating_sub(1);
        if hint_y > y {
            Paragraph::new(hint)
                .style(muted_style)
                .render(Rect::new(inner.x, hint_y, inner.width, 1), frame);
        }
    }

    /// Render the palette evidence ledger panel below the palette overlay.
    fn render_palette_evidence(
        &self,
        frame: &mut super::ftui_adapter::Frame,
        area: Rect,
        styles: &StyleContext,
    ) {
        use ftui::widgets::Widget;
        let panel_w = 68u16.min(area.width.saturating_sub(4));
        let panel_h = 12u16.min(area.height.saturating_sub(4));
        if panel_w < 30 || panel_h < 5 {
            return;
        }
        let px = area.x + (area.width.saturating_sub(panel_w)) / 2;
        let py = area.y + area.height.saturating_sub(panel_h + 1);
        let panel_area = Rect::new(px, py, panel_w, panel_h);
        let bg = styles.style(style_system::STYLE_PANE_BASE);
        let accent = styles.style(style_system::STYLE_PANE_FOCUSED);
        let dim = styles.style(style_system::STYLE_TEXT_MUTED);
        Block::new().style(bg).render(panel_area, frame);
        let outer = Block::new()
            .borders(Borders::ALL)
            .border_type(if panel_w >= 40 {
                BorderType::Rounded
            } else {
                BorderType::Square
            })
            .title(" Evidence Ledger (Alt+E) ")
            .title_alignment(Alignment::Left)
            .style(accent);
        let inner = outer.inner(panel_area);
        outer.render(panel_area, frame);
        let mut lines: Vec<ftui::text::Line> = Vec::new();
        if let Some(matched) = self.command_palette.selected_match() {
            let desc = matched.result.match_type.description();
            let pct = (matched.result.score * 100.0) as u32;
            lines.push(ftui::text::Line::from_spans(vec![
                ftui::text::Span::styled(
                    format!("{} | {} | score {}%", matched.action.title, desc, pct),
                    accent,
                ),
            ]));
            for entry in matched.result.evidence.entries() {
                let dir = if entry.bayes_factor > 1.0 {
                    "+"
                } else if entry.bayes_factor < 1.0 {
                    "-"
                } else {
                    "="
                };
                lines.push(ftui::text::Line::from_spans(vec![
                    ftui::text::Span::styled(
                        format!(
                            "  {} {:?}: BF={:.2} {}",
                            dir, entry.kind, entry.bayes_factor, entry.description
                        ),
                        dim,
                    ),
                ]));
            }
            let bf = matched.result.evidence.combined_bayes_factor();
            let post = matched.result.evidence.posterior_probability();
            lines.push(ftui::text::Line::from_spans(vec![
                ftui::text::Span::styled(
                    format!("  combined BF={:.2} | posterior={:.1}%", bf, post * 100.0),
                    accent,
                ),
            ]));
        } else {
            lines.push(ftui::text::Line::from_spans(vec![
                ftui::text::Span::styled("No match selected. Type a query to see evidence.", dim),
            ]));
        }
        let stats = self.command_palette.scorer_stats();
        lines.push(ftui::text::Line::from_spans(vec![
            ftui::text::Span::styled(
                format!(
                    "scorer: {} full + {} incr | prune {:.0}%",
                    stats.full_scans,
                    stats.incremental_scans,
                    stats.prune_ratio() * 100.0
                ),
                dim,
            ),
        ]));
        // Latency stats line
        let lat = &self.palette_latency;
        if lat.query_count > 0 || lat.bench_mode {
            let mut parts = format!(
                "latency: {}us last | {}us avg | {}us peak [{}]",
                lat.last_query_us,
                lat.avg_us(),
                lat.peak_us,
                lat.budget_indicator(),
            );
            if lat.bench_mode {
                parts.push_str(&format!(" | bench: {:.1} q/s", lat.queries_per_sec()));
            }
            lines.push(ftui::text::Line::from_spans(vec![
                ftui::text::Span::styled(parts, dim),
            ]));
        }
        {
            let mut ly = inner.y;
            for line in &lines {
                if ly >= inner.y + inner.height {
                    break;
                }
                let row = Rect::new(inner.x, ly, inner.width, 1);
                Paragraph::new(
                    line.spans()
                        .iter()
                        .map(|s| &*s.content)
                        .collect::<Vec<_>>()
                        .join(""),
                )
                .style(bg)
                .render(row, frame);
                ly += 1;
            }
        }
    }

    /// Render the inspector debug overlay in the bottom-right corner.
    fn render_inspector_overlay(
        &self,
        frame: &mut super::ftui_adapter::Frame,
        area: Rect,
        styles: &StyleContext,
    ) {
        // Responsive overlay sizing driven by CockpitTopology (1mfw3.3.3).
        let bp = LayoutBreakpoint::from_width(area.width);
        let cockpit_mode = self.cockpit.mode;
        let topo = bp.cockpit_topology(cockpit_mode);
        let overlay_w = topo.overlay_max_w.min(area.width.saturating_sub(2));
        // For low-height terminals, further clamp to 60% of available height
        let height_cap = (area.height as u32 * 60 / 100).max(topo.overlay_min_h as u32) as u16;
        let overlay_h = topo
            .overlay_max_h
            .min(height_cap)
            .min(area.height.saturating_sub(2));
        if overlay_w < topo.overlay_min_w || overlay_h < topo.overlay_min_h {
            return; // Too small — auto-disable
        }
        let ox = area.x + area.width.saturating_sub(overlay_w + 1);
        let oy = area.y + area.height.saturating_sub(overlay_h + 1);
        let overlay_area = Rect::new(ox, oy, overlay_w, overlay_h);

        let bg_style = styles.style(style_system::STYLE_PANE_BASE);
        let border_style = styles.style(style_system::STYLE_PANE_FOCUSED);
        let muted_style = styles.style(style_system::STYLE_TEXT_MUTED);
        let value_style = styles.style(style_system::STYLE_TEXT_PRIMARY);

        // Clear background
        Block::new().style(bg_style).render(overlay_area, frame);

        // Tab bar header — use short labels based on topology
        let tabs = [
            InspectorTab::Timing,
            InspectorTab::Layout,
            InspectorTab::HitRegions,
            InspectorTab::Resize,
            InspectorTab::Diff,
            InspectorTab::Budget,
            InspectorTab::Timeline,
        ];
        let tab_header: String = tabs
            .iter()
            .map(|t| {
                let lbl = if topo.use_short_labels {
                    t.short_label()
                } else {
                    t.label()
                };
                if *t == self.inspector_tab {
                    format!("[{lbl}]")
                } else {
                    lbl.to_string()
                }
            })
            .collect::<Vec<_>>()
            .join(" ");
        // Mode indicator: show cockpit mode + overlay/expanded when space permits
        let mode_indicator = if self.cockpit.enabled && topo.show_mode_indicator {
            match cockpit_mode {
                crate::ui::data::CockpitMode::Overlay => " [cockpit]",
                crate::ui::data::CockpitMode::Expanded => " [expanded]",
            }
        } else {
            ""
        };
        let title = format!(" {tab_header}{mode_indicator} ");
        // Truncate title to fit within overlay width (leave room for border corners).
        // Use char_indices to find a safe truncation point (no mid-char panics).
        let max_title_len = overlay_w.saturating_sub(2) as usize;
        let title = if title.len() > max_title_len {
            let cutoff = max_title_len.saturating_sub(1);
            let safe_end = title
                .char_indices()
                .take_while(|(i, _)| *i <= cutoff)
                .last()
                .map(|(i, _)| i)
                .unwrap_or(0);
            let mut truncated = title[..safe_end].to_string();
            truncated.push('\u{2026}'); // ellipsis
            truncated
        } else {
            title
        };

        let block = Block::new()
            .borders(Borders::ALL)
            .border_type(BorderType::Rounded)
            .title(&title)
            .title_alignment(Alignment::Left)
            .style(border_style);
        let inner = block.inner(overlay_area);
        block.render(overlay_area, frame);

        if inner.is_empty() {
            return;
        }

        let mut y = inner.y;
        let max_y = inner.y + inner.height;

        match self.inspector_tab {
            InspectorTab::Timing => {
                let fps = self.frame_timing.fps();
                let avg = self.frame_timing.avg_us();
                let p95 = self.frame_timing.p95_us();
                let last = self.frame_timing.last_us();
                let samples = self.frame_timing.frame_times_us.len();

                let lines = [
                    format!("FPS:     {fps:.1}"),
                    format!("Avg:     {:.2}ms", avg as f64 / 1000.0),
                    format!("P95:     {:.2}ms", p95 as f64 / 1000.0),
                    format!("Last:    {:.2}ms", last as f64 / 1000.0),
                    format!("Samples: {samples}"),
                    String::new(),
                    format!("Search:  {}ms", self.last_search_ms.unwrap_or(0)),
                    format!("Results: {}", self.results.len()),
                    format!("Panes:   {}", self.panes.len()),
                ];

                for line in &lines {
                    if y >= max_y {
                        break;
                    }
                    let row = Rect::new(inner.x, y, inner.width, 1);
                    let st = if line.is_empty() {
                        muted_style
                    } else {
                        value_style
                    };
                    Paragraph::new(line.as_str()).style(st).render(row, frame);
                    y += 1;
                }
            }
            InspectorTab::Layout => {
                let bp = LayoutBreakpoint::from_width(area.width);
                let bp_str = bp.inspector_label();
                let topo = bp.search_topology();
                let topo_str = if topo.dual_pane {
                    format!("Dual (res≥{}, det≥{})", topo.min_results, topo.min_detail)
                } else {
                    "Single (focus-switched)".to_string()
                };
                let lines = [
                    format!("Terminal: {}x{}", area.width, area.height),
                    format!("Layout:   {bp_str}"),
                    format!("Topology: {topo_str}"),
                    format!("Density:  {:?}", self.density_mode),
                    format!(
                        "Borders:  {}",
                        if self.fancy_borders {
                            "Rounded"
                        } else {
                            "Plain"
                        }
                    ),
                    format!("Focus:    {:?}", self.focused_region()),
                    format!("FocusID:  {:?}", self.focus_manager.current()),
                    format!("Trapped:  {}", self.focus_manager.is_trapped()),
                    format!("Theme:    {:?}", self.theme_preset),
                    format!("Input:    {:?}", self.input_mode),
                ];

                for line in &lines {
                    if y >= max_y {
                        break;
                    }
                    let row = Rect::new(inner.x, y, inner.width, 1);
                    Paragraph::new(line.as_str())
                        .style(value_style)
                        .render(row, frame);
                    y += 1;
                }
            }
            InspectorTab::HitRegions => {
                let regions: Vec<(String, Option<Rect>)> = vec![
                    ("SearchBar".into(), *self.last_search_bar_area.borrow()),
                    ("Results".into(), *self.last_results_inner.borrow()),
                    ("Detail".into(), *self.last_detail_area.borrow()),
                    ("Status".into(), *self.last_status_area.borrow()),
                    ("Content".into(), *self.last_content_area.borrow()),
                    ("SplitHandle".into(), *self.last_split_handle_area.borrow()),
                ];

                for (name, rect) in &regions {
                    if y >= max_y {
                        break;
                    }
                    let row = Rect::new(inner.x, y, inner.width, 1);
                    let text = match rect {
                        Some(r) => {
                            format!("{name:<12} {}x{} @({},{})", r.width, r.height, r.x, r.y)
                        }
                        None => format!("{name:<12} (not rendered)"),
                    };
                    let st = if rect.is_some() {
                        value_style
                    } else {
                        muted_style
                    };
                    Paragraph::new(&*text).style(st).render(row, frame);
                    y += 1;
                }

                // Pill count and pane count
                if y < max_y {
                    let pill_count = self.last_pill_rects.borrow().len();
                    let pane_count = self.last_pane_rects.borrow().len();
                    let text = format!("Pills: {pill_count}  Panes: {pane_count}");
                    let row = Rect::new(inner.x, y, inner.width, 1);
                    Paragraph::new(&*text).style(muted_style).render(row, frame);
                }
            }
            InspectorTab::Resize => {
                let s = &self.evidence.summary;
                if !self.evidence.has_any() {
                    let no_data = "No resize evidence yet";
                    let row = Rect::new(inner.x, y, inner.width, 1);
                    Paragraph::new(no_data)
                        .style(muted_style)
                        .render(row, frame);
                    y += 1;
                    if y < max_y {
                        let hint2 = "(waiting for runtime events)";
                        let row2 = Rect::new(inner.x, y, inner.width, 1);
                        Paragraph::new(hint2).style(muted_style).render(row2, frame);
                    }
                } else {
                    let lines = [
                        format!("Regime:  {}", s.regime),
                        format!("Degrad:  {}", s.degradation),
                        format!("Budget:  {:.1}ms", s.budget_us / 1000.0),
                        format!("Frame:   {:.1}ms", s.frame_time_us / 1000.0),
                        format!("PID:     {:.2}", s.pid_output),
                        format!(
                            "Size:    {}",
                            s.applied_size
                                .map(|(w, h)| format!("{w}x{h}"))
                                .unwrap_or_else(|| "\u{2014}".into())
                        ),
                        format!(
                            "BOCPD:   {}",
                            s.bocpd_p_burst
                                .map(|p| format!("P(burst)={p:.2}"))
                                .unwrap_or_else(|| "off".into())
                        ),
                        format!(
                            "Delay:   {}",
                            s.bocpd_delay_ms
                                .map(|d| format!("{d}ms"))
                                .unwrap_or_else(|| "\u{2014}".into())
                        ),
                        format!("Warmup:  {}", if s.in_warmup { "yes" } else { "no" }),
                        format!("Frames:  {}", s.frames_observed),
                        format!("History: {} decisions", s.history_len()),
                    ];
                    for line in &lines {
                        if y >= max_y {
                            break;
                        }
                        let row = Rect::new(inner.x, y, inner.width, 1);
                        Paragraph::new(line.as_str())
                            .style(value_style)
                            .render(row, frame);
                        y += 1;
                    }
                }
            }
            InspectorTab::Diff => {
                let warn_style = styles.style(style_system::STYLE_STATUS_WARNING);
                if let Some(diff) = &self.evidence.diff {
                    let ev = &diff.evidence;
                    // Human-readable rationale
                    let rationale = if !diff.fallback_reason.is_empty() {
                        format!("fallback: {}", diff.fallback_reason)
                    } else if ev.hysteresis_applied {
                        format!(
                            "hysteresis held ({:.0}% ratio)",
                            ev.hysteresis_ratio * 100.0
                        )
                    } else if !ev.guard_reason.is_empty() {
                        format!("guard: {}", ev.guard_reason)
                    } else {
                        let winner =
                            if ev.cost_dirty <= ev.cost_full && ev.cost_dirty <= ev.cost_redraw {
                                "DirtyRows cheapest"
                            } else if ev.cost_full <= ev.cost_redraw {
                                "Full cheapest"
                            } else {
                                "FullRedraw cheapest"
                            };
                        winner.to_string()
                    };
                    let is_full_redraw = matches!(
                        diff.strategy_used,
                        ftui::render::diff_strategy::DiffStrategy::FullRedraw
                    );
                    let rows: Vec<(&str, String, bool)> = vec![
                        (
                            "Strategy",
                            format!("{}", diff.strategy_used),
                            is_full_redraw,
                        ),
                        ("Why", rationale, false),
                        (
                            "Screen",
                            format!("{}x{} {}", diff.cols, diff.rows, diff.screen_mode),
                            false,
                        ),
                        (
                            "Dirty",
                            format!(
                                "{}/{} ({:.0}%)",
                                ev.dirty_rows,
                                ev.total_rows,
                                ev.posterior_mean * 100.0
                            ),
                            ev.posterior_mean > 0.5,
                        ),
                        (
                            "Costs",
                            format!(
                                "F={:.0} D={:.0} R={:.0}",
                                ev.cost_full, ev.cost_dirty, ev.cost_redraw
                            ),
                            false,
                        ),
                        (
                            "Spans",
                            format!(
                                "{} ({:.0}% cov)",
                                diff.span_count,
                                diff.span_coverage_pct * 100.0
                            ),
                            false,
                        ),
                        (
                            "Tile",
                            if diff.tile_used {
                                "yes".to_string()
                            } else if diff.tile_fallback.is_empty() {
                                "no".to_string()
                            } else {
                                format!("no ({})", diff.tile_fallback)
                            },
                            false,
                        ),
                    ];
                    for (label, value, is_warn) in &rows {
                        if y >= max_y {
                            break;
                        }
                        let row = Rect::new(inner.x, y, inner.width, 1);
                        let text = format!("{label:<8}  {value}");
                        let st = if *is_warn { warn_style } else { value_style };
                        Paragraph::new(text).style(st).render(row, frame);
                        y += 1;
                    }
                } else {
                    let row = Rect::new(inner.x, y, inner.width, 1);
                    Paragraph::new("No diff evidence yet")
                        .style(muted_style)
                        .render(row, frame);
                }
            }
            InspectorTab::Budget => {
                let warn_style = styles.style(style_system::STYLE_STATUS_WARNING);
                let error_style = styles.style(style_system::STYLE_STATUS_ERROR);
                if let Some(budget) = &self.evidence.budget {
                    let overrun = budget.frame_time_us > budget.budget_us;
                    let degrading =
                        budget.degradation_after as u8 > budget.degradation_before as u8;
                    let pid_arrow = if budget.pid_output > 0.1 {
                        "\u{2191}" // pressure increasing
                    } else if budget.pid_output < -0.1 {
                        "\u{2193}" // pressure decreasing
                    } else {
                        "\u{2194}" // stable
                    };
                    let e_zone = if budget.in_warmup {
                        "warmup"
                    } else if budget.e_value > 20.0 {
                        "CRITICAL"
                    } else if budget.e_value > 5.0 {
                        "elevated"
                    } else if budget.e_value < 0.5 {
                        "healthy"
                    } else {
                        "normal"
                    };
                    let conformal_flag = budget
                        .conformal
                        .as_ref()
                        .map(|c| if c.risk { " RISK" } else { "" })
                        .unwrap_or("");
                    let rows: Vec<(&str, String, bool)> = vec![
                        ("Decision", format!("{:?}", budget.decision), degrading),
                        (
                            "Degrad",
                            format!(
                                "{:?} \u{2192} {:?}",
                                budget.degradation_before, budget.degradation_after
                            ),
                            degrading,
                        ),
                        (
                            "Frame/Bgt",
                            format!(
                                "{:.1}/{:.1}ms",
                                budget.frame_time_us / 1000.0,
                                budget.budget_us / 1000.0
                            ),
                            overrun,
                        ),
                        (
                            "PID",
                            format!("{:.2} {pid_arrow}", budget.pid_output),
                            budget.pid_output > 0.3,
                        ),
                        (
                            "E-value",
                            format!("{:.2} ({e_zone}){conformal_flag}", budget.e_value),
                            budget.e_value > 5.0,
                        ),
                        (
                            "Frames",
                            format!(
                                "{} (chg {}ago)",
                                budget.frames_observed, budget.frames_since_change
                            ),
                            false,
                        ),
                        (
                            "Warmup",
                            (if budget.in_warmup { "yes" } else { "no" }).to_string(),
                            budget.in_warmup,
                        ),
                    ];
                    for (label, value, is_warn) in &rows {
                        if y >= max_y {
                            break;
                        }
                        let row = Rect::new(inner.x, y, inner.width, 1);
                        let text = format!("{label:<9}  {value}");
                        let st = if *is_warn {
                            if degrading || budget.e_value > 20.0 {
                                error_style
                            } else {
                                warn_style
                            }
                        } else {
                            value_style
                        };
                        Paragraph::new(text).style(st).render(row, frame);
                        y += 1;
                    }
                } else {
                    let row = Rect::new(inner.x, y, inner.width, 1);
                    Paragraph::new("No budget evidence yet")
                        .style(muted_style)
                        .render(row, frame);
                }
            }
            InspectorTab::Timeline => {
                if self.evidence.timeline.is_empty() {
                    let row = Rect::new(inner.x, y, inner.width, 1);
                    Paragraph::new("No events yet")
                        .style(muted_style)
                        .render(row, frame);
                    y += 1;
                    if y < max_y {
                        let row2 = Rect::new(inner.x, y, inner.width, 1);
                        Paragraph::new("(waiting for adaptive decisions)")
                            .style(muted_style)
                            .render(row2, frame);
                    }
                } else {
                    // Header line
                    let hdr = format!(
                        "{} events (cap {})",
                        self.evidence.timeline.len(),
                        TIMELINE_CAPACITY
                    );
                    let row = Rect::new(inner.x, y, inner.width, 1);
                    Paragraph::new(hdr).style(muted_style).render(row, frame);
                    y += 1;
                    // Recent events, newest first, capped by topology
                    let max_events = topo.max_timeline_events as usize;
                    for event in self.evidence.timeline.recent().take(max_events) {
                        if y >= max_y {
                            break;
                        }
                        let row = Rect::new(inner.x, y, inner.width, 1);
                        let text = format!(
                            "#{:<4} {:<6} {}",
                            event.frame_idx,
                            event.kind.label(),
                            event.summary
                        );
                        Paragraph::new(text).style(value_style).render(row, frame);
                        y += 1;
                    }
                }
            }
        }

        // Footer hint — only shown when topology permits
        if topo.show_footer_hint {
            let hint = if self.cockpit.enabled {
                match self.cockpit.mode {
                    crate::ui::data::CockpitMode::Overlay => "^⇧I:close Tab:tab c:classic e:expand",
                    crate::ui::data::CockpitMode::Expanded => {
                        "^⇧I:close Tab:tab c:classic e:shrink"
                    }
                }
            } else {
                "^⇧I:close Tab:tab c:cockpit m:mode"
            };
            let hint_row = Rect::new(inner.x, max_y.saturating_sub(1), inner.width, 1);
            Paragraph::new(hint)
                .style(muted_style)
                .render(hint_row, frame);
        }
    }

    // NOTE: render_palette_overlay() removed — rendering now delegated to
    // ftui CommandPalette widget via Widget::render() in the view() method.

    // -- Help overlay rendering -----------------------------------------------

    /// Build the help content lines using ftui text types.
    fn build_help_lines(&self, styles: &StyleContext) -> Vec<ftui::text::Line> {
        let title_style = styles.style(style_system::STYLE_STATUS_INFO).bold();
        let key_style = styles.style(style_system::STYLE_KBD_KEY);
        let desc_style = styles.style(style_system::STYLE_KBD_DESC);
        let muted_style = styles.style(style_system::STYLE_TEXT_MUTED);

        let mut lines: Vec<ftui::text::Line> = Vec::new();

        // Helper closure: push a section title + plain items + blank line
        let add_section = |out: &mut Vec<ftui::text::Line>, title: &str, items: &[String]| {
            out.push(ftui::text::Line::from_spans(vec![
                ftui::text::Span::styled(title.to_string(), title_style),
            ]));
            for item in items {
                out.push(ftui::text::Line::from(format!("  {item}")));
            }
            out.push(ftui::text::Line::from(""));
        };

        // Helper closure: push a section with styled key-description pairs
        let add_section_kv =
            |out: &mut Vec<ftui::text::Line>, title: &str, items: &[(&str, &str)]| {
                out.push(ftui::text::Line::from_spans(vec![
                    ftui::text::Span::styled(title.to_string(), title_style),
                ]));
                // Find the longest key for alignment
                let max_key_w = items.iter().map(|(k, _)| k.len()).max().unwrap_or(0);
                for (key, desc) in items {
                    out.push(ftui::text::Line::from_spans(vec![
                        ftui::text::Span::styled(
                            format!("  {key:>width$}  ", width = max_key_w),
                            key_style,
                        ),
                        ftui::text::Span::styled(desc.to_string(), desc_style),
                    ]));
                }
                out.push(ftui::text::Line::from(""));
            };

        // Welcome
        lines.push(ftui::text::Line::from_spans(vec![
            ftui::text::Span::styled(
                "Welcome to CASS - Coding Agent Session Search".to_string(),
                title_style,
            ),
        ]));
        lines.push(ftui::text::Line::from(""));
        lines.push(ftui::text::Line::from("  Layout:"));
        let border_s = styles.style(style_system::STYLE_SPLIT_HANDLE);
        for row in [
            "  ┌─────────────────────────────────────────────────┐",
            "  │ [Surface Tabs + Global Hints]                    │",
            "  │ [Search Bar]         [Filter Chips]    [Status] │",
            "  ├────────────────┬────────────────────────────────┤",
            "  │                │                                │",
            "  │   Results      │       Detail Preview           │",
            "  │   (Left/↑↓)    │       (Tab to focus)           │",
            "  │                │                                │",
            "  ├────────────────┴────────────────────────────────┤",
            "  │ [Help Strip]                                    │",
            "  └─────────────────────────────────────────────────┘",
        ] {
            lines.push(ftui::text::Line::from_spans(vec![
                ftui::text::Span::styled(row.to_string(), border_s),
            ]));
        }
        lines.push(ftui::text::Line::from(""));

        add_section(
            &mut lines,
            "Data Locations",
            &[
                "Index & state: ~/.local/share/coding-agent-search/".into(),
                "  agent_search.db - Full-text search index".into(),
                "  tui_state.json - UI preferences | watch_state.json - Watch timestamps"
                    .into(),
                "  remotes/ - Synced session data from remote sources".into(),
                "Config: ~/.config/cass/sources.toml (remote sources)".into(),
                "Agents: Claude, Codex, Gemini, Cline, OpenCode, Amp, Cursor, ChatGPT, Aider, Pi-Agent, Factory"
                    .into(),
            ],
        );

        add_section(
            &mut lines,
            "Updates",
            &[
                "Checks GitHub releases hourly (offline-friendly, no auto-download)".into(),
                "When available: banner shows at top with U/N/S/Esc options".into(),
                "  U - Start upgrade flow (press U twice to confirm)".into(),
                "  N - Open release notes in browser (Shift+N)".into(),
                "  S - Skip this version permanently (Shift+S)".into(),
                "  Esc - Dismiss banner for this session".into(),
            ],
        );

        add_section(
            &mut lines,
            "Search",
            &[
                format!(
                    "type to live-search; {} focuses query; {} cycles history",
                    shortcuts::FOCUS_QUERY,
                    shortcuts::HISTORY_CYCLE
                ),
                "Enter in query bar submits immediately; Enter on selected result opens detail modal (Messages tab)".into(),
                "Wildcards: foo* (prefix), *foo (suffix), *foo* (contains)".into(),
                "Auto-fuzzy: searches with few results try *term* fallback".into(),
                format!("{} refresh index in background", shortcuts::REFRESH),
                format!(
                    "/ or {} detail-find in preview; n/N to jump session hits in context",
                    shortcuts::PANE_FILTER
                ),
            ],
        );

        add_section(
            &mut lines,
            "Surfaces",
            &[
                format!(
                    "{} jump directly to Analytics (global shell + metrics views)",
                    shortcuts::SURFACE_ANALYTICS
                ),
                format!(
                    "{} open Sources manager (sync, doctor, health)",
                    shortcuts::SOURCES
                ),
                "Esc from Analytics/Sources returns to the previous surface".into(),
                format!(
                    "{} opens the command palette for all surface commands",
                    shortcuts::PALETTE
                ),
            ],
        );

        add_section(
            &mut lines,
            "Filters",
            &[
                format!(
                    "{} agent | {} workspace | {} from | {} to | {} clear all",
                    shortcuts::FILTER_AGENT,
                    shortcuts::FILTER_WORKSPACE,
                    shortcuts::FILTER_DATE_FROM,
                    shortcuts::FILTER_DATE_TO,
                    shortcuts::CLEAR_FILTERS
                ),
                format!(
                    "{} clear agent filter | {} clear all filters | {} cycle time presets (24h/7d/30d/all)",
                    shortcuts::SCOPE_AGENT,
                    shortcuts::SCOPE_WORKSPACE,
                    shortcuts::CYCLE_TIME_PRESETS
                ),
                "Chips in search bar; Backspace removes last; Enter (query empty) edits last chip"
                    .into(),
            ],
        );

        add_section(
            &mut lines,
            "Sources (Multi-Machine)",
            &[
                "F11 cycle source filter: all → local → remote → all".into(),
                "Shift+F11 opens source filter menu (select specific sources)".into(),
                "Remote sessions show [source-name] in results list".into(),
                "Setup: cass sources setup (interactive wizard with SSH discovery)".into(),
                "Sync: rsync over SSH (delta transfers, additive-only for safety)".into(),
            ],
        );

        add_section(
            &mut lines,
            "Modes",
            &[
                format!(
                    "{} search mode: Lexical → Semantic → Hybrid",
                    shortcuts::SEARCH_MODE
                ),
                format!(
                    "{} match mode: standard (default) ⇄ prefix",
                    shortcuts::MATCH_MODE
                ),
                format!(
                    "{} ranking: recent → balanced → relevance → match-quality → date-newest → date-oldest",
                    shortcuts::RANKING
                ),
                format!(
                    "{} cycle themes (Dark → Light → Catppuccin → Dracula → Nord → High Contrast) | {} toggle border style",
                    shortcuts::THEME,
                    shortcuts::BORDERS
                ),
            ],
        );

        add_section(
            &mut lines,
            "Context",
            &[
                format!(
                    "{} cycles S/M/L/XL context window",
                    shortcuts::CONTEXT_WINDOW
                ),
                "Ctrl+Space: peek XL for current hit, tap again to restore".into(),
            ],
        );

        add_section_kv(
            &mut lines,
            "Navigation",
            &[
                ("Tab", "Focus results/detail"),
                ("Alt+h/j/k/l", "Directional navigation"),
                ("\u{2191}/\u{2193}", "Move selection"),
                ("Home/End", "Move query caret to start/end"),
                ("Alt+1..9", "Jump to pane index"),
                (
                    "Enter",
                    "Open detail (Messages tab default; if no selected hit, submit query)",
                ),
                ("Esc", "Close/back"),
                ("Tab (in detail)", "Cycle detail tabs"),
                ("{ / }", "Jump messages"),
                ("[ / ]", "Jump user messages"),
                ("Ctrl+Enter", "Queue item; Ctrl+O open all queued"),
            ],
        );

        add_section(
            &mut lines,
            "Actions",
            &[
                format!(
                    "{} opens detail modal (o=open, c=copy, p=path, s=snip, n=nano, Esc=close)",
                    shortcuts::DETAIL_OPEN
                ),
                format!(
                    "{} open hit in $EDITOR; {} copy snippet | {} copy path | {} copy content",
                    shortcuts::EDITOR,
                    shortcuts::COPY,
                    shortcuts::COPY_PATH,
                    shortcuts::COPY_CONTENT
                ),
                format!(
                    "{} toggle aggregate results stats bar",
                    shortcuts::STATS_BAR
                ),
                format!(
                    "{} detail-find within messages; n/N cycle session hits",
                    shortcuts::PANE_FILTER
                ),
                format!(
                    "{}/Alt+H toggle this help; {} quit (or back from detail)",
                    shortcuts::HELP,
                    shortcuts::QUIT
                ),
            ],
        );

        add_section_kv(
            &mut lines,
            "Density & Display",
            &[
                ("Alt+= / Alt+-", "Increase/decrease pane items"),
                ("Ctrl+D", "Cycle density mode (compact/cozy/spacious)"),
                ("F2", "Cycle theme preset"),
                ("Ctrl+B", "Toggle border style"),
            ],
        );

        add_section(
            &mut lines,
            "States",
            &[
                "UI state persists in tui_state.json (data dir).".into(),
                format!(
                    "{} reset UI state or launch with `cass tui --reset-state`",
                    shortcuts::RESET_STATE
                ),
            ],
        );

        // Pinned indicator
        if self.help_pinned {
            lines.push(ftui::text::Line::from_spans(vec![
                ftui::text::Span::styled("  [PINNED] ".to_string(), title_style),
                ftui::text::Span::styled("Press P to unpin, Esc to close".to_string(), muted_style),
            ]));
        } else {
            lines.push(ftui::text::Line::from_spans(vec![
                ftui::text::Span::styled("  P=pin  ↑/↓=scroll  Esc=close".to_string(), muted_style),
            ]));
        }

        lines
    }

    /// Render the help overlay as a centered popup with scrollable content.
    fn render_help_overlay(
        &self,
        frame: &mut super::ftui_adapter::Frame,
        area: Rect,
        styles: &StyleContext,
    ) {
        // Size: 70% width, 70% height (clamped to area)
        let popup_w = ((area.width as u32 * 70) / 100).min(area.width as u32) as u16;
        let popup_h = ((area.height as u32 * 70) / 100).min(area.height as u32) as u16;
        if popup_w < 20 || popup_h < 6 {
            return;
        }

        let popup_x = area.x + (area.width.saturating_sub(popup_w)) / 2;
        let popup_y = area.y + (area.height.saturating_sub(popup_h)) / 2;
        let popup_area = Rect::new(popup_x, popup_y, popup_w, popup_h);

        let bg_style = styles.style(style_system::STYLE_PANE_BASE);
        let border_style = styles.style(style_system::STYLE_PANE_FOCUSED);

        // Clear background
        Block::new().style(bg_style).render(popup_area, frame);

        let title = if self.help_pinned {
            "Quick Start & Shortcuts (pinned)"
        } else {
            "Quick Start & Shortcuts (F1 or Alt+H)"
        };
        let outer = Block::new()
            .borders(Borders::ALL)
            .border_type(BorderType::Rounded)
            .title(title)
            .title_alignment(Alignment::Left)
            .style(border_style);
        let inner = outer.inner(popup_area);
        outer.render(popup_area, frame);
        if inner.is_empty() {
            return;
        }

        let lines = self.build_help_lines(styles);
        let text = ftui::text::Text::from_lines(lines);
        Paragraph::new(text)
            .style(styles.style(style_system::STYLE_TEXT_PRIMARY))
            .wrap(ftui::text::WrapMode::Word)
            .scroll((self.help_scroll, 0))
            .render(inner, frame);
    }

    /// Render the source filter popup menu centered on screen.
    fn render_source_filter_menu_overlay(
        &self,
        frame: &mut super::ftui_adapter::Frame,
        area: Rect,
        styles: &StyleContext,
    ) {
        let items = self.source_menu_items();
        let menu_w = 44u16.min(area.width.saturating_sub(2));
        let menu_h = (items.len() as u16 + 4).min(area.height.saturating_sub(2));
        if menu_w == 0 || menu_h == 0 {
            return;
        }

        let menu_x = area.x + (area.width.saturating_sub(menu_w)) / 2;
        let menu_y = area.y + (area.height.saturating_sub(menu_h)) / 2;
        let menu_area = Rect::new(menu_x, menu_y, menu_w, menu_h);

        let background = styles.style(style_system::STYLE_PANE_BASE);
        let border_style = styles.style(style_system::STYLE_PANE_FOCUSED);
        let text_style = styles.style(style_system::STYLE_TEXT_PRIMARY);
        let muted_style = styles.style(style_system::STYLE_TEXT_MUTED);
        let selected_style = styles.style(style_system::STYLE_RESULT_ROW_SELECTED);

        Block::new().style(background).render(menu_area, frame);
        let outer = Block::new()
            .borders(Borders::ALL)
            .border_type(BorderType::Rounded)
            .title("Source Filter (Shift+F11)")
            .title_alignment(Alignment::Left)
            .style(border_style);
        let inner = outer.inner(menu_area);
        outer.render(menu_area, frame);
        if inner.is_empty() {
            return;
        }

        let selected = self
            .source_filter_menu_selection
            .min(items.len().saturating_sub(1));
        let visible = inner.height as usize;
        let start = selected.saturating_sub(visible.saturating_sub(1));

        for (row, (label, filter)) in items.iter().enumerate().skip(start).take(visible) {
            let y = inner.y + (row - start) as u16;
            let row_area = Rect::new(inner.x, y, inner.width, 1);
            let pointer = if row == selected { "> " } else { "  " };
            let active = if *filter == self.filters.source_filter {
                "* "
            } else {
                "  "
            };
            let line = format!("{pointer}{active}{label}");
            let style = if row == selected {
                selected_style
            } else if *filter == self.filters.source_filter {
                muted_style
            } else {
                text_style
            };
            Paragraph::new(&*line).style(style).render(row_area, frame);
        }
    }

    /// Render the semantic model consent dialog overlay.
    fn render_consent_overlay(
        &self,
        frame: &mut super::ftui_adapter::Frame,
        area: Rect,
        styles: &StyleContext,
    ) {
        let dialog_w = 68u16.min(area.width.saturating_sub(2));
        let dialog_h = 9u16.min(area.height.saturating_sub(2));
        if dialog_w < 28 || dialog_h < 6 {
            return;
        }

        let dialog_x = area.x + (area.width.saturating_sub(dialog_w)) / 2;
        let dialog_y = area.y + (area.height.saturating_sub(dialog_h)) / 2;
        let dialog_area = Rect::new(dialog_x, dialog_y, dialog_w, dialog_h);

        let bg_style = styles.style(style_system::STYLE_PANE_BASE);
        let border_style = styles.style(style_system::STYLE_PANE_FOCUSED);
        let text_style = styles.style(style_system::STYLE_TEXT_PRIMARY);
        let muted_style = styles.style(style_system::STYLE_TEXT_MUTED);
        let key_style = styles.style(style_system::STYLE_KBD_KEY);

        Block::new().style(bg_style).render(dialog_area, frame);
        let outer = Block::new()
            .borders(Borders::ALL)
            .border_type(BorderType::Rounded)
            .title("Enable semantic search?")
            .title_alignment(Alignment::Left)
            .style(border_style);
        let inner = outer.inner(dialog_area);
        outer.render(dialog_area, frame);
        if inner.is_empty() {
            return;
        }

        let lines = vec![
            ftui::text::Line::from_spans(vec![ftui::text::Span::styled(
                "Semantic/Hybrid mode needs a local embedding model download.".to_string(),
                text_style,
            )]),
            ftui::text::Line::from_spans(vec![
                ftui::text::Span::styled("[D]".to_string(), key_style.bold()),
                ftui::text::Span::styled(" Download model (recommended)".to_string(), text_style),
            ]),
            ftui::text::Line::from_spans(vec![
                ftui::text::Span::styled("[H]".to_string(), key_style.bold()),
                ftui::text::Span::styled(
                    " Use hash fallback (no download)".to_string(),
                    text_style,
                ),
            ]),
            ftui::text::Line::from_spans(vec![
                ftui::text::Span::styled("[Esc]".to_string(), key_style.bold()),
                ftui::text::Span::styled(" Cancel for now".to_string(), muted_style),
            ]),
        ];
        Paragraph::new(ftui::text::Text::from_lines(lines))
            .style(text_style)
            .wrap(ftui::text::WrapMode::Word)
            .render(inner, frame);
    }

    /// Render the saved views manager popup centered on screen.
    fn render_saved_views_overlay(
        &self,
        frame: &mut super::ftui_adapter::Frame,
        area: Rect,
        styles: &StyleContext,
    ) {
        let modal_w = 72u16.min(area.width.saturating_sub(2));
        let modal_h = 18u16.min(area.height.saturating_sub(2));
        if modal_w == 0 || modal_h == 0 {
            self.last_saved_view_row_areas.borrow_mut().clear();
            return;
        }

        let modal_x = area.x + (area.width.saturating_sub(modal_w)) / 2;
        let modal_y = area.y + (area.height.saturating_sub(modal_h)) / 2;
        let modal_area = Rect::new(modal_x, modal_y, modal_w, modal_h);

        let bg_style = styles.style(style_system::STYLE_PANE_BASE);
        let border_style = styles.style(style_system::STYLE_PANE_FOCUSED);
        let text_style = styles.style(style_system::STYLE_TEXT_PRIMARY);
        let muted_style = styles.style(style_system::STYLE_TEXT_MUTED);
        let selected_style = styles.style(style_system::STYLE_RESULT_ROW_SELECTED);

        Block::new().style(bg_style).render(modal_area, frame);
        let title = format!("{SAVED_VIEWS_MODAL_TITLE}({})", self.saved_views.len());
        let outer = Block::new()
            .borders(Borders::ALL)
            .border_type(BorderType::Rounded)
            .title(&title)
            .title_alignment(Alignment::Left)
            .style(border_style);
        let inner = outer.inner(modal_area);
        outer.render(modal_area, frame);
        if inner.is_empty() {
            self.last_saved_view_row_areas.borrow_mut().clear();
            return;
        }

        let mut rows = self.saved_views.clone();
        rows.sort_by_key(|v| v.slot);
        self.last_saved_view_row_areas.borrow_mut().clear();

        let footer_h = if self.saved_view_rename_mode { 2 } else { 1 };
        let list_h = inner.height.saturating_sub(footer_h).max(1);
        let list_area = Rect::new(inner.x, inner.y, inner.width, list_h);
        let footer_area = Rect::new(inner.x, inner.y + list_h, inner.width, footer_h);

        if rows.is_empty() {
            Paragraph::new(
                "No saved views. Use Ctrl+1..9 to save the current filters into a slot.",
            )
            .style(muted_style)
            .render(list_area, frame);
        } else {
            let selected = self.saved_views_selection.min(rows.len().saturating_sub(1));
            let drag_hover = self.saved_view_drag.map(|d| d.hover_idx);
            let visible = list_area.height as usize;
            let start = selected.saturating_sub(visible.saturating_sub(1));
            for (row, view) in rows.iter().enumerate().skip(start).take(visible) {
                let y = list_area.y + (row - start) as u16;
                let row_area = Rect::new(list_area.x, y, list_area.width, 1);
                self.last_saved_view_row_areas
                    .borrow_mut()
                    .push((row_area, row));
                let marker = if row == selected { "> " } else { "  " };
                let label = view
                    .label
                    .as_deref()
                    .filter(|s| !s.trim().is_empty())
                    .map(str::to_string)
                    .unwrap_or_else(|| format!("Slot {}", view.slot));
                let line = format!(
                    "{marker}[{}] {}  a:{} w:{}  src:{}",
                    view.slot,
                    label,
                    view.agents.len(),
                    view.workspaces.len(),
                    view.source_filter
                );
                let style = if row == selected || drag_hover == Some(row) {
                    selected_style
                } else {
                    text_style
                };
                Paragraph::new(&*line).style(style).render(row_area, frame);
            }
        }

        if self.saved_view_rename_mode {
            let prompt = format!(
                "Rename slot: {}{}",
                self.saved_view_rename_buffer,
                if self.saved_view_rename_buffer.is_empty() {
                    ""
                } else {
                    " "
                }
            );
            Paragraph::new(&*prompt).style(text_style).render(
                Rect::new(footer_area.x, footer_area.y, footer_area.width, 1),
                frame,
            );
            Paragraph::new("Enter=save · Esc=cancel")
                .style(muted_style)
                .render(
                    Rect::new(
                        footer_area.x,
                        footer_area.y + 1,
                        footer_area.width,
                        footer_area.height.saturating_sub(1),
                    ),
                    frame,
                );
        } else {
            Paragraph::new(
                "Enter=load · drag=move · R=rename · D=delete · C=clear all · Esc=close",
            )
            .style(muted_style)
            .render(footer_area, frame);
        }
    }

    /// Render the export modal overlay centered on screen.
    fn render_export_overlay(
        &self,
        frame: &mut super::ftui_adapter::Frame,
        area: Rect,
        styles: &StyleContext,
    ) {
        let state = match self.export_modal_state.as_ref() {
            Some(s) => s,
            None => return,
        };

        let text_style = styles.style(style_system::STYLE_TEXT_PRIMARY);
        let muted_style = styles.style(style_system::STYLE_TEXT_MUTED);
        let bg_style = styles.style(style_system::STYLE_PANE_BASE);
        let border_style = styles.style(style_system::STYLE_PANE_FOCUSED);
        let accent_style = styles.style(style_system::STYLE_STATUS_INFO);
        let success_style = styles.style(style_system::STYLE_STATUS_SUCCESS);
        let error_style = styles.style(style_system::STYLE_STATUS_ERROR);
        let selected_style = styles.style(style_system::STYLE_RESULT_ROW_SELECTED);

        // Modal dimensions: 70x22, clamped to terminal size.
        let modal_w = 70u16.min(area.width.saturating_sub(4));
        let modal_h = 22u16.min(area.height.saturating_sub(2));
        let modal_x = area.x + (area.width.saturating_sub(modal_w)) / 2;
        let modal_y = area.y + (area.height.saturating_sub(modal_h)) / 2;
        let modal_area = Rect::new(modal_x, modal_y, modal_w, modal_h);

        // Clear background.
        Block::new().style(bg_style).render(modal_area, frame);

        // Outer border.
        let outer = Block::new()
            .borders(Borders::ALL)
            .border_type(BorderType::Rounded)
            .title("Export Session as HTML (Ctrl+E)")
            .title_alignment(Alignment::Left)
            .style(border_style);
        let inner = outer.inner(modal_area);
        outer.render(modal_area, frame);

        if inner.is_empty() {
            return;
        }

        // Vertical layout: session card (3) + gap (1) + options (6) + gap (1) + preview (3) + flex + footer (1).
        let mut y = inner.y;
        let w = inner.width;
        let x = inner.x;

        // ── Session info card ──────────────────────────────────────
        if y + 3 <= inner.y + inner.height {
            let badge = format!(" {} ", state.agent_name);
            let location = format!("  {} | {}", state.workspace, state.timestamp);
            let badge_line = format!("{badge}{location}");
            Paragraph::new(&*badge_line)
                .style(accent_style)
                .render(Rect::new(x, y, w, 1), frame);
            y += 1;

            let title_text = &state.title_preview;
            Paragraph::new(title_text.as_str())
                .style(text_style)
                .render(Rect::new(x, y, w, 1), frame);
            y += 1;

            let stats = format!("{} messages", state.message_count);
            Paragraph::new(&*stats)
                .style(muted_style)
                .render(Rect::new(x, y, w, 1), frame);
            y += 1;
        }

        // Gap.
        y += 1;

        // ── Options section ────────────────────────────────────────
        // Separator.
        if y < inner.y + inner.height {
            let sep = "\u{2500}".repeat(w as usize);
            Paragraph::new(&*sep)
                .style(muted_style)
                .render(Rect::new(x, y, w, 1), frame);
            y += 1;
        }

        // Output directory.
        if y < inner.y + inner.height {
            let focused = state.focused == ExportField::OutputDir;
            let editing = state.output_dir_editing;
            let display_path = if editing {
                state.output_dir_buffer.as_str()
            } else {
                // Use a short representation
                state.output_dir.to_str().unwrap_or(".")
            };
            let max_len = w.saturating_sub(14) as usize;
            let truncated = if display_path.len() > max_len && max_len > 6 {
                let tail = &display_path[display_path.len().saturating_sub(max_len - 3)..];
                format!("...{tail}")
            } else {
                display_path.to_string()
            };
            let cursor = if editing { "_" } else { "" };
            let hint = if focused && !editing {
                " (Enter)"
            } else if editing {
                " (Enter=ok)"
            } else {
                ""
            };
            let line = format!(" Output: {truncated}{cursor}{hint}");
            let row_style = if focused { accent_style } else { text_style };
            Paragraph::new(&*line)
                .style(row_style)
                .render(Rect::new(x, y, w, 1), frame);
            y += 1;
        }

        // Checkboxes: include_tools, encrypt, password (conditional), show_timestamps.
        let checkboxes: &[(ExportField, &str, bool)] = &[
            (
                ExportField::IncludeTools,
                "Include tool calls",
                state.include_tools,
            ),
            (ExportField::Encrypt, "Password protection", state.encrypt),
        ];
        for &(field, label, checked) in checkboxes {
            if y >= inner.y + inner.height {
                break;
            }
            let mark = if checked { "[x]" } else { "[ ]" };
            let focused = state.focused == field;
            let row_style = if focused { accent_style } else { text_style };
            let line = format!(" {mark} {label}");
            Paragraph::new(&*line)
                .style(row_style)
                .render(Rect::new(x, y, w, 1), frame);
            y += 1;
        }

        // Password row (only if encrypt is enabled).
        if state.encrypt && y < inner.y + inner.height {
            let focused = state.focused == ExportField::Password;
            let display = if state.password_visible {
                state.password.clone()
            } else {
                "\u{2022}".repeat(state.password.len())
            };
            let cursor = if focused { "_" } else { "" };
            let vis_hint = if state.password_visible {
                "(Ctrl+H hide)"
            } else {
                "(Ctrl+H show)"
            };
            let line = format!("     Password: {display}{cursor} {vis_hint}");
            let row_style = if focused { accent_style } else { text_style };
            Paragraph::new(&*line)
                .style(row_style)
                .render(Rect::new(x, y, w, 1), frame);
            y += 1;
        }

        // Show timestamps checkbox.
        if y < inner.y + inner.height {
            let mark = if state.show_timestamps { "[x]" } else { "[ ]" };
            let focused = state.focused == ExportField::ShowTimestamps;
            let row_style = if focused { accent_style } else { text_style };
            let line = format!(" {mark} Show timestamps");
            Paragraph::new(&*line)
                .style(row_style)
                .render(Rect::new(x, y, w, 1), frame);
            y += 1;
        }

        // Gap.
        y += 1;

        // ── Preview section ────────────────────────────────────────
        if y < inner.y + inner.height {
            let sep2 = "\u{2500}".repeat(w as usize);
            Paragraph::new(&*sep2)
                .style(muted_style)
                .render(Rect::new(x, y, w, 1), frame);
            y += 1;
        }

        if y < inner.y + inner.height {
            Paragraph::new(state.filename_preview.as_str())
                .style(text_style)
                .render(Rect::new(x, y, w, 1), frame);
            y += 1;
        }

        if y < inner.y + inner.height {
            let est_kb = (state.message_count * 2 + 15).max(20);
            let size_str = if est_kb > 1024 {
                format!("~{:.1}MB", est_kb as f64 / 1024.0)
            } else {
                format!("~{est_kb}KB")
            };
            let mut features = vec!["Theme presets", "Print-friendly"];
            if state.encrypt {
                features.push("Encrypted");
            }
            let preview = format!(
                "{} msgs | {} | {}",
                state.message_count,
                size_str,
                features.join(" | ")
            );
            Paragraph::new(&*preview)
                .style(muted_style)
                .render(Rect::new(x, y, w, 1), frame);
            y += 1;
        }

        // Progress line.
        if y < inner.y + inner.height {
            let (progress_text, pstyle) = match &state.progress {
                ExportProgress::Idle => (String::new(), muted_style),
                ExportProgress::Preparing => ("Preparing export...".to_string(), accent_style),
                ExportProgress::Encrypting => ("Encrypting content...".to_string(), accent_style),
                ExportProgress::Writing => ("Writing HTML file...".to_string(), accent_style),
                ExportProgress::Complete(path) => {
                    let name = path
                        .file_name()
                        .map(|n| n.to_string_lossy().to_string())
                        .unwrap_or_else(|| path.display().to_string());
                    (format!("Exported: {name}"), success_style)
                }
                ExportProgress::Error(msg) => (format!("Error: {msg}"), error_style),
            };
            if !progress_text.is_empty() {
                Paragraph::new(&*progress_text)
                    .style(pstyle)
                    .render(Rect::new(x, y, w, 1), frame);
            }
        }

        // ── Footer (keyboard hints) ──────────────────────────────
        let footer_y = modal_area.y + modal_area.height - 2;
        if footer_y > y {
            let can_export = state.can_export();
            let export_label = if can_export && state.focused == ExportField::ExportButton {
                " [EXPORT] "
            } else if can_export {
                " Enter=Export "
            } else {
                " (set password) "
            };
            let btn_style = if can_export && state.focused == ExportField::ExportButton {
                selected_style
            } else if can_export {
                accent_style
            } else {
                muted_style
            };

            // Build hint string with consistent spacing.
            let hints = format!(" Tab=Navigate  Space=Toggle {export_label} Esc=Cancel");
            Paragraph::new(&*hints)
                .style(btn_style)
                .render(Rect::new(x, footer_y, w, 1), frame);
        }
    }

    fn analytics_filter_count(&self) -> usize {
        let f = &self.analytics_filters;
        let mut count = 0;
        if f.since_ms.is_some() || f.until_ms.is_some() {
            count += 1;
        }
        if !f.agents.is_empty() {
            count += 1;
        }
        if !f.workspaces.is_empty() {
            count += 1;
        }
        if !matches!(f.source_filter, SourceFilter::All) {
            count += 1;
        }
        count
    }

    fn analytics_tabs_line(
        &self,
        show_tab_bar: bool,
        active_style: ftui::Style,
        inactive_style: ftui::Style,
        meta_style: ftui::Style,
    ) -> ftui::text::Line {
        let mut spans: Vec<ftui::text::Span> = Vec::new();
        if show_tab_bar {
            for (idx, view) in AnalyticsView::all().iter().enumerate() {
                if idx > 0 {
                    spans.push(ftui::text::Span::styled(" ", meta_style));
                }
                if *view == self.analytics_view {
                    spans.push(ftui::text::Span::styled(
                        format!("[{}]", view.label()),
                        active_style,
                    ));
                } else {
                    spans.push(ftui::text::Span::styled(
                        format!(" {} ", view.label()),
                        inactive_style,
                    ));
                }
            }
        } else {
            spans.push(ftui::text::Span::styled("view ", meta_style));
            spans.push(ftui::text::Span::styled(
                self.analytics_view.label(),
                active_style,
            ));
            spans.push(ftui::text::Span::styled(
                "  \u{2190}/\u{2192} switch",
                meta_style,
            ));
        }
        ftui::text::Line::from_spans(spans)
    }

    fn analytics_metrics_line(
        &self,
        data: &super::analytics_charts::AnalyticsChartData,
        width: u16,
        value_style: ftui::Style,
        meta_style: ftui::Style,
    ) -> ftui::text::Line {
        let mut spans: Vec<ftui::text::Span> = Vec::new();
        let push_metric = |spans: &mut Vec<ftui::text::Span>,
                           label: &str,
                           value: String,
                           sep_style: ftui::Style| {
            if !spans.is_empty() {
                spans.push(ftui::text::Span::styled(" \u{2502} ", sep_style));
            }
            spans.push(ftui::text::Span::styled(format!("{label}:"), sep_style));
            spans.push(ftui::text::Span::styled(value, value_style));
        };

        push_metric(
            &mut spans,
            "msgs",
            compact_i64_for_analytics(data.total_messages),
            meta_style,
        );
        push_metric(
            &mut spans,
            "api",
            compact_i64_for_analytics(data.total_api_tokens),
            meta_style,
        );
        push_metric(
            &mut spans,
            "tools",
            compact_i64_for_analytics(data.total_tool_calls),
            meta_style,
        );
        push_metric(
            &mut spans,
            "cov",
            format!("{:.0}%", data.coverage_pct),
            meta_style,
        );
        let filter_count = self.analytics_filter_count();
        if filter_count > 0 {
            push_metric(&mut spans, "filters", filter_count.to_string(), meta_style);
        }

        if width >= 72 {
            let spark_width = (width as usize / 5).clamp(8, 28);
            let values: Vec<f64> = if data.daily_tokens.is_empty() {
                data.daily_messages.iter().map(|(_, v)| *v).collect()
            } else {
                data.daily_tokens.iter().map(|(_, v)| *v).collect()
            };
            let spark = sparkline_from_values(&values, spark_width);
            if !spark.is_empty() {
                spans.push(ftui::text::Span::styled(" \u{2502} trend:", meta_style));
                spans.push(ftui::text::Span::styled(spark, value_style));
            }
        }

        ftui::text::Line::from_spans(spans)
    }

    /// Build a one-line summary of active analytics filters for the header bar.
    fn analytics_filter_summary(&self) -> String {
        let f = &self.analytics_filters;
        let mut parts: Vec<String> = Vec::new();

        // Time range
        match (f.since_ms, f.until_ms) {
            (Some(s), Some(u)) => parts.push(format!("time:{s}..{u}")),
            (Some(s), None) => parts.push(format!("since:{s}")),
            (None, Some(u)) => parts.push(format!("until:{u}")),
            (None, None) => {}
        }

        // Agent filter
        if !f.agents.is_empty() {
            let mut agents: Vec<&str> = f.agents.iter().map(|s| s.as_str()).collect();
            agents.sort();
            parts.push(format!("agents:{}", agents.join(",")));
        }

        // Workspace filter
        if !f.workspaces.is_empty() {
            let mut ws: Vec<&str> = f.workspaces.iter().map(|s| s.as_str()).collect();
            ws.sort();
            parts.push(format!("ws:{}", ws.join(",")));
        }

        // Source filter
        match f.source_filter {
            SourceFilter::All => {}
            SourceFilter::Local => parts.push("source:local".into()),
            SourceFilter::Remote => parts.push("source:remote".into()),
            SourceFilter::SourceId(ref id) => parts.push(format!("source:{id}")),
        }

        if parts.is_empty() {
            "Filters: none".to_string()
        } else {
            format!("Filters: {}", parts.join(" | "))
        }
    }

    /// Load sources configuration + sync status into `SourcesViewState`.
    #[cfg(not(test))]
    fn load_sources_view(&mut self) {
        use crate::sources::{SourcesConfig, SyncStatus};

        let config = SourcesConfig::load().unwrap_or_default();
        let config_path = SourcesConfig::config_path()
            .map(|p| p.display().to_string())
            .unwrap_or_else(|_| "unknown".into());

        let data_dir = self.data_dir.clone();
        let sync_status = SyncStatus::load(&data_dir).unwrap_or_default();

        let mut items = Vec::new();

        // Always show the "local" pseudo-source first.
        items.push(SourcesViewItem {
            name: "local".into(),
            kind: crate::sources::SourceKind::Local,
            host: None,
            schedule: "always".into(),
            path_count: 0,
            last_sync: None,
            last_result: "n/a".into(),
            files_synced: 0,
            bytes_transferred: 0,
            busy: false,
            doctor_summary: None,
            error: None,
        });

        for src in &config.sources {
            let info = sync_status.sources.get(&src.name);
            let last_result_str = match info.map(|i| &i.last_result) {
                Some(crate::sources::SyncResult::Success) => "success",
                Some(crate::sources::SyncResult::PartialFailure(_)) => "partial",
                Some(crate::sources::SyncResult::Failed(_)) => "failed",
                Some(crate::sources::SyncResult::Skipped) | None => "never",
            };
            items.push(SourcesViewItem {
                name: src.name.clone(),
                kind: src.source_type,
                host: src.host.clone(),
                schedule: format!("{:?}", src.sync_schedule).to_lowercase(),
                path_count: src.paths.len(),
                last_sync: info.and_then(|i| i.last_sync),
                last_result: last_result_str.into(),
                files_synced: info.map(|i| i.files_synced).unwrap_or(0),
                bytes_transferred: info.map(|i| i.bytes_transferred).unwrap_or(0),
                busy: false,
                doctor_summary: None,
                error: None,
            });
        }

        let count = items.len();
        self.sources_view = SourcesViewState {
            items,
            selected: self.sources_view.selected.min(count.saturating_sub(1)),
            scroll: 0,
            busy: false,
            config_path,
            status: format!("{count} source(s) configured"),
        };
    }

    /// Number of selectable items in the current analytics subview.
    fn analytics_selectable_count(&self) -> usize {
        let data = match &self.analytics_cache {
            Some(d) => d,
            None => return 0,
        };
        match self.analytics_view {
            AnalyticsView::Explorer => data.daily_tokens.len(),
            AnalyticsView::Heatmap => data.heatmap_days.len(),
            AnalyticsView::Breakdowns => {
                super::analytics_charts::breakdown_rows(data, self.breakdown_tab)
            }
            AnalyticsView::Tools => super::analytics_charts::tools_row_count(data),
            AnalyticsView::Plans => data.agent_plan_messages.len(),
            AnalyticsView::Coverage => super::analytics_charts::coverage_row_count(data),
            // Dashboard has no selectable rows.
            AnalyticsView::Dashboard => 0,
        }
    }

    /// Build a [`DrilldownContext`] from the current analytics view and selection.
    ///
    /// Returns `None` for views without selectable items or when the cache is empty.
    fn build_drilldown_context(&self) -> Option<DrilldownContext> {
        let data = self.analytics_cache.as_ref()?;
        let idx = self.analytics_selection;

        // Inherit global analytics filters as the base.
        let base_since = self.analytics_filters.since_ms;
        let base_until = self.analytics_filters.until_ms;

        match self.analytics_view {
            AnalyticsView::Explorer => {
                // Drill into a specific day bucket.
                let (label, _) = data.daily_tokens.get(idx)?;
                let (since, until) = day_label_to_epoch_range(label)?;
                Some(DrilldownContext {
                    since_ms: Some(since),
                    until_ms: Some(until),
                    agent: None,
                    workspace: None,
                    source_filter: None,
                    model: None,
                })
            }
            AnalyticsView::Heatmap => {
                // Drill into a specific heatmap day.
                let (label, _) = data.heatmap_days.get(idx)?;
                let (since, until) = day_label_to_epoch_range(label)?;
                Some(DrilldownContext {
                    since_ms: Some(since),
                    until_ms: Some(until),
                    agent: None,
                    workspace: None,
                    source_filter: None,
                    model: None,
                })
            }
            AnalyticsView::Breakdowns => {
                // Drill into the selected dimension based on active tab.
                match self.breakdown_tab {
                    BreakdownTab::Agent => {
                        let (agent, _) = data.agent_tokens.get(idx)?;
                        Some(DrilldownContext {
                            since_ms: base_since,
                            until_ms: base_until,
                            agent: Some(agent.clone()),
                            workspace: None,
                            source_filter: None,
                            model: None,
                        })
                    }
                    BreakdownTab::Workspace => {
                        let (workspace, _) = data.workspace_tokens.get(idx)?;
                        Some(DrilldownContext {
                            since_ms: base_since,
                            until_ms: base_until,
                            agent: None,
                            workspace: Some(workspace.clone()),
                            source_filter: None,
                            model: None,
                        })
                    }
                    BreakdownTab::Source => {
                        let (source_id, _) = data.source_tokens.get(idx)?;
                        Some(DrilldownContext {
                            since_ms: base_since,
                            until_ms: base_until,
                            agent: None,
                            workspace: None,
                            source_filter: Some(SourceFilter::SourceId(source_id.clone())),
                            model: None,
                        })
                    }
                    BreakdownTab::Model => {
                        let (model, _) = data.model_tokens.get(idx)?;
                        Some(DrilldownContext {
                            since_ms: base_since,
                            until_ms: base_until,
                            agent: None,
                            workspace: None,
                            source_filter: None,
                            model: Some(model.clone()),
                        })
                    }
                }
            }
            AnalyticsView::Tools => {
                // Drill into a specific agent (tool rows are keyed by agent).
                let row = data.tool_rows.get(idx)?;
                Some(DrilldownContext {
                    since_ms: base_since,
                    until_ms: base_until,
                    agent: Some(row.key.clone()),
                    workspace: None,
                    source_filter: None,
                    model: None,
                })
            }
            AnalyticsView::Plans => {
                // Drill into agent's plan-heavy sessions.
                let (agent, _) = data.agent_plan_messages.get(idx)?;
                Some(DrilldownContext {
                    since_ms: base_since,
                    until_ms: base_until,
                    agent: Some(agent.clone()),
                    workspace: None,
                    source_filter: None,
                    model: None,
                })
            }
            AnalyticsView::Coverage => {
                // Drill into a specific agent's sessions.
                let (agent, _) = data.agent_tokens.get(idx)?;
                Some(DrilldownContext {
                    since_ms: base_since,
                    until_ms: base_until,
                    agent: Some(agent.clone()),
                    workspace: None,
                    source_filter: None,
                    model: None,
                })
            }
            // Dashboard doesn't support drilldown.
            AnalyticsView::Dashboard => None,
        }
    }
}

/// Convert a day label (e.g. "2026-02-06") to an epoch-ms range `[start, end)`.
///
/// Returns `None` if the label doesn't parse as a valid date.
fn day_label_to_epoch_range(label: &str) -> Option<(i64, i64)> {
    // Parse YYYY-MM-DD (the format produced by bucketing::day_id_to_date).
    let parts: Vec<&str> = label.split('-').collect();
    if parts.len() != 3 {
        return None;
    }
    let year: i32 = parts[0].parse().ok()?;
    let month: u32 = parts[1].parse().ok()?;
    let day: u32 = parts[2].parse().ok()?;
    if !(1..=12).contains(&month) {
        return None;
    }
    fn is_leap_year(y: i32) -> bool {
        (y % 4 == 0 && y % 100 != 0) || (y % 400 == 0)
    }
    fn days_in_month(y: i32, m: u32) -> u32 {
        match m {
            1 | 3 | 5 | 7 | 8 | 10 | 12 => 31,
            4 | 6 | 9 | 11 => 30,
            2 if is_leap_year(y) => 29,
            2 => 28,
            _ => 0,
        }
    }
    if day == 0 || day > days_in_month(year, month) {
        return None;
    }

    // Compute days since Unix epoch using a simple Gregorian calendar.
    // We use a well-known algorithm to convert y/m/d → days since epoch.
    fn days_from_civil(y: i32, m: u32, d: u32) -> i64 {
        let y = y as i64;
        let m = m as i64;
        let d = d as i64;
        let (y2, m2) = if m <= 2 { (y - 1, m + 9) } else { (y, m - 3) };
        let era = if y2 >= 0 { y2 / 400 } else { (y2 - 399) / 400 };
        let yoe = y2 - era * 400;
        let doy = (153 * m2 + 2) / 5 + d - 1;
        let doe = yoe * 365 + yoe / 4 - yoe / 100 + doy;
        era * 146097 + doe - 719468
    }

    let start_days = days_from_civil(year, month, day);
    let start_ms = start_days * 86_400_000;
    let end_ms = start_ms + 86_400_000;
    Some((start_ms, end_ms))
}

// =========================================================================
// CassMsg — every event the TUI can process
// =========================================================================

/// Messages that drive the cass TUI state machine.
///
/// Every user action, system event, and async completion maps to exactly
/// one variant.  The `CassApp::update()` function pattern-matches on
/// these to produce pure state transitions + side-effect commands.
#[derive(Debug)]
pub enum CassMsg {
    // -- Keyboard / input -------------------------------------------------
    /// Raw terminal event (key, mouse, resize, paste, tick).
    /// The update() function converts this into more specific messages.
    TerminalEvent(TerminalEventPayload),

    // -- Query & search ---------------------------------------------------
    /// User typed or edited the query string.
    QueryChanged(String),
    /// User cleared the entire query line (Ctrl+U).
    QueryCleared,
    /// User deleted word-backward (Ctrl+W).
    QueryWordDeleted,
    /// User pressed Enter to submit the query (force immediate search, push to history).
    QuerySubmitted,
    /// Search execution requested (Enter or debounce expired).
    SearchRequested,
    /// Load the next page of results for the current query (infinite scroll).
    SearchMoreRequested,
    /// Async search completed with results.
    SearchCompleted {
        /// Monotonic generation id so stale async completions can be ignored.
        generation: u64,
        hits: Vec<SearchHit>,
        elapsed_ms: u128,
        suggestions: Vec<QuerySuggestion>,
        wildcard_fallback: bool,
        /// When true, append hits to the existing result set instead of replacing it.
        append: bool,
    },
    /// Search failed with an error message.
    SearchFailed { generation: u64, error: String },
    /// Move cursor within the query string (Left/Right arrow keys).
    CursorMoved { delta: i32 },
    /// Jump cursor to start or end of query (Home/End keys).
    CursorJumped { to_end: bool },
    /// Toggle the wildcard fallback indicator (Ctrl+F).
    WildcardFallbackToggled,

    // -- Filters ----------------------------------------------------------
    /// Agent filter added or changed.
    FilterAgentSet(HashSet<String>),
    /// Workspace filter added or changed.
    FilterWorkspaceSet(HashSet<String>),
    /// Time range filter set.
    FilterTimeSet { from: Option<i64>, to: Option<i64> },
    /// Source filter changed.
    FilterSourceSet(SourceFilter),
    /// All filters cleared.
    FiltersClearAll,
    /// Cycle time filter preset (All -> Today -> Week -> Month -> All).
    TimePresetCycled,
    /// Cycle source filter (All -> Local -> Remote -> All).
    SourceFilterCycled,

    // -- Mode cycling -----------------------------------------------------
    /// Cycle search mode (Lexical -> Semantic -> Hybrid).
    SearchModeCycled,
    /// Cycle match mode (Standard <-> Prefix).
    MatchModeCycled,
    /// Cycle ranking mode through all 6 variants.
    RankingModeCycled,
    /// Cycle context window (S -> M -> L -> XL).
    ContextWindowCycled,
    /// Cycle density mode (Compact -> Cozy -> Spacious).
    DensityModeCycled,
    /// Cycle through all built-in theme presets.
    ThemeToggled,

    // -- Navigation -------------------------------------------------------
    /// Move selection in the results pane.
    SelectionMoved { delta: i32 },
    /// Jump to first or last result.
    SelectionJumped { to_end: bool },
    /// Change active pane.
    ActivePaneChanged { index: usize },
    /// Toggle focus between Results and Detail.
    FocusToggled,
    /// Move focus in a specific direction.
    FocusDirectional { direction: FocusDirection },
    /// Scroll the detail pane.
    DetailScrolled { delta: i32 },
    /// Page-level scroll.
    PageScrolled { delta: i32 },

    /// Undo the last query/filter change (Ctrl+Z).
    Undo,
    /// Redo the last undone change (Ctrl+Y).
    Redo,

    /// Cycle the results grouping mode (Agent → Conversation → Workspace → Flat).
    GroupingCycled,
    /// Jump to the next/previous day boundary in results.
    TimelineJumped { forward: bool },

    // -- Detail view ------------------------------------------------------
    /// Open the detail modal for the currently selected result.
    DetailOpened,
    /// Load full conversation detail for the selected source path.
    DetailLoadRequested { source_path: String },
    /// Close the detail modal.
    DetailClosed,
    /// Switch detail tab.
    DetailTabChanged(DetailTab),
    /// Toggle text wrap in detail view.
    DetailWrapToggled,
    /// Enter/exit inline find mode in detail.
    DetailFindToggled,
    /// Update the detail find query.
    DetailFindQueryChanged(String),
    /// Move to next/previous find match.
    DetailFindNavigated { forward: bool },
    /// Move to next/previous session search hit in contextual Messages view.
    DetailSessionHitNavigated { forward: bool },
    /// Toggle JSON viewer tab (syntax-highlighted tree view).
    ToggleJsonView,
    /// Toggle collapse for a tool/system message at the given index.
    ToolCollapseToggled(usize),
    /// Expand all collapsed tool/system messages.
    ToolExpandAll,
    /// Collapse all tool/system messages.
    ToolCollapseAll,
    /// Jump to the next/previous message in the detail view.
    DetailMessageJumped { forward: bool, user_only: bool },
    /// Toggle the aggregate stats bar in the results pane (Ctrl+S).
    StatsBarToggled,

    // -- Multi-select & bulk actions --------------------------------------
    /// Toggle select on the current item.
    SelectionToggled,
    /// Select or deselect all items in the current pane.
    SelectAllToggled,
    /// Enqueue current item and advance to next.
    ItemEnqueued,
    /// Open bulk actions modal.
    BulkActionsOpened,
    /// Close bulk actions modal.
    BulkActionsClosed,
    /// Execute a bulk action.
    BulkActionExecuted { action_index: usize },

    // -- Actions on results -----------------------------------------------
    /// Copy the current snippet to clipboard.
    CopySnippet,
    /// Copy the current source path to clipboard.
    CopyPath,
    /// Copy the rendered detail content to clipboard.
    CopyContent,
    /// Copy the current search query to clipboard.
    CopyQuery,
    /// Open the current result in $EDITOR.
    OpenInEditor,
    /// Open content in nano.
    OpenInNano,
    /// Open all enqueued items in $EDITOR.
    OpenAllQueued,
    /// View raw source file.
    ViewRaw,
    /// Peek XL context (toggle).
    PeekToggled,
    /// Refresh results (re-run current query).
    ResultsRefreshed,

    // -- Pane filter (/ in results) ---------------------------------------
    /// Enter pane-local filter mode.
    PaneFilterOpened,
    /// Update pane filter text.
    PaneFilterChanged(String),
    /// Apply or cancel pane filter.
    PaneFilterClosed { apply: bool },

    // -- Input mode transitions -------------------------------------------
    /// Enter a specific input mode (Agent, Workspace, DateFrom, DateTo).
    InputModeEntered(InputMode),
    /// Update the ephemeral input buffer.
    InputBufferChanged(String),
    /// Apply the current input buffer as a filter and return to Query mode.
    InputModeApplied,
    /// Cancel input mode and return to Query mode.
    InputModeCancelled,
    /// Auto-complete the input buffer to the first suggestion.
    InputAutoCompleted,

    // -- History ----------------------------------------------------------
    /// Navigate query history.
    HistoryNavigated { forward: bool },
    /// Cycle through history (Ctrl+R).
    HistoryCycled,

    // -- Command palette --------------------------------------------------
    /// Open the command palette.
    PaletteOpened,
    /// Close the command palette.
    PaletteClosed,
    /// Update the palette search query.
    PaletteQueryChanged(String),
    /// Move palette selection.
    PaletteSelectionMoved { delta: i32 },
    /// Execute the selected palette action.
    PaletteActionExecuted,
    /// Toggle the palette evidence ledger panel.
    PaletteEvidenceToggled,
    /// Toggle palette micro-bench mode for latency profiling.
    PaletteBenchToggled,
    /// Cycle the palette match-type filter (F9 while palette is open).
    PaletteMatchModeCycled,

    // -- Theme editor -----------------------------------------------------
    /// Open the interactive theme editor modal.
    ThemeEditorOpened,
    /// Close the theme editor (discarding unsaved changes).
    ThemeEditorClosed,
    /// Move selection in the theme editor color list.
    ThemeEditorMoved { delta: i32 },
    /// Start editing the selected color slot (Enter).
    ThemeEditorEditStarted,
    /// Commit the hex input for the selected color slot (Enter while editing).
    ThemeEditorEditCommitted,
    /// Cancel hex editing (Esc while editing).
    ThemeEditorEditCancelled,
    /// Update the hex input buffer.
    ThemeEditorHexChanged(String),
    /// Clear the override for the selected slot (Del).
    ThemeEditorSlotCleared,
    /// Cycle the base preset in the editor.
    ThemeEditorPresetCycled,
    /// Export/save the theme config to disk.
    ThemeEditorExported,

    // -- Inspector overlay ------------------------------------------------
    /// Toggle the inspector debug overlay (Ctrl+Shift+I).
    InspectorToggled,
    /// Cycle the active inspector tab (Timing → Layout → HitRegions).
    InspectorTabCycled,
    /// Cycle the ftui inspector mode (Off → HitRegions → WidgetBounds → Full).
    InspectorModeCycled,
    /// Toggle cockpit mode on/off within the inspector overlay.
    CockpitModeToggled,
    /// Toggle cockpit between overlay and expanded display modes.
    CockpitExpandToggled,

    // -- Help overlay -----------------------------------------------------
    /// Toggle the help overlay.
    HelpToggled,
    /// Scroll the help overlay.
    HelpScrolled { delta: i32 },
    /// Toggle help strip pinned state.
    HelpPinToggled,

    // -- Export modal ------------------------------------------------------
    /// Open the export modal.
    ExportModalOpened,
    /// Close the export modal.
    ExportModalClosed,
    /// Update an export modal field.
    ExportFieldChanged {
        field: crate::ui::components::export_modal::ExportField,
        value: String,
    },
    /// Toggle an export modal checkbox.
    ExportFieldToggled(crate::ui::components::export_modal::ExportField),
    /// Move focus within the export modal.
    ExportFocusMoved { forward: bool },
    /// Execute the export.
    ExportExecuted,
    /// Export progress update from background task.
    ExportProgressUpdated(ExportProgress),
    /// Export completed successfully.
    ExportCompleted {
        output_path: PathBuf,
        file_size: usize,
        encrypted: bool,
    },
    /// Export failed.
    ExportFailed(String),

    // -- Consent dialog (semantic model download) -------------------------
    /// Open the consent dialog.
    ConsentDialogOpened,
    /// Close the consent dialog.
    ConsentDialogClosed,
    /// User accepted model download.
    ModelDownloadAccepted,
    /// Model download progress update.
    ModelDownloadProgress { bytes_downloaded: u64, total: u64 },
    /// Model download completed.
    ModelDownloadCompleted,
    /// Model download failed.
    ModelDownloadFailed(String),
    /// User cancelled the active download.
    ModelDownloadCancelled,
    /// User accepted hash mode fallback (no ML model).
    HashModeAccepted,

    // -- Source filter menu ------------------------------------------------
    /// Toggle the source filter popup menu.
    SourceFilterMenuToggled,
    /// Select a source filter from the menu.
    SourceFilterSelected(SourceFilter),

    // -- Update assistant -------------------------------------------------
    /// Update check completed.
    UpdateCheckCompleted(UpdateInfo),
    /// User chose to upgrade.
    UpdateUpgradeRequested,
    /// User chose to skip this version.
    UpdateSkipped,
    /// User chose to view release notes.
    UpdateReleaseNotesRequested,
    /// User dismissed the update banner.
    UpdateDismissed,

    // -- Did-you-mean suggestions -----------------------------------------
    /// Apply a did-you-mean suggestion by index (1, 2, or 3).
    SuggestionApplied(u8),

    // -- Display ----------------------------------------------------------
    /// Toggle fancy/plain borders.
    BordersToggled,
    /// Grow the pane item count.
    PaneGrew,
    /// Shrink the pane item count.
    PaneShrunk,

    // -- Saved views ------------------------------------------------------
    /// Open saved views manager modal.
    SavedViewsOpened,
    /// Close saved views manager modal.
    SavedViewsClosed,
    /// Move selection in saved views modal.
    SavedViewsSelectionMoved { delta: i32 },
    /// Load currently selected saved view.
    SavedViewLoadedSelected,
    /// Enter rename mode for selected saved view.
    SavedViewRenameStarted,
    /// Commit rename for selected saved view.
    SavedViewRenameCommitted,
    /// Delete selected saved view slot.
    SavedViewDeletedSelected,
    /// Clear all saved view slots.
    SavedViewsCleared,
    /// Save current view to a slot (1-9).
    ViewSaved(u8),
    /// Load a saved view from a slot (1-9).
    ViewLoaded(u8),

    // -- Index ------------------------------------------------------------
    /// User requested index refresh.
    IndexRefreshRequested,
    /// Index progress update.
    IndexProgress {
        processed: usize,
        total: usize,
        new_items: usize,
    },
    /// Index refresh completed.
    IndexRefreshCompleted,
    /// Index refresh failed.
    IndexRefreshFailed(String),

    // -- State persistence ------------------------------------------------
    /// Load persisted state from disk.
    StateLoadRequested,
    /// Persisted state loaded.
    StateLoaded(Box<PersistedState>),
    /// Persisted state load failed.
    StateLoadFailed(String),
    /// Save current state to disk.
    StateSaveRequested,
    /// Persisted state save completed.
    StateSaved,
    /// Persisted state save failed.
    StateSaveFailed(String),
    /// Reset all persisted state to defaults.
    StateResetRequested,

    // -- Toast notifications ----------------------------------------------
    /// Show a toast notification.
    ToastShown {
        message: String,
        toast_type: crate::ui::components::toast::ToastType,
    },
    /// Dismiss expired toasts (called on tick).
    ToastTick,

    // -- Window & terminal ------------------------------------------------
    /// Terminal resized.
    Resized { width: u16, height: u16 },
    /// Terminal focus gained or lost.
    TerminalFocusChanged(bool),
    /// Periodic tick for animations and debounce.
    Tick,
    /// Mouse event with coordinates.
    MouseEvent {
        kind: MouseEventKind,
        x: u16,
        y: u16,
    },

    // -- Analytics surface ------------------------------------------------
    /// Switch to analytics surface (pushes Search onto back-stack).
    AnalyticsEntered,
    /// Deferred analytics data load (lets UI render a loading frame first).
    AnalyticsLoadRequested,
    /// Async analytics chart data loaded successfully.
    AnalyticsChartDataLoaded(Box<AnalyticsChartData>),
    /// Async analytics chart data load failed.
    AnalyticsChartDataFailed(String),
    /// Navigate to a specific analytics subview.
    AnalyticsViewChanged(AnalyticsView),
    /// Pop the view stack (Esc from analytics returns to search).
    ViewStackPopped,
    /// Update analytics time range filter.
    AnalyticsTimeRangeSet {
        since_ms: Option<i64>,
        until_ms: Option<i64>,
    },
    /// Update analytics agent filter.
    AnalyticsAgentFilterSet(HashSet<String>),
    /// Update analytics workspace filter.
    AnalyticsWorkspaceFilterSet(HashSet<String>),
    /// Update analytics source filter.
    AnalyticsSourceFilterSet(SourceFilter),
    /// Clear all analytics filters.
    AnalyticsFiltersClearAll,
    /// Drilldown from analytics selection into the search view.
    AnalyticsDrilldown(DrilldownContext),
    /// Move selection within the current analytics subview.
    AnalyticsSelectionMoved { delta: i32 },
    /// Cycle the Explorer metric forward or backward.
    ExplorerMetricCycled { forward: bool },
    /// Cycle the Explorer overlay mode.
    ExplorerOverlayCycled,
    /// Cycle the Explorer group-by granularity forward or backward.
    ExplorerGroupByCycled { forward: bool },
    /// Cycle the Explorer zoom preset forward or backward.
    ExplorerZoomCycled { forward: bool },
    /// Cycle the Breakdowns tab forward or backward.
    BreakdownTabCycled { forward: bool },
    /// Cycle the Heatmap metric forward or backward.
    HeatmapMetricCycled { forward: bool },

    // -- Sources management surface (2noh9.4.9) ----------------------------
    /// Switch to the sources management surface.
    SourcesEntered,
    /// Reload sources config + sync status from disk.
    SourcesRefreshed,
    /// Trigger sync for the selected source (by name).
    SourceSyncRequested(String),
    /// Sync completed with a result message.
    SourceSyncCompleted {
        source_name: String,
        message: String,
    },
    /// Trigger doctor diagnostics for the selected source.
    SourceDoctorRequested(String),
    /// Doctor diagnostics completed.
    SourceDoctorCompleted {
        source_name: String,
        passed: usize,
        warnings: usize,
        failed: usize,
    },
    /// Move selection in the sources list.
    SourcesSelectionMoved { delta: i32 },

    // -- Screenshot export -------------------------------------------------
    /// Capture a screenshot of the current TUI state.
    ScreenshotRequested(ScreenshotFormat),
    /// Screenshot file was written successfully.
    ScreenshotCompleted(PathBuf),
    /// Screenshot export failed.
    ScreenshotFailed(String),

    // -- Macro recording/playback -----------------------------------------
    /// Toggle interactive macro recording (start/stop).
    MacroRecordingToggled,
    /// Macro recording saved to path.
    MacroRecordingSaved(PathBuf),
    /// Macro recording failed.
    MacroRecordingFailed(String),

    // -- Lifecycle ---------------------------------------------------------
    /// Application quit requested.
    QuitRequested,
    /// Force quit (Ctrl+C).
    ForceQuit,
}

/// Direction for focus movement.
#[derive(Debug, Clone, Copy)]
pub enum FocusDirection {
    Up,
    Down,
    Left,
    Right,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct SavedViewDragState {
    pub from_idx: usize,
    pub hover_idx: usize,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct PaneSplitDragState;

/// Mouse event kinds (simplified from crossterm/ftui).
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum MouseEventKind {
    LeftClick,
    LeftDrag,
    LeftRelease,
    RightClick,
    ScrollUp,
    ScrollDown,
    /// Mouse moved without any button pressed (hover).
    Moved,
}

/// Region identified by mouse hit-testing against last-rendered layout rects.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum MouseHitRegion {
    /// Drag handle between results and detail panes.
    SplitHandle,
    /// Row in the saved views manager list.
    SavedViewRow { row_idx: usize },
    /// Active filter pill in the search header.
    Pill { index: usize },
    /// Click/scroll landed in a results pane row.
    /// `pane_idx` is the absolute pane index, `item_idx` is row index inside that pane.
    Results { pane_idx: usize, item_idx: usize },
    /// Click/scroll landed in the detail pane.
    Detail,
    /// Click/scroll landed in the search bar.
    SearchBar,
    /// Click/scroll landed in the status footer.
    StatusBar,
    /// Click/scroll landed outside any tracked region.
    None,
}

/// Wrapper for terminal events that will be converted to specific messages.
#[derive(Debug)]
pub struct TerminalEventPayload {
    /// Opaque event data (will be ftui::Event in the runtime).
    _private: (),
}

// =========================================================================
// Persisted state (for save/load)
// =========================================================================

/// Subset of CassApp state that persists across sessions.
#[derive(Debug, Clone)]
pub struct PersistedState {
    pub search_mode: SearchMode,
    pub match_mode: MatchMode,
    pub ranking_mode: RankingMode,
    pub context_window: ContextWindow,
    pub theme_dark: bool,
    pub density_mode: DensityMode,
    pub per_pane_limit: usize,
    pub query_history: VecDeque<String>,
    pub saved_views: Vec<SavedView>,
    pub analytics_since_ms: Option<i64>,
    pub analytics_until_ms: Option<i64>,
    pub analytics_agents: HashSet<String>,
    pub analytics_workspaces: HashSet<String>,
    pub analytics_source_filter: SourceFilter,
    pub fancy_borders: bool,
    pub help_pinned: bool,
    pub has_seen_help: bool,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize, Default)]
struct PersistedSavedView {
    #[serde(default)]
    slot: u8,
    #[serde(default)]
    label: Option<String>,
    #[serde(default)]
    agents: Vec<String>,
    #[serde(default)]
    workspaces: Vec<String>,
    #[serde(default)]
    created_from: Option<i64>,
    #[serde(default)]
    created_to: Option<i64>,
    #[serde(default)]
    ranking: Option<String>,
    #[serde(default)]
    source_filter_kind: Option<String>,
    #[serde(default)]
    source_filter_value: Option<String>,
    #[serde(default)]
    source_filter: Option<serde_json::Value>,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize, Default)]
struct PersistedStateFile {
    #[serde(default)]
    version: u32,
    #[serde(default)]
    search_mode: Option<String>,
    #[serde(default)]
    match_mode: Option<String>,
    #[serde(default)]
    ranking_mode: Option<String>,
    #[serde(default)]
    context_window: Option<String>,
    #[serde(default)]
    theme_dark: Option<bool>,
    #[serde(default)]
    density_mode: Option<String>,
    #[serde(default)]
    per_pane_limit: Option<usize>,
    #[serde(default)]
    query_history: Vec<String>,
    #[serde(default)]
    saved_views: Vec<PersistedSavedView>,
    #[serde(default)]
    analytics_since_ms: Option<i64>,
    #[serde(default)]
    analytics_until_ms: Option<i64>,
    #[serde(default)]
    analytics_agents: Vec<String>,
    #[serde(default)]
    analytics_workspaces: Vec<String>,
    #[serde(default)]
    analytics_source_filter_kind: Option<String>,
    #[serde(default)]
    analytics_source_filter_value: Option<String>,
    #[serde(default)]
    analytics_source_filter: Option<serde_json::Value>,
    #[serde(default)]
    fancy_borders: Option<bool>,
    #[serde(default)]
    help_pinned: Option<bool>,
    #[serde(default)]
    has_seen_help: Option<bool>,
}

fn parse_search_mode(value: &str) -> Option<SearchMode> {
    match value.to_ascii_lowercase().as_str() {
        "lexical" => Some(SearchMode::Lexical),
        "semantic" => Some(SearchMode::Semantic),
        "hybrid" => Some(SearchMode::Hybrid),
        _ => None,
    }
}

fn search_mode_str(value: SearchMode) -> &'static str {
    match value {
        SearchMode::Lexical => "lexical",
        SearchMode::Semantic => "semantic",
        SearchMode::Hybrid => "hybrid",
    }
}

fn parse_match_mode(value: &str) -> Option<MatchMode> {
    match value.to_ascii_lowercase().as_str() {
        "standard" => Some(MatchMode::Standard),
        "prefix" => Some(MatchMode::Prefix),
        _ => None,
    }
}

fn match_mode_str(value: MatchMode) -> &'static str {
    match value {
        MatchMode::Standard => "standard",
        MatchMode::Prefix => "prefix",
    }
}

fn parse_ranking_mode(value: &str) -> Option<RankingMode> {
    match value.to_ascii_lowercase().as_str() {
        "recent_heavy" => Some(RankingMode::RecentHeavy),
        "balanced" => Some(RankingMode::Balanced),
        "relevance_heavy" => Some(RankingMode::RelevanceHeavy),
        "match_quality_heavy" => Some(RankingMode::MatchQualityHeavy),
        "date_newest" => Some(RankingMode::DateNewest),
        "date_oldest" => Some(RankingMode::DateOldest),
        _ => None,
    }
}

fn ranking_mode_str(value: RankingMode) -> &'static str {
    match value {
        RankingMode::RecentHeavy => "recent_heavy",
        RankingMode::Balanced => "balanced",
        RankingMode::RelevanceHeavy => "relevance_heavy",
        RankingMode::MatchQualityHeavy => "match_quality_heavy",
        RankingMode::DateNewest => "date_newest",
        RankingMode::DateOldest => "date_oldest",
    }
}

fn parse_context_window(value: &str) -> Option<ContextWindow> {
    match value.to_ascii_lowercase().as_str() {
        "small" => Some(ContextWindow::Small),
        "medium" => Some(ContextWindow::Medium),
        "large" => Some(ContextWindow::Large),
        "xlarge" | "x_large" | "xl" => Some(ContextWindow::XLarge),
        _ => None,
    }
}

fn context_window_str(value: ContextWindow) -> &'static str {
    match value {
        ContextWindow::Small => "small",
        ContextWindow::Medium => "medium",
        ContextWindow::Large => "large",
        ContextWindow::XLarge => "xlarge",
    }
}

fn parse_density_mode(value: &str) -> Option<DensityMode> {
    match value.to_ascii_lowercase().as_str() {
        "compact" => Some(DensityMode::Compact),
        "cozy" => Some(DensityMode::Cozy),
        "spacious" => Some(DensityMode::Spacious),
        _ => None,
    }
}

fn density_mode_str(value: DensityMode) -> &'static str {
    match value {
        DensityMode::Compact => "compact",
        DensityMode::Cozy => "cozy",
        DensityMode::Spacious => "spacious",
    }
}

fn source_filter_to_parts(filter: &SourceFilter) -> (String, Option<String>) {
    match filter {
        SourceFilter::All => ("all".to_string(), None),
        SourceFilter::Local => ("local".to_string(), None),
        SourceFilter::Remote => ("remote".to_string(), None),
        SourceFilter::SourceId(id) => ("source_id".to_string(), Some(id.clone())),
    }
}

fn parse_legacy_source_filter(value: &serde_json::Value) -> Option<SourceFilter> {
    match value {
        serde_json::Value::String(s) => Some(SourceFilter::parse(s)),
        serde_json::Value::Object(map) => {
            if let Some(v) = map.get("source_id").and_then(|v| v.as_str()) {
                return Some(SourceFilter::SourceId(v.to_string()));
            }
            if let Some(v) = map.get("SourceId").and_then(|v| v.as_str()) {
                return Some(SourceFilter::SourceId(v.to_string()));
            }
            if map.contains_key("local") || map.contains_key("Local") {
                return Some(SourceFilter::Local);
            }
            if map.contains_key("remote") || map.contains_key("Remote") {
                return Some(SourceFilter::Remote);
            }
            if map.contains_key("all") || map.contains_key("All") {
                return Some(SourceFilter::All);
            }
            None
        }
        _ => None,
    }
}

fn source_filter_from_parts(
    kind: Option<&str>,
    value: Option<&str>,
    legacy: Option<&serde_json::Value>,
) -> SourceFilter {
    let legacy_filter = || parse_legacy_source_filter(legacy?);
    if let Some(kind) = kind {
        return match kind.to_ascii_lowercase().as_str() {
            "all" => SourceFilter::All,
            "local" => SourceFilter::Local,
            "remote" => SourceFilter::Remote,
            "source_id" => value
                .map(|v| SourceFilter::SourceId(v.to_string()))
                .unwrap_or(SourceFilter::All),
            _ => legacy_filter().unwrap_or(SourceFilter::All),
        };
    }
    legacy_filter().unwrap_or(SourceFilter::All)
}

fn persisted_state_defaults() -> PersistedState {
    PersistedState {
        search_mode: SearchMode::default(),
        match_mode: MatchMode::default(),
        ranking_mode: RankingMode::default(),
        context_window: ContextWindow::default(),
        theme_dark: true,
        density_mode: DensityMode::default(),
        per_pane_limit: 0,
        query_history: VecDeque::with_capacity(QUERY_HISTORY_CAP),
        saved_views: Vec::new(),
        analytics_since_ms: None,
        analytics_until_ms: None,
        analytics_agents: HashSet::new(),
        analytics_workspaces: HashSet::new(),
        analytics_source_filter: SourceFilter::All,
        fancy_borders: true,
        help_pinned: false,
        has_seen_help: false,
    }
}

fn persisted_state_file_from_state(state: &PersistedState) -> PersistedStateFile {
    let saved_views = state
        .saved_views
        .iter()
        .map(|view| {
            let (source_filter_kind, source_filter_value) =
                source_filter_to_parts(&view.source_filter);
            PersistedSavedView {
                slot: view.slot,
                label: view.label.clone(),
                agents: view.agents.iter().cloned().collect(),
                workspaces: view.workspaces.iter().cloned().collect(),
                created_from: view.created_from,
                created_to: view.created_to,
                ranking: Some(ranking_mode_str(view.ranking).to_string()),
                source_filter_kind: Some(source_filter_kind),
                source_filter_value,
                source_filter: Some(serde_json::Value::String(view.source_filter.to_string())),
            }
        })
        .collect();
    let (analytics_source_filter_kind, analytics_source_filter_value) =
        source_filter_to_parts(&state.analytics_source_filter);
    PersistedStateFile {
        version: 1,
        search_mode: Some(search_mode_str(state.search_mode).to_string()),
        match_mode: Some(match_mode_str(state.match_mode).to_string()),
        ranking_mode: Some(ranking_mode_str(state.ranking_mode).to_string()),
        context_window: Some(context_window_str(state.context_window).to_string()),
        theme_dark: Some(state.theme_dark),
        density_mode: Some(density_mode_str(state.density_mode).to_string()),
        per_pane_limit: Some(state.per_pane_limit),
        query_history: state.query_history.iter().cloned().collect(),
        saved_views,
        analytics_since_ms: state.analytics_since_ms,
        analytics_until_ms: state.analytics_until_ms,
        analytics_agents: state.analytics_agents.iter().cloned().collect(),
        analytics_workspaces: state.analytics_workspaces.iter().cloned().collect(),
        analytics_source_filter_kind: Some(analytics_source_filter_kind),
        analytics_source_filter_value,
        analytics_source_filter: Some(serde_json::Value::String(
            state.analytics_source_filter.to_string(),
        )),
        fancy_borders: Some(state.fancy_borders),
        help_pinned: Some(state.help_pinned),
        has_seen_help: Some(state.has_seen_help),
    }
}

fn persisted_state_from_file(file: PersistedStateFile) -> PersistedState {
    let defaults = persisted_state_defaults();
    let mut dedup_slots = HashSet::new();
    let saved_views = file
        .saved_views
        .into_iter()
        .filter_map(|view| {
            if !(1..=9).contains(&view.slot) || !dedup_slots.insert(view.slot) {
                return None;
            }
            let ranking = view
                .ranking
                .as_deref()
                .and_then(parse_ranking_mode)
                .unwrap_or(RankingMode::Balanced);
            let source_filter = source_filter_from_parts(
                view.source_filter_kind.as_deref(),
                view.source_filter_value.as_deref(),
                view.source_filter.as_ref(),
            );
            Some(SavedView {
                slot: view.slot,
                label: view.label.filter(|s| !s.trim().is_empty()),
                agents: view
                    .agents
                    .into_iter()
                    .filter(|s| !s.trim().is_empty())
                    .collect(),
                workspaces: view
                    .workspaces
                    .into_iter()
                    .filter(|s| !s.trim().is_empty())
                    .collect(),
                created_from: view.created_from,
                created_to: view.created_to,
                ranking,
                source_filter,
            })
        })
        .collect();
    let mut query_history: VecDeque<String> = file
        .query_history
        .into_iter()
        .filter(|q| !q.trim().is_empty())
        .take(QUERY_HISTORY_CAP)
        .collect();
    if query_history.len() > QUERY_HISTORY_CAP {
        query_history.truncate(QUERY_HISTORY_CAP);
    }
    PersistedState {
        search_mode: file
            .search_mode
            .as_deref()
            .and_then(parse_search_mode)
            .unwrap_or(defaults.search_mode),
        match_mode: file
            .match_mode
            .as_deref()
            .and_then(parse_match_mode)
            .unwrap_or(defaults.match_mode),
        ranking_mode: file
            .ranking_mode
            .as_deref()
            .and_then(parse_ranking_mode)
            .unwrap_or(defaults.ranking_mode),
        context_window: file
            .context_window
            .as_deref()
            .and_then(parse_context_window)
            .unwrap_or(defaults.context_window),
        theme_dark: file.theme_dark.unwrap_or(defaults.theme_dark),
        density_mode: file
            .density_mode
            .as_deref()
            .and_then(parse_density_mode)
            .unwrap_or(defaults.density_mode),
        per_pane_limit: file.per_pane_limit.unwrap_or(defaults.per_pane_limit),
        query_history,
        saved_views,
        analytics_since_ms: file.analytics_since_ms,
        analytics_until_ms: file.analytics_until_ms,
        analytics_agents: file
            .analytics_agents
            .into_iter()
            .filter(|s| !s.trim().is_empty())
            .collect(),
        analytics_workspaces: file
            .analytics_workspaces
            .into_iter()
            .filter(|s| !s.trim().is_empty())
            .collect(),
        analytics_source_filter: source_filter_from_parts(
            file.analytics_source_filter_kind.as_deref(),
            file.analytics_source_filter_value.as_deref(),
            file.analytics_source_filter.as_ref(),
        ),
        fancy_borders: file.fancy_borders.unwrap_or(defaults.fancy_borders),
        help_pinned: file.help_pinned.unwrap_or(defaults.help_pinned),
        has_seen_help: file.has_seen_help.unwrap_or(defaults.has_seen_help),
    }
}

fn load_persisted_state_from_path(path: &Path) -> Result<Option<PersistedState>, String> {
    if !path.exists() {
        return Ok(None);
    }
    let raw = std::fs::read_to_string(path)
        .map_err(|e| format!("failed reading {}: {e}", path.display()))?;
    let file: PersistedStateFile = serde_json::from_str(&raw)
        .map_err(|e| format!("failed parsing {}: {e}", path.display()))?;
    Ok(Some(persisted_state_from_file(file)))
}

fn save_persisted_state_to_path(path: &Path, state: &PersistedState) -> Result<(), String> {
    if let Some(parent) = path.parent() {
        std::fs::create_dir_all(parent)
            .map_err(|e| format!("failed creating {}: {e}", parent.display()))?;
    }
    let tmp_path = path.with_extension("json.tmp");
    let payload = serde_json::to_vec_pretty(&persisted_state_file_from_state(state))
        .map_err(|e| format!("failed serializing state: {e}"))?;
    std::fs::write(&tmp_path, payload)
        .map_err(|e| format!("failed writing {}: {e}", tmp_path.display()))?;
    std::fs::rename(&tmp_path, path)
        .map_err(|e| format!("failed replacing {}: {e}", path.display()))?;
    Ok(())
}

fn clear_persisted_state_file(path: &Path) -> Result<(), String> {
    match std::fs::remove_file(path) {
        Ok(()) => Ok(()),
        Err(e) if e.kind() == std::io::ErrorKind::NotFound => Ok(()),
        Err(e) => Err(format!("failed removing {}: {e}", path.display())),
    }
}

// =========================================================================
// Service Traits
// =========================================================================

/// Async search execution.
///
/// Abstracts the Tantivy + vector index search pipeline so the Model
/// does not hold direct references to index internals.
pub trait SearchService: Send + Sync {
    /// Execute a search query with the given parameters.
    fn execute(&self, params: &SearchParams) -> Result<SearchResult, String>;
}

/// Parameters for a search query.
#[derive(Debug, Clone)]
pub struct SearchParams {
    pub query: String,
    pub filters: SearchFilters,
    pub mode: SearchMode,
    pub match_mode: MatchMode,
    pub ranking: RankingMode,
    pub context_window: ContextWindow,
    pub limit: usize,
    pub offset: usize,
}

/// Result returned by [`SearchService::execute`].
#[derive(Debug)]
pub struct SearchResult {
    pub hits: Vec<SearchHit>,
    pub elapsed_ms: u128,
    pub suggestions: Vec<QuerySuggestion>,
    pub wildcard_fallback: bool,
}

/// Background indexing with progress reporting.
pub trait IndexService: Send + Sync {
    /// Trigger an incremental index refresh.
    fn refresh(&self) -> Result<(), String>;

    /// Check if indexing is currently in progress.
    fn is_running(&self) -> bool;
}

/// Open files in external editors.
pub trait EditorService: Send + Sync {
    /// Open a file at the given path, optionally at a specific line.
    fn open(&self, path: &str, line: Option<usize>) -> Result<(), String>;

    /// Open multiple files.
    fn open_many(&self, paths: &[String]) -> Result<(), String>;
}

/// HTML/markdown export.
pub trait ExportService: Send + Sync {
    /// Export a conversation to HTML.
    fn export_html(
        &self,
        source_path: &str,
        output_dir: &std::path::Path,
        encrypt: bool,
        password: Option<&str>,
        show_timestamps: bool,
    ) -> Result<ExportResult, String>;
}

/// Result returned by [`ExportService::export_html`].
#[derive(Debug)]
pub struct ExportResult {
    pub output_path: PathBuf,
    pub file_size: usize,
    pub encrypted: bool,
    pub message_count: usize,
}

/// Save/load TUI state to disk.
pub trait PersistenceService: Send + Sync {
    /// Load persisted state.
    fn load(&self) -> Result<Option<PersistedState>, String>;

    /// Save current state.
    fn save(&self, state: &PersistedState) -> Result<(), String>;

    /// Delete persisted state (reset).
    fn reset(&self) -> Result<(), String>;
}

/// In-process search service backed by Tantivy + SQLite storage.
#[derive(Clone)]
struct TantivySearchService {
    client: Arc<crate::search::query::SearchClient>,
}

impl TantivySearchService {
    fn new(client: Arc<crate::search::query::SearchClient>) -> Self {
        Self { client }
    }
}

impl SearchService for TantivySearchService {
    fn execute(&self, params: &SearchParams) -> Result<SearchResult, String> {
        use crate::search::query::{FieldMask, SearchResult as BackendSearchResult};

        let started = Instant::now();
        let limit = params.limit;
        let offset = params.offset;
        let sparse_threshold = 3;
        let field_mask = FieldMask::new(true, true, true, true);

        let execute_mode = |mode: SearchMode| -> Result<BackendSearchResult, String> {
            match mode {
                SearchMode::Lexical => self
                    .client
                    .search_with_fallback(
                        &params.query,
                        params.filters.clone(),
                        limit,
                        offset,
                        sparse_threshold,
                        field_mask,
                    )
                    .map_err(|e| e.to_string()),
                SearchMode::Semantic => {
                    let (hits, ann_stats) = self
                        .client
                        .search_semantic(
                            &params.query,
                            params.filters.clone(),
                            limit,
                            offset,
                            field_mask,
                            false,
                        )
                        .map_err(|e| e.to_string())?;
                    Ok(crate::search::query::SearchResult {
                        hits,
                        wildcard_fallback: false,
                        cache_stats: crate::search::query::CacheStats::default(),
                        suggestions: Vec::new(),
                        ann_stats,
                    })
                }
                SearchMode::Hybrid => self
                    .client
                    .search_hybrid(
                        &params.query,
                        &params.query,
                        params.filters.clone(),
                        limit,
                        offset,
                        sparse_threshold,
                        field_mask,
                        false,
                    )
                    .map_err(|e| e.to_string()),
            }
        };

        // Semantic/hybrid modes can be unavailable if embedders are not installed.
        // Fall back to lexical so typing always returns results instead of no-op.
        let backend = match execute_mode(params.mode) {
            Ok(result) => result,
            Err(err) if matches!(params.mode, SearchMode::Semantic | SearchMode::Hybrid) => {
                execute_mode(SearchMode::Lexical).map_err(|fallback_err| {
                    format!("search failed ({err}); lexical fallback failed: {fallback_err}")
                })?
            }
            Err(err) => return Err(err),
        };

        Ok(SearchResult {
            hits: backend.hits,
            elapsed_ms: started.elapsed().as_millis(),
            suggestions: backend.suggestions,
            wildcard_fallback: backend.wildcard_fallback,
        })
    }
}

const SEARCH_DEBOUNCE: std::time::Duration = std::time::Duration::from_millis(60);
const STATE_SAVE_DEBOUNCE: Duration = Duration::from_millis(450);

/// Minimum distance (in terminal cells) for a drag event to be considered
/// meaningful. Events with movement below this threshold are discarded to
/// prevent jitter from touchpad noise and sub-cell pointer motion.
const DRAG_JITTER_THRESHOLD: u16 = 2;

/// Minimum time (ms) a drag hover must remain on a new row before the hover
/// index updates. Prevents rapid flickering when dragging across thin row
/// boundaries.
const DRAG_HOVER_SETTLE_MS: u64 = 80;
const TUI_STATE_FILE_NAME: &str = "tui_state.json";
const QUERY_HISTORY_CAP: usize = 50;

// =========================================================================
// From<Event> — convert ftui terminal events into CassMsg
// =========================================================================

impl From<super::ftui_adapter::Event> for CassMsg {
    fn from(event: super::ftui_adapter::Event) -> Self {
        use super::ftui_adapter::{Event, KeyCode, Modifiers};

        // Stash raw event for model-level macro recording.
        stash_raw_event(&event);

        match event {
            Event::Key(key) => {
                // Ignore key-release events so toggle shortcuts (F1/F2, etc.)
                // do not fire twice on terminals that report press+release.
                if key.kind == ftui::KeyEventKind::Release {
                    return CassMsg::Tick;
                }

                let ctrl = key.modifiers.contains(Modifiers::CTRL);
                let alt = key.modifiers.contains(Modifiers::ALT);
                let shift = key.modifiers.contains(Modifiers::SHIFT);

                match key.code {
                    // -- Force quit -----------------------------------------------
                    KeyCode::Char('c') if ctrl => CassMsg::ForceQuit,

                    // -- Escape / quit --------------------------------------------
                    KeyCode::Escape => CassMsg::QuitRequested,
                    KeyCode::F(10) => CassMsg::QuitRequested,

                    // -- Help -----------------------------------------------------
                    KeyCode::F(1) => CassMsg::HelpToggled,
                    KeyCode::Char('h') if alt => CassMsg::HelpToggled,
                    KeyCode::Char('H') if alt => CassMsg::HelpToggled,

                    // -- Theme ----------------------------------------------------
                    KeyCode::F(2) => CassMsg::ThemeToggled,
                    KeyCode::Char('t') if ctrl && !shift => CassMsg::ThemeEditorOpened,
                    KeyCode::Char('t') if alt => CassMsg::ThemeEditorOpened,
                    KeyCode::Char('T') if alt => CassMsg::ThemeEditorOpened,

                    // -- Filters --------------------------------------------------
                    KeyCode::F(3) if shift => CassMsg::FilterAgentSet(HashSet::new()),
                    KeyCode::F(3) => CassMsg::InputModeEntered(InputMode::Agent),
                    KeyCode::F(4) if shift => CassMsg::FiltersClearAll,
                    KeyCode::F(4) => CassMsg::InputModeEntered(InputMode::Workspace),
                    KeyCode::F(5) if shift => CassMsg::TimePresetCycled,
                    KeyCode::F(5) => CassMsg::InputModeEntered(InputMode::CreatedFrom),
                    KeyCode::F(6) => CassMsg::InputModeEntered(InputMode::CreatedTo),

                    // -- Context window -------------------------------------------
                    KeyCode::F(7) => CassMsg::ContextWindowCycled,

                    // -- Editor ---------------------------------------------------
                    KeyCode::F(8) => CassMsg::OpenInEditor,

                    // -- Match mode -----------------------------------------------
                    KeyCode::F(9) => CassMsg::MatchModeCycled,

                    // -- Source filter ---------------------------------------------
                    KeyCode::F(11) if shift => CassMsg::SourceFilterMenuToggled,
                    KeyCode::F(11) => CassMsg::SourceFilterCycled,

                    // -- Ranking --------------------------------------------------
                    KeyCode::F(12) => CassMsg::RankingModeCycled,

                    // -- Search mode (Alt+S) --------------------------------------
                    KeyCode::Char('s') if ctrl && !shift => CassMsg::StatsBarToggled,
                    KeyCode::Char('S') if ctrl && !shift => CassMsg::StatsBarToggled,
                    KeyCode::Char('s') if alt => CassMsg::SearchModeCycled,
                    KeyCode::Char('S') if alt => CassMsg::SearchModeCycled,

                    // -- Surface switch -------------------------------------------
                    KeyCode::Char('a') if alt => CassMsg::AnalyticsEntered,
                    KeyCode::Char('A') if alt => CassMsg::AnalyticsEntered,

                    // -- Macro recording (Alt+M) ----------------------------------
                    KeyCode::Char('m') if alt => CassMsg::MacroRecordingToggled,

                    // -- Command palette ------------------------------------------
                    KeyCode::Char('p') if ctrl => CassMsg::PaletteOpened,
                    KeyCode::Char('p') if alt => CassMsg::PaletteOpened,

                    // -- Result/action shortcuts (Alt+...) ------------------------
                    // Keep printable characters available for query editing.
                    KeyCode::Char('/') if alt => CassMsg::PaneFilterOpened,
                    KeyCode::Char('y') if alt => CassMsg::CopySnippet,
                    KeyCode::Char('o') if alt => CassMsg::OpenInEditor,
                    KeyCode::Char('v') if alt => CassMsg::ViewRaw,
                    KeyCode::Char('J') if alt => CassMsg::ToggleJsonView,
                    KeyCode::Char('r') if alt => CassMsg::ResultsRefreshed,
                    KeyCode::Char('b') if alt => CassMsg::BulkActionsOpened,
                    KeyCode::Char('g') if alt => CassMsg::GroupingCycled,
                    KeyCode::Char('[') if alt => CassMsg::TimelineJumped { forward: false },
                    KeyCode::Char(']') if alt => CassMsg::TimelineJumped { forward: true },

                    // -- History ---------------------------------------------------
                    KeyCode::Char('r') if ctrl && shift => CassMsg::IndexRefreshRequested,
                    KeyCode::Char('r') if ctrl => CassMsg::HistoryCycled,
                    KeyCode::Char('n') if ctrl => CassMsg::HistoryNavigated { forward: true },
                    KeyCode::Char('p') if ctrl => CassMsg::HistoryNavigated { forward: false },

                    // -- Saved views (Ctrl+1..9 save, Shift+1..9 load) -----------
                    KeyCode::Char(c @ '1'..='9') if ctrl => CassMsg::ViewSaved(c as u8 - b'0'),
                    KeyCode::Char(c @ '1'..='9') if shift => CassMsg::ViewLoaded(c as u8 - b'0'),

                    // -- Clear / reset --------------------------------------------
                    KeyCode::Delete if ctrl && shift => CassMsg::StateResetRequested,
                    KeyCode::Delete if ctrl => CassMsg::FiltersClearAll,

                    // -- Theme editor -------------------------------------------------
                    KeyCode::Char('t') if ctrl && shift => CassMsg::ThemeEditorOpened,
                    KeyCode::Char('T') if ctrl => CassMsg::ThemeEditorOpened,

                    // -- Sources management -----------------------------------------
                    KeyCode::Char('s') if ctrl && shift => CassMsg::SourcesEntered,
                    KeyCode::Char('S') if ctrl && shift => CassMsg::SourcesEntered,

                    // -- Inspector overlay -----------------------------------------
                    KeyCode::Char('i') if ctrl && shift => CassMsg::InspectorToggled,
                    KeyCode::Char('I') if ctrl => CassMsg::InspectorToggled,

                    // -- Borders --------------------------------------------------
                    KeyCode::Char('b') if ctrl => CassMsg::BordersToggled,

                    // -- Undo/redo ------------------------------------------------
                    KeyCode::Char('z') if ctrl && shift => CassMsg::Redo,
                    KeyCode::Char('Z') if ctrl => CassMsg::Redo,
                    KeyCode::Char('z') if ctrl => CassMsg::Undo,

                    // -- Line editing ---------------------------------------------
                    KeyCode::Char('u') if ctrl => CassMsg::QueryCleared,
                    KeyCode::Char('w') if ctrl => CassMsg::QueryWordDeleted,
                    KeyCode::Char('f') if ctrl => CassMsg::WildcardFallbackToggled,

                    // -- Density --------------------------------------------------
                    KeyCode::Char('d') if ctrl => CassMsg::DensityModeCycled,

                    // -- Multi-select ---------------------------------------------
                    KeyCode::Char('x') if ctrl => CassMsg::SelectionToggled,
                    KeyCode::Char('a') if ctrl => CassMsg::SelectAllToggled,
                    // Compatibility path: many terminals encode Enter as Ctrl+M / Ctrl+J.
                    KeyCode::Char('m') if ctrl && !alt && !shift => CassMsg::DetailOpened,
                    KeyCode::Char('j') if ctrl && !alt && !shift => CassMsg::DetailOpened,
                    KeyCode::Enter if ctrl => CassMsg::ItemEnqueued,
                    KeyCode::Char('o') if ctrl => CassMsg::OpenAllQueued,

                    // -- Quick export ---------------------------------------------
                    KeyCode::Char('e') if ctrl => CassMsg::ExportModalOpened,

                    // -- Clipboard ------------------------------------------------
                    KeyCode::Char('Y') if ctrl => CassMsg::CopyQuery,
                    KeyCode::Char('y') if ctrl && shift => CassMsg::CopyQuery,
                    KeyCode::Char('y') if ctrl => CassMsg::CopyPath,
                    KeyCode::Char('c') if ctrl && shift => CassMsg::CopyContent,

                    // -- Peek XL --------------------------------------------------
                    KeyCode::Char(' ') if ctrl => CassMsg::PeekToggled,

                    // -- Navigation -----------------------------------------------
                    KeyCode::Tab if shift => CassMsg::FocusDirectional {
                        direction: FocusDirection::Left,
                    },
                    KeyCode::Tab => CassMsg::FocusToggled,
                    KeyCode::Up | KeyCode::Char('k') if alt => CassMsg::FocusDirectional {
                        direction: FocusDirection::Up,
                    },
                    KeyCode::Down | KeyCode::Char('j') if alt => CassMsg::FocusDirectional {
                        direction: FocusDirection::Down,
                    },
                    KeyCode::Left | KeyCode::Char('h') if alt => CassMsg::FocusDirectional {
                        direction: FocusDirection::Left,
                    },
                    KeyCode::Right | KeyCode::Char('l') if alt => CassMsg::FocusDirectional {
                        direction: FocusDirection::Right,
                    },
                    // -- Cursor movement (query editing) --------------------------
                    KeyCode::Left => CassMsg::CursorMoved { delta: -1 },
                    KeyCode::Right => CassMsg::CursorMoved { delta: 1 },

                    KeyCode::Up => CassMsg::SelectionMoved { delta: -1 },
                    KeyCode::Down => CassMsg::SelectionMoved { delta: 1 },
                    KeyCode::Home => CassMsg::CursorJumped { to_end: false },
                    KeyCode::End => CassMsg::CursorJumped { to_end: true },
                    KeyCode::PageUp => CassMsg::PageScrolled { delta: -1 },
                    KeyCode::PageDown => CassMsg::PageScrolled { delta: 1 },
                    KeyCode::Enter => CassMsg::DetailOpened,

                    // -- Pane sizing (Alt+=, Alt+-) -------------------------------
                    KeyCode::Char('-') if alt => CassMsg::PaneShrunk,
                    KeyCode::Char('=') if alt => CassMsg::PaneGrew,
                    KeyCode::Char('+') if alt => CassMsg::PaneGrew,

                    // -- Alt+digit pane switch ------------------------------------
                    KeyCode::Char(c @ '1'..='9') if alt => CassMsg::ActivePaneChanged {
                        index: (c as u8 - b'1') as usize,
                    },

                    // -- Default: treat as query input ----------------------------
                    KeyCode::Char(c) => CassMsg::QueryChanged(c.to_string()),
                    KeyCode::Backspace => CassMsg::QueryChanged(String::new()),

                    _ => CassMsg::Tick, // Unhandled keys become no-op ticks
                }
            }

            Event::Mouse(mouse) => {
                use ftui::core::event::MouseButton;
                use ftui::core::event::MouseEventKind as Mek;
                match mouse.kind {
                    Mek::Down(MouseButton::Left) => CassMsg::MouseEvent {
                        kind: MouseEventKind::LeftClick,
                        x: mouse.x,
                        y: mouse.y,
                    },
                    Mek::Drag(MouseButton::Left) => CassMsg::MouseEvent {
                        kind: MouseEventKind::LeftDrag,
                        x: mouse.x,
                        y: mouse.y,
                    },
                    Mek::Up(MouseButton::Left) => CassMsg::MouseEvent {
                        kind: MouseEventKind::LeftRelease,
                        x: mouse.x,
                        y: mouse.y,
                    },
                    Mek::Down(MouseButton::Right) => CassMsg::MouseEvent {
                        kind: MouseEventKind::RightClick,
                        x: mouse.x,
                        y: mouse.y,
                    },
                    Mek::Down(_) => CassMsg::Tick,
                    Mek::ScrollUp => CassMsg::MouseEvent {
                        kind: MouseEventKind::ScrollUp,
                        x: mouse.x,
                        y: mouse.y,
                    },
                    Mek::ScrollDown => CassMsg::MouseEvent {
                        kind: MouseEventKind::ScrollDown,
                        x: mouse.x,
                        y: mouse.y,
                    },
                    Mek::Moved => CassMsg::MouseEvent {
                        kind: MouseEventKind::Moved,
                        x: mouse.x,
                        y: mouse.y,
                    },
                    _ => CassMsg::Tick,
                }
            }

            Event::Paste(paste) => {
                if paste.text.is_empty() {
                    CassMsg::Tick
                } else {
                    CassMsg::QueryChanged(paste.text)
                }
            }

            Event::Resize { width, height } => CassMsg::Resized { width, height },
            Event::Focus(gained) => CassMsg::TerminalFocusChanged(gained),
            Event::Tick => CassMsg::Tick,
            _ => CassMsg::Tick,
        }
    }
}

// =========================================================================
// ftui::Model implementation
// =========================================================================

impl super::ftui_adapter::Model for CassApp {
    type Message = CassMsg;

    fn init(&mut self) -> ftui::Cmd<CassMsg> {
        // Request state load on startup.
        ftui::Cmd::msg(CassMsg::StateLoadRequested)
    }

    fn update(&mut self, msg: CassMsg) -> ftui::Cmd<CassMsg> {
        // Record raw event for model-level macro recording.
        if let Some(ref mut recorder) = self.macro_recorder
            && let Some(raw_event) = take_raw_event()
        {
            recorder.record_event(raw_event);
        }

        // Consent dialog intercepts D/H keys and blocks other query input
        if self.show_consent_dialog
            && let CassMsg::QueryChanged(ref text) = msg
        {
            if text.eq_ignore_ascii_case("d") {
                return self.update(CassMsg::ModelDownloadAccepted);
            }
            if text.eq_ignore_ascii_case("h") {
                return self.update(CassMsg::HashModeAccepted);
            }
            // Ignore other query input while consent dialog is open
            return ftui::Cmd::none();
        }

        // Export modal intercepts keyboard input for form navigation and text editing.
        if self.show_export_modal
            && let Some(ref mut state) = self.export_modal_state
        {
            match &msg {
                CassMsg::QueryChanged(text) if state.is_editing_text() => {
                    // Route typed characters to the active text field.
                    if text.is_empty() {
                        // Backspace
                        if state.focused == ExportField::Password {
                            state.password_pop();
                        } else if state.focused == ExportField::OutputDir
                            && state.output_dir_editing
                        {
                            state.output_dir_pop();
                        }
                    } else {
                        for c in text.chars() {
                            if state.focused == ExportField::Password {
                                state.password_push(c);
                            } else if state.focused == ExportField::OutputDir
                                && state.output_dir_editing
                            {
                                state.output_dir_push(c);
                            }
                        }
                    }
                    return ftui::Cmd::none();
                }
                CassMsg::QueryChanged(text) => {
                    // Non-editing mode: check for Ctrl+H (password visibility toggle).
                    if text == "\x08" {
                        state.toggle_password_visibility();
                    }
                    return ftui::Cmd::none();
                }
                CassMsg::QuerySubmitted => {
                    // Enter key: toggle text field editing, or execute export.
                    if state.focused == ExportField::OutputDir {
                        state.toggle_current();
                    } else if state.focused == ExportField::ExportButton {
                        return self.update(CassMsg::ExportExecuted);
                    } else if state.focused == ExportField::Password {
                        // Enter in password field = move to next.
                        state.next_field();
                    } else {
                        state.toggle_current();
                    }
                    return ftui::Cmd::none();
                }
                CassMsg::FocusToggled => {
                    // Tab → next field.
                    state.next_field();
                    return ftui::Cmd::none();
                }
                CassMsg::FocusDirectional { .. } => {
                    // Shift+Tab → prev field.
                    state.prev_field();
                    return ftui::Cmd::none();
                }
                CassMsg::PeekToggled => {
                    // Space → toggle checkbox / button.
                    if state.focused == ExportField::ExportButton {
                        return self.update(CassMsg::ExportExecuted);
                    }
                    state.toggle_current();
                    return ftui::Cmd::none();
                }
                _ => {
                    // Let non-intercepted messages (like Tick, QuitRequested,
                    // ExportModalOpened/Closed, etc.) fall through to normal handling.
                }
            }
        }

        // Update banner shortcuts:
        // - Shift+U: upgrade (two-step confirm)
        // - Shift+N: open release notes
        // - Shift+S: skip version
        // - Esc: dismiss banner for this session
        if self.can_handle_update_shortcuts() {
            match &msg {
                CassMsg::QueryChanged(text) if text == "U" => {
                    return self.update(CassMsg::UpdateUpgradeRequested);
                }
                CassMsg::QueryChanged(text) if text == "N" => {
                    return self.update(CassMsg::UpdateReleaseNotesRequested);
                }
                CassMsg::QueryChanged(text) if text == "S" => {
                    return self.update(CassMsg::UpdateSkipped);
                }
                CassMsg::QuitRequested => {
                    return self.update(CassMsg::UpdateDismissed);
                }
                _ => {}
            }
        }

        // ── Theme editor modal intercept ────────────────────────────
        if self.show_theme_editor
            && let Some(editor) = self.theme_editor.as_ref()
        {
            let is_editing = editor.editing;
            if is_editing {
                // In hex editing mode: intercept text and confirm/cancel
                match &msg {
                    CassMsg::QueryChanged(text) => {
                        if let Some(ed) = self.theme_editor.as_mut() {
                            if text.is_empty() {
                                ed.hex_buffer.pop();
                            } else {
                                ed.hex_buffer.push_str(text);
                            }
                        }
                        return ftui::Cmd::none();
                    }
                    CassMsg::DetailOpened | CassMsg::QuerySubmitted => {
                        return self.update(CassMsg::ThemeEditorEditCommitted);
                    }
                    CassMsg::QuitRequested => {
                        return self.update(CassMsg::ThemeEditorEditCancelled);
                    }
                    // Let direct theme-editor messages through to the handler
                    CassMsg::ThemeEditorEditCommitted
                    | CassMsg::ThemeEditorEditCancelled
                    | CassMsg::ThemeEditorHexChanged(_)
                    | CassMsg::ThemeEditorClosed => {}
                    _ => return ftui::Cmd::none(),
                }
            } else {
                // In navigation mode: intercept nav and action keys
                match &msg {
                    CassMsg::SelectionMoved { delta } => {
                        return self.update(CassMsg::ThemeEditorMoved { delta: *delta });
                    }
                    CassMsg::CursorMoved { delta } => {
                        return self.update(CassMsg::ThemeEditorMoved { delta: *delta });
                    }
                    CassMsg::DetailOpened | CassMsg::QuerySubmitted => {
                        return self.update(CassMsg::ThemeEditorEditStarted);
                    }
                    CassMsg::QuitRequested => {
                        return self.update(CassMsg::ThemeEditorClosed);
                    }
                    CassMsg::QueryChanged(text) => match text.as_str() {
                        "p" => return self.update(CassMsg::ThemeEditorPresetCycled),
                        "s" => return self.update(CassMsg::ThemeEditorExported),
                        "j" => return self.update(CassMsg::ThemeEditorMoved { delta: 1 }),
                        "k" => return self.update(CassMsg::ThemeEditorMoved { delta: -1 }),
                        _ => return ftui::Cmd::none(),
                    },
                    CassMsg::FiltersClearAll => {
                        return self.update(CassMsg::ThemeEditorSlotCleared);
                    }
                    CassMsg::ThemeEditorOpened
                    | CassMsg::ThemeEditorClosed
                    | CassMsg::ThemeEditorMoved { .. }
                    | CassMsg::ThemeEditorEditStarted
                    | CassMsg::ThemeEditorEditCommitted
                    | CassMsg::ThemeEditorEditCancelled
                    | CassMsg::ThemeEditorHexChanged(_)
                    | CassMsg::ThemeEditorPresetCycled
                    | CassMsg::ThemeEditorExported
                    | CassMsg::ThemeEditorSlotCleared => {
                        // Let these through to the handler
                    }
                    _ => return ftui::Cmd::none(),
                }
            }
        }

        // ── Inspector overlay key intercept ─────────────────────────
        // Non-blocking: intercept Tab (cycle tabs), m (cycle mode), c (cockpit)
        if self.show_inspector {
            match &msg {
                CassMsg::InspectorTabCycled | CassMsg::FocusToggled => {
                    self.inspector_tab = self.inspector_tab.next();
                    return ftui::Cmd::none();
                }
                CassMsg::InspectorModeCycled => {
                    self.inspector_state.cycle_mode();
                    return ftui::Cmd::none();
                }
                CassMsg::CockpitModeToggled => {
                    self.cockpit.enabled = !self.cockpit.enabled;
                    if self.cockpit.enabled {
                        self.inspector_tab = InspectorTab::Diff;
                    } else {
                        self.inspector_tab = InspectorTab::Timing;
                    }
                    return ftui::Cmd::none();
                }
                CassMsg::CockpitExpandToggled => {
                    self.cockpit.mode = self.cockpit.mode.cycle();
                    return ftui::Cmd::none();
                }
                // Redirect single-char keys to inspector actions when overlay is open
                CassMsg::QueryChanged(text) if text == "m" => {
                    self.inspector_state.cycle_mode();
                    return ftui::Cmd::none();
                }
                CassMsg::QueryChanged(text) if text == "c" => {
                    return self.update(CassMsg::CockpitModeToggled);
                }
                CassMsg::QueryChanged(text) if text == "e" => {
                    return self.update(CassMsg::CockpitExpandToggled);
                }
                _ => {}
            }
        }

        // ── Bulk-actions modal intercept ────────────────────────────
        // When the bulk modal is open, intercept navigation and confirm.
        if self.show_bulk_modal {
            match &msg {
                CassMsg::SelectionMoved { delta } => {
                    match delta {
                        -1 => self.bulk_action_idx = self.bulk_action_idx.saturating_sub(1),
                        1 => {
                            self.bulk_action_idx =
                                (self.bulk_action_idx + 1).min(BULK_ACTIONS.len() - 1);
                        }
                        _ => {}
                    }
                    return ftui::Cmd::none();
                }
                CassMsg::QuerySubmitted => {
                    // Enter in the modal executes the selected action.
                    let idx = self.bulk_action_idx;
                    return self.update(CassMsg::BulkActionExecuted { action_index: idx });
                }
                CassMsg::QuitRequested => {
                    self.show_bulk_modal = false;
                    self.focus_manager.pop_trap();
                    return ftui::Cmd::none();
                }
                _ => {}
            }
        }

        // Saved views manager modal intercept. While open, consume navigation
        // and action keys so query/search state is not mutated underneath.
        if self.show_saved_views_modal {
            if self.saved_view_rename_mode {
                match &msg {
                    CassMsg::QueryChanged(text) => {
                        if text.is_empty() {
                            self.saved_view_rename_buffer.pop();
                        } else {
                            self.saved_view_rename_buffer.push_str(text);
                        }
                        return ftui::Cmd::none();
                    }
                    CassMsg::DetailOpened | CassMsg::QuerySubmitted => {
                        return ftui::Cmd::msg(CassMsg::SavedViewRenameCommitted);
                    }
                    CassMsg::QuitRequested => {
                        self.saved_view_rename_mode = false;
                        self.saved_view_drag = None;
                        self.saved_view_rename_buffer.clear();
                        self.status = "Cancelled saved view rename".to_string();
                        return ftui::Cmd::none();
                    }
                    CassMsg::SavedViewRenameCommitted
                    | CassMsg::SavedViewsClosed
                    | CassMsg::SavedViewDeletedSelected
                    | CassMsg::SavedViewsCleared => {}
                    _ => return ftui::Cmd::none(),
                }
            }

            match &msg {
                CassMsg::QuitRequested => return ftui::Cmd::msg(CassMsg::SavedViewsClosed),
                CassMsg::SelectionMoved { delta } => {
                    return ftui::Cmd::msg(CassMsg::SavedViewsSelectionMoved { delta: *delta });
                }
                CassMsg::QueryChanged(text) if text.eq_ignore_ascii_case("j") => {
                    return ftui::Cmd::msg(CassMsg::SavedViewsSelectionMoved { delta: 1 });
                }
                CassMsg::QueryChanged(text) if text.eq_ignore_ascii_case("k") => {
                    return ftui::Cmd::msg(CassMsg::SavedViewsSelectionMoved { delta: -1 });
                }
                CassMsg::DetailOpened | CassMsg::QuerySubmitted => {
                    return ftui::Cmd::msg(CassMsg::SavedViewLoadedSelected);
                }
                CassMsg::QueryChanged(text) if text.eq_ignore_ascii_case("r") => {
                    return ftui::Cmd::msg(CassMsg::SavedViewRenameStarted);
                }
                CassMsg::QueryChanged(text) if text.eq_ignore_ascii_case("d") => {
                    return ftui::Cmd::msg(CassMsg::SavedViewDeletedSelected);
                }
                CassMsg::QueryChanged(text) if text.eq_ignore_ascii_case("c") => {
                    return ftui::Cmd::msg(CassMsg::SavedViewsCleared);
                }
                CassMsg::SavedViewsSelectionMoved { .. }
                | CassMsg::SavedViewLoadedSelected
                | CassMsg::ViewLoaded(_)
                | CassMsg::SavedViewRenameStarted
                | CassMsg::SavedViewRenameCommitted
                | CassMsg::SavedViewDeletedSelected
                | CassMsg::SavedViewsCleared
                | CassMsg::SavedViewsClosed
                | CassMsg::SavedViewsOpened
                | CassMsg::MouseEvent { .. } => {}
                _ => return ftui::Cmd::none(),
            }
        }

        // Source filter menu: while open, consume navigation keys and apply
        // selection without affecting results/query.
        if self.source_filter_menu_open {
            match &msg {
                CassMsg::SourceFilterMenuToggled | CassMsg::QuitRequested => {
                    self.source_filter_menu_open = false;
                    self.status = "Source filter menu closed".to_string();
                    self.focus_manager.pop_trap();
                    return ftui::Cmd::none();
                }
                CassMsg::SelectionMoved { delta } => {
                    self.move_source_menu_selection(*delta);
                    return ftui::Cmd::none();
                }
                CassMsg::QueryChanged(text) if text.eq_ignore_ascii_case("j") => {
                    self.move_source_menu_selection(1);
                    return ftui::Cmd::none();
                }
                CassMsg::QueryChanged(text) if text.eq_ignore_ascii_case("k") => {
                    self.move_source_menu_selection(-1);
                    return ftui::Cmd::none();
                }
                CassMsg::DetailOpened | CassMsg::QuerySubmitted => {
                    let filter = self.source_filter_from_menu_selection();
                    return ftui::Cmd::msg(CassMsg::SourceFilterSelected(filter));
                }
                CassMsg::SourceFilterSelected(_) => {}
                _ => return ftui::Cmd::none(),
            }
        }

        // ── Detail modal intercept ──────────────────────────────────
        // When the full-screen detail modal is open, remap navigation and
        // provide find-in-detail text search (Ctrl+F or /).
        if self.show_detail_modal {
            // Sub-intercept: when find bar is active, route text input there.
            if self.detail_find.is_some() && self.input_mode == InputMode::DetailFind {
                match &msg {
                    CassMsg::QueryChanged(text) => {
                        if let Some(ref mut find) = self.detail_find {
                            if text.is_empty() {
                                find.query.pop();
                            } else {
                                find.query.push_str(text);
                            }
                            let q = find.query.clone();
                            return self.update(CassMsg::DetailFindQueryChanged(q));
                        }
                        return ftui::Cmd::none();
                    }
                    CassMsg::QuerySubmitted | CassMsg::DetailOpened => {
                        // Enter → navigate to next match
                        return self.update(CassMsg::DetailFindNavigated { forward: true });
                    }
                    CassMsg::QuitRequested => {
                        // Esc closes the detail modal in one keypress.
                        return self.update(CassMsg::DetailClosed);
                    }
                    // Let detail-specific messages through
                    CassMsg::DetailFindToggled
                    | CassMsg::DetailFindQueryChanged(_)
                    | CassMsg::DetailFindNavigated { .. }
                    | CassMsg::DetailSessionHitNavigated { .. }
                    | CassMsg::DetailClosed
                    | CassMsg::DetailLoadRequested { .. }
                    | CassMsg::DetailTabChanged(_)
                    | CassMsg::DetailScrolled { .. }
                    | CassMsg::DetailWrapToggled
                    | CassMsg::CopySnippet
                    | CassMsg::CopyPath
                    | CassMsg::CopyContent
                    | CassMsg::OpenInEditor
                    | CassMsg::OpenInNano
                    | CassMsg::ViewRaw
                    | CassMsg::Tick
                    | CassMsg::MouseEvent { .. }
                    | CassMsg::ForceQuit => {}
                    _ => return ftui::Cmd::none(),
                }
            } else {
                // Find bar is NOT active — handle detail-level navigation
                match &msg {
                    // Slash or Ctrl+F opens find
                    CassMsg::PaneFilterOpened | CassMsg::WildcardFallbackToggled => {
                        return self.update(CassMsg::DetailFindToggled);
                    }
                    CassMsg::QueryChanged(text) if text == "/" => {
                        return self.update(CassMsg::DetailFindToggled);
                    }
                    // Enter moves to the next contextual search hit while modal is open.
                    CassMsg::QuerySubmitted | CassMsg::DetailOpened => {
                        // Preserve explicit non-context tabs. Navigation is only meaningful
                        // on the Messages tab where hits are shown in-session.
                        if self.detail_tab == DetailTab::Messages {
                            return self
                                .update(CassMsg::DetailSessionHitNavigated { forward: true });
                        }
                        return ftui::Cmd::none();
                    }
                    // j/k scroll the detail view
                    CassMsg::QueryChanged(text) if text == "j" => {
                        return self.update(CassMsg::DetailScrolled { delta: 3 });
                    }
                    CassMsg::QueryChanged(text) if text == "k" => {
                        return self.update(CassMsg::DetailScrolled { delta: -3 });
                    }
                    // n/N navigate contextual search hits for this session.
                    CassMsg::QueryChanged(text) if text == "n" => {
                        return self.update(CassMsg::DetailSessionHitNavigated { forward: true });
                    }
                    CassMsg::QueryChanged(text) if text == "N" => {
                        return self.update(CassMsg::DetailSessionHitNavigated { forward: false });
                    }
                    // w toggles wrap
                    CassMsg::QueryChanged(text) if text == "w" => {
                        return self.update(CassMsg::DetailWrapToggled);
                    }
                    // e expands all tool/system messages
                    CassMsg::QueryChanged(text) if text == "e" => {
                        return self.update(CassMsg::ToolExpandAll);
                    }
                    // c collapses all tool/system messages
                    CassMsg::QueryChanged(text) if text == "c" => {
                        return self.update(CassMsg::ToolCollapseAll);
                    }
                    // { / } jump between messages
                    CassMsg::QueryChanged(text) if text == "{" => {
                        return self.update(CassMsg::DetailMessageJumped {
                            forward: false,
                            user_only: false,
                        });
                    }
                    CassMsg::QueryChanged(text) if text == "}" => {
                        return self.update(CassMsg::DetailMessageJumped {
                            forward: true,
                            user_only: false,
                        });
                    }
                    // [ / ] jump between user messages only
                    CassMsg::QueryChanged(text) if text == "[" => {
                        return self.update(CassMsg::DetailMessageJumped {
                            forward: false,
                            user_only: true,
                        });
                    }
                    CassMsg::QueryChanged(text) if text == "]" => {
                        return self.update(CassMsg::DetailMessageJumped {
                            forward: true,
                            user_only: true,
                        });
                    }
                    // g / G for top / bottom (vim-style)
                    CassMsg::QueryChanged(text) if text == "g" => {
                        self.detail_scroll = 0;
                        return ftui::Cmd::none();
                    }
                    CassMsg::QueryChanged(text) if text == "G" => {
                        self.detail_scroll = self
                            .detail_content_lines
                            .get()
                            .saturating_sub(self.detail_visible_height.get());
                        return ftui::Cmd::none();
                    }
                    // Up/Down scroll detail
                    CassMsg::SelectionMoved { delta } => {
                        return self.update(CassMsg::DetailScrolled { delta: *delta });
                    }
                    // Home/End jump to top/bottom of detail
                    CassMsg::CursorJumped { to_end } => {
                        self.detail_scroll = if *to_end {
                            self.detail_content_lines
                                .get()
                                .saturating_sub(self.detail_visible_height.get())
                        } else {
                            0
                        };
                        return ftui::Cmd::none();
                    }
                    // Esc closes detail modal
                    CassMsg::QuitRequested => {
                        return self.update(CassMsg::DetailClosed);
                    }
                    // Tab cycles detail tabs
                    CassMsg::FocusToggled => {
                        let next = match self.detail_tab {
                            DetailTab::Messages => DetailTab::Snippets,
                            DetailTab::Snippets => DetailTab::Raw,
                            DetailTab::Raw => DetailTab::Json,
                            DetailTab::Json => DetailTab::Analytics,
                            DetailTab::Analytics => DetailTab::Messages,
                        };
                        return self.update(CassMsg::DetailTabChanged(next));
                    }
                    // Let these through unchanged
                    CassMsg::DetailClosed
                    | CassMsg::DetailLoadRequested { .. }
                    | CassMsg::DetailTabChanged(_)
                    | CassMsg::DetailScrolled { .. }
                    | CassMsg::DetailWrapToggled
                    | CassMsg::DetailFindToggled
                    | CassMsg::DetailFindQueryChanged(_)
                    | CassMsg::DetailFindNavigated { .. }
                    | CassMsg::DetailSessionHitNavigated { .. }
                    | CassMsg::ToggleJsonView
                    | CassMsg::CopySnippet
                    | CassMsg::CopyPath
                    | CassMsg::CopyContent
                    | CassMsg::OpenInEditor
                    | CassMsg::OpenInNano
                    | CassMsg::ViewRaw
                    | CassMsg::ToolCollapseToggled(_)
                    | CassMsg::ToolExpandAll
                    | CassMsg::ToolCollapseAll
                    | CassMsg::DetailMessageJumped { .. }
                    | CassMsg::PageScrolled { .. }
                    | CassMsg::Tick
                    | CassMsg::MouseEvent { .. }
                    | CassMsg::ForceQuit => {}
                    _ => return ftui::Cmd::none(),
                }
            }
        }

        // -- Command palette intercept ----------------------------------------
        // When the palette is open, forward raw key events to the ftui
        // CommandPalette widget which owns query, selection, filtering, and
        // scoring.  Execute/Dismiss actions are translated back to our domain
        // via the PaletteResult adapter layer.
        if self.command_palette.is_visible() {
            match &msg {
                // Let critical / non-keyboard messages through to normal handling.
                CassMsg::Tick | CassMsg::ForceQuit | CassMsg::MouseEvent { .. } => {}
                _ => {
                    if let Some(ref raw_event) = peek_raw_event()
                        && let super::ftui_adapter::Event::Key(ke) = raw_event
                    {
                        // Alt+E toggles the evidence ledger panel.
                        if ke.code == super::ftui_adapter::KeyCode::Char('e')
                            && ke.modifiers.contains(super::ftui_adapter::Modifiers::ALT)
                        {
                            self.show_palette_evidence = !self.show_palette_evidence;
                            return ftui::Cmd::none();
                        }
                        // Alt+B toggles micro-bench mode.
                        if ke.code == super::ftui_adapter::KeyCode::Char('b')
                            && ke.modifiers.contains(super::ftui_adapter::Modifiers::ALT)
                        {
                            self.palette_latency.bench_mode = !self.palette_latency.bench_mode;
                            if self.palette_latency.bench_mode {
                                self.palette_latency.reset();
                                self.palette_latency.bench_start = Some(std::time::Instant::now());
                            } else {
                                self.palette_latency.bench_start = None;
                            }
                            return ftui::Cmd::none();
                        }
                        // F9 cycles the match-type filter.
                        if ke.code == super::ftui_adapter::KeyCode::F(9) {
                            self.palette_match_mode = self.palette_match_mode.cycle();
                            let filter = match self.palette_match_mode {
                                PaletteMatchMode::All => MatchFilter::All,
                                PaletteMatchMode::Exact => MatchFilter::Exact,
                                PaletteMatchMode::Prefix => MatchFilter::Prefix,
                                PaletteMatchMode::WordStart => MatchFilter::WordStart,
                                PaletteMatchMode::Substring => MatchFilter::Substring,
                                PaletteMatchMode::Fuzzy => MatchFilter::Fuzzy,
                            };
                            self.command_palette.set_match_filter(filter);
                            self.status =
                                format!("Palette filter: {}", self.palette_match_mode.label());
                            return ftui::Cmd::none();
                        }
                        let _t0 = std::time::Instant::now();
                        if let Some(action) = self.command_palette.handle_event(raw_event) {
                            use ftui::widgets::command_palette::PaletteAction as WPA;
                            match action {
                                WPA::Execute(ref id) => {
                                    self.command_palette.close();
                                    self.show_palette_evidence = false;
                                    self.palette_latency.bench_mode = false;
                                    self.palette_latency.bench_start = None;
                                    self.focus_manager.pop_trap();
                                    let result = action_by_id(&self.palette_state.all_actions, id)
                                        .map(|a| a.dispatch())
                                        .unwrap_or(PaletteResult::Noop);
                                    return self.palette_result_to_cmd(result);
                                }
                                WPA::Dismiss => {
                                    self.command_palette.close();
                                    self.show_palette_evidence = false;
                                    self.palette_latency.bench_mode = false;
                                    self.palette_latency.bench_start = None;
                                    self.focus_manager.pop_trap();
                                    return ftui::Cmd::none();
                                }
                            }
                        }
                        // Event consumed by palette (navigation, typing, etc.)
                        self.palette_latency
                            .record(_t0.elapsed().as_micros() as u64);
                        return ftui::Cmd::none();
                    }
                    // No raw key event available — fall through to main handler.
                }
            }
        }

        // -- Analytics surface interception -----------------------------------
        // When on the analytics surface, remap navigation/selection messages to
        // analytics-specific variants so Enter drills down and Up/Down moves
        // the analytics selection rather than the search results pane.
        if self.surface == AppSurface::Analytics {
            match &msg {
                CassMsg::SelectionMoved { delta } => {
                    return self.update(CassMsg::AnalyticsSelectionMoved { delta: *delta });
                }
                CassMsg::DetailOpened | CassMsg::QuerySubmitted => {
                    // Enter triggers drilldown from the current selection.
                    if let Some(ctx) = self.build_drilldown_context() {
                        return self.update(CassMsg::AnalyticsDrilldown(ctx));
                    }
                    // No drilldown available (Dashboard / Coverage) — no-op.
                    return ftui::Cmd::none();
                }
                CassMsg::CursorMoved { delta } => {
                    // Left/Right cycles analytics view tabs.
                    let views = AnalyticsView::all();
                    if let Some(cur_idx) = views.iter().position(|v| *v == self.analytics_view) {
                        let next = (cur_idx as i32 + delta).rem_euclid(views.len() as i32) as usize;
                        return self.update(CassMsg::AnalyticsViewChanged(views[next]));
                    }
                    return ftui::Cmd::none();
                }
                // Tab / Shift+Tab cycle breakdown sub-tabs when on Breakdowns view.
                CassMsg::FocusToggled if self.analytics_view == AnalyticsView::Breakdowns => {
                    return self.update(CassMsg::BreakdownTabCycled { forward: true });
                }
                CassMsg::FocusDirectional { .. }
                    if self.analytics_view == AnalyticsView::Breakdowns =>
                {
                    return self.update(CassMsg::BreakdownTabCycled { forward: false });
                }
                // Tab / Shift+Tab cycle heatmap metric when on Heatmap view.
                CassMsg::FocusToggled if self.analytics_view == AnalyticsView::Heatmap => {
                    return self.update(CassMsg::HeatmapMetricCycled { forward: true });
                }
                CassMsg::FocusDirectional { .. }
                    if self.analytics_view == AnalyticsView::Heatmap =>
                {
                    return self.update(CassMsg::HeatmapMetricCycled { forward: false });
                }
                // Heatmap view: 'm' cycles metric.
                CassMsg::QueryChanged(text) if self.analytics_view == AnalyticsView::Heatmap => {
                    match text.as_str() {
                        "m" => {
                            return self.update(CassMsg::HeatmapMetricCycled { forward: true });
                        }
                        "M" => {
                            return self.update(CassMsg::HeatmapMetricCycled { forward: false });
                        }
                        _ => {}
                    }
                }
                // Explorer view: 'm' cycles metric, 'o' cycles overlay, 'g' cycles group-by.
                CassMsg::QueryChanged(text) if self.analytics_view == AnalyticsView::Explorer => {
                    match text.as_str() {
                        "m" => {
                            return self.update(CassMsg::ExplorerMetricCycled { forward: true });
                        }
                        "M" => {
                            return self.update(CassMsg::ExplorerMetricCycled { forward: false });
                        }
                        "o" | "O" => {
                            return self.update(CassMsg::ExplorerOverlayCycled);
                        }
                        "g" => {
                            return self.update(CassMsg::ExplorerGroupByCycled { forward: true });
                        }
                        "G" => {
                            return self.update(CassMsg::ExplorerGroupByCycled { forward: false });
                        }
                        "z" => {
                            return self.update(CassMsg::ExplorerZoomCycled { forward: true });
                        }
                        "Z" => {
                            return self.update(CassMsg::ExplorerZoomCycled { forward: false });
                        }
                        _ => {}
                    }
                }
                // Bare 'o' key fires OpenInEditor; remap to overlay toggle on Explorer.
                CassMsg::OpenInEditor if self.analytics_view == AnalyticsView::Explorer => {
                    return self.update(CassMsg::ExplorerOverlayCycled);
                }
                // Suppress query input on analytics surface (no search bar visible).
                CassMsg::QueryChanged(_) => {
                    return ftui::Cmd::none();
                }
                // Let other messages (analytics-specific, lifecycle, etc.) fall through.
                _ => {}
            }
        }

        // When on the sources surface, remap navigation and suppress query input.
        if self.surface == AppSurface::Sources {
            match &msg {
                CassMsg::SelectionMoved { delta } => {
                    return self.update(CassMsg::SourcesSelectionMoved { delta: *delta });
                }
                // 's' key triggers sync for selected source.
                CassMsg::QueryChanged(text) if text == "s" || text == "S" => {
                    if let Some(item) = self.sources_view.items.get(self.sources_view.selected)
                        && item.kind != crate::sources::SourceKind::Local
                        && !item.busy
                    {
                        let name = item.name.clone();
                        return self.update(CassMsg::SourceSyncRequested(name));
                    }
                    return ftui::Cmd::none();
                }
                // 'd' key triggers doctor for selected source.
                CassMsg::QueryChanged(text) if text == "d" || text == "D" => {
                    if let Some(item) = self.sources_view.items.get(self.sources_view.selected)
                        && item.kind != crate::sources::SourceKind::Local
                        && !item.busy
                    {
                        let name = item.name.clone();
                        return self.update(CassMsg::SourceDoctorRequested(name));
                    }
                    return ftui::Cmd::none();
                }
                // 'r' key refreshes the source list from disk.
                CassMsg::QueryChanged(text) if text == "r" || text == "R" => {
                    return self.update(CassMsg::SourcesRefreshed);
                }
                // Suppress all other query input on sources surface.
                CassMsg::QueryChanged(_) => {
                    return ftui::Cmd::none();
                }
                _ => {}
            }
        }

        // Non-query input modes (agent/workspace/date/pane) own keyboard
        // editing. Route printable/backspace/enter/esc here so those modes
        // are actually interactive.
        if self.surface == AppSurface::Search
            && self.input_mode != InputMode::Query
            && self.focus_manager.current() == Some(focus_ids::SEARCH_BAR)
        {
            match &msg {
                CassMsg::QueryChanged(text) => {
                    if text.is_empty() {
                        self.input_buffer.pop();
                    } else {
                        self.input_buffer.push_str(text);
                    }
                    if self.input_mode == InputMode::PaneFilter {
                        self.pane_filter = Some(self.input_buffer.clone());
                    }
                    return ftui::Cmd::none();
                }
                CassMsg::QueryCleared => {
                    self.input_buffer.clear();
                    if self.input_mode == InputMode::PaneFilter {
                        self.pane_filter = Some(String::new());
                    }
                    return ftui::Cmd::none();
                }
                CassMsg::QueryWordDeleted => {
                    let trimmed = self.input_buffer.trim_end();
                    let new_end = trimmed
                        .rfind(|c: char| c.is_whitespace())
                        .map(|i| i + 1)
                        .unwrap_or(0);
                    self.input_buffer.truncate(new_end);
                    if self.input_mode == InputMode::PaneFilter {
                        self.pane_filter = Some(self.input_buffer.clone());
                    }
                    return ftui::Cmd::none();
                }
                CassMsg::DetailOpened | CassMsg::QuerySubmitted => {
                    if self.input_mode == InputMode::PaneFilter {
                        return self.update(CassMsg::PaneFilterClosed { apply: true });
                    }
                    return self.update(CassMsg::InputModeApplied);
                }
                CassMsg::FocusToggled => {
                    return self.update(CassMsg::InputAutoCompleted);
                }
                CassMsg::QuitRequested => {
                    if self.input_mode == InputMode::PaneFilter {
                        return self.update(CassMsg::PaneFilterClosed { apply: false });
                    }
                    return self.update(CassMsg::InputModeCancelled);
                }
                _ => {}
            }
        }

        // Legacy ratatui parity: in the main search surface, Left/Right should
        // navigate result panes (sessions) while results are focused.
        if self.surface == AppSurface::Search
            && self.input_mode == InputMode::Query
            && !self.show_detail_modal
            && let CassMsg::CursorMoved { delta } = msg
        {
            match self.focus_manager.current() {
                Some(id) if id == focus_ids::RESULTS_LIST && !self.panes.is_empty() => {
                    let target = if delta > 0 {
                        self.active_pane
                            .saturating_add(delta as usize)
                            .min(self.panes.len().saturating_sub(1))
                    } else {
                        self.active_pane
                            .saturating_sub(delta.unsigned_abs() as usize)
                    };

                    if target != self.active_pane {
                        return self.update(CassMsg::ActivePaneChanged { index: target });
                    }

                    // At the rightmost pane, Right arrow moves focus to detail.
                    if delta > 0 {
                        return self.update(CassMsg::FocusDirectional {
                            direction: FocusDirection::Right,
                        });
                    }
                    return ftui::Cmd::none();
                }
                Some(id) if id == focus_ids::DETAIL_PANE => {
                    if delta < 0 {
                        return self.update(CassMsg::FocusDirectional {
                            direction: FocusDirection::Left,
                        });
                    }
                    return ftui::Cmd::none();
                }
                _ => {}
            }
        }

        match msg {
            // -- Terminal event passthrough (unused, events come as CassMsg) ---
            CassMsg::TerminalEvent(_) => ftui::Cmd::none(),

            // -- Query & search -----------------------------------------------
            CassMsg::QueryChanged(text) => {
                let cursor = clamp_cursor_boundary(&self.query, self.cursor_pos);
                if text.is_empty() {
                    // Backspace: remove char before cursor
                    if cursor > 0 {
                        let new_cursor = prev_cursor_boundary(&self.query, cursor);
                        self.query.drain(new_cursor..cursor);
                        self.cursor_pos = new_cursor;
                    }
                } else {
                    self.query.insert_str(cursor, &text);
                    self.cursor_pos = cursor + text.len();
                }
                self.dirty_since = Some(Instant::now());
                self.search_dirty_since = Some(Instant::now());
                self.history_cursor = None;
                ftui::Cmd::tick(SEARCH_DEBOUNCE)
            }
            CassMsg::QueryCleared => {
                self.push_undo("Clear query");
                self.query.clear();
                self.cursor_pos = 0;
                self.dirty_since = Some(Instant::now());
                self.search_dirty_since = Some(Instant::now());
                self.history_cursor = None;
                ftui::Cmd::tick(SEARCH_DEBOUNCE)
            }
            CassMsg::QueryWordDeleted => {
                // Delete word backward from cursor (Ctrl+W): trim trailing
                // whitespace before cursor, then delete to word boundary.
                let cursor = clamp_cursor_boundary(&self.query, self.cursor_pos);
                if cursor > 0 {
                    self.push_undo("Delete word");
                    let before = &self.query[..cursor];
                    let trimmed = before.trim_end();
                    let new_end = trimmed
                        .rfind(|c: char| c.is_whitespace())
                        .map(|i| i + 1)
                        .unwrap_or(0);
                    self.query.drain(new_end..cursor);
                    self.cursor_pos = new_end;
                    self.dirty_since = Some(Instant::now());
                    self.search_dirty_since = Some(Instant::now());
                    self.history_cursor = None;
                    return ftui::Cmd::tick(SEARCH_DEBOUNCE);
                }
                ftui::Cmd::none()
            }
            CassMsg::QuerySubmitted => {
                // Enter pressed: push query to history (deduplicated), clear
                // debounce state, and force immediate search.
                let q = self.query.trim().to_string();
                if !q.is_empty() {
                    // Remove duplicate from history if present
                    self.query_history.retain(|h| h != &q);
                    self.query_history.push_front(q);
                    if self.query_history.len() > QUERY_HISTORY_CAP {
                        self.query_history.pop_back();
                    }
                    self.dirty_since = Some(Instant::now());
                } else if let Some(prev) = self.query_history.front().cloned() {
                    // Empty query + history → load most recent query
                    self.query = prev;
                    self.cursor_pos = self.query.len();
                    self.dirty_since = Some(Instant::now());
                }
                self.history_cursor = None;
                self.search_dirty_since = None; // cancel pending debounce
                ftui::Cmd::msg(CassMsg::SearchRequested)
            }
            CassMsg::SearchRequested => {
                // Clear debounce state so we don't double-fire.
                self.search_dirty_since = None;
                // Build search params from current state.
                let generation = self.search_generation.wrapping_add(1);
                let params = SearchParams {
                    query: self.query.clone(),
                    filters: self.filters.clone(),
                    mode: self.search_mode,
                    match_mode: self.match_mode,
                    ranking: self.ranking_mode,
                    context_window: self.context_window,
                    // Unlimited results are implemented via paging (no silent hard cap).
                    limit: self.search_page_size.max(1),
                    offset: 0,
                };
                // Skip empty queries.
                if params.query.trim().is_empty() {
                    self.clear_loading_context(LoadingContext::Search);
                    return ftui::Cmd::none();
                }
                // Dispatch async search if a service is available.
                if let Some(svc) = self.search_service.clone() {
                    self.search_generation = generation;
                    self.search_backend_offset = 0;
                    self.search_has_more = true;
                    self.search_in_flight = true;
                    self.status = "Searching\u{2026}".to_string();
                    self.set_loading_context(LoadingContext::Search);
                    ftui::Cmd::task(move || match svc.execute(&params) {
                        Ok(result) => CassMsg::SearchCompleted {
                            generation,
                            hits: result.hits,
                            elapsed_ms: result.elapsed_ms,
                            suggestions: result.suggestions,
                            wildcard_fallback: result.wildcard_fallback,
                            append: false,
                        },
                        Err(e) => CassMsg::SearchFailed {
                            generation,
                            error: e,
                        },
                    })
                } else {
                    self.search_in_flight = false;
                    self.clear_loading_context(LoadingContext::Search);
                    ftui::Cmd::none()
                }
            }
            CassMsg::SearchMoreRequested => {
                if self.search_in_flight || !self.search_has_more {
                    return ftui::Cmd::none();
                }
                let generation = self.search_generation;
                let params = SearchParams {
                    query: self.query.clone(),
                    filters: self.filters.clone(),
                    mode: self.search_mode,
                    match_mode: self.match_mode,
                    ranking: self.ranking_mode,
                    context_window: self.context_window,
                    limit: self.search_page_size.max(1),
                    offset: self.search_backend_offset,
                };
                if params.query.trim().is_empty() {
                    return ftui::Cmd::none();
                }
                if let Some(svc) = self.search_service.clone() {
                    self.search_in_flight = true;
                    self.status = format!("Loading more\u{2026} ({} loaded)", self.results.len());
                    self.set_loading_context(LoadingContext::Search);
                    ftui::Cmd::task(move || match svc.execute(&params) {
                        Ok(result) => CassMsg::SearchCompleted {
                            generation,
                            hits: result.hits,
                            elapsed_ms: result.elapsed_ms,
                            suggestions: result.suggestions,
                            wildcard_fallback: result.wildcard_fallback,
                            append: true,
                        },
                        Err(e) => CassMsg::SearchFailed {
                            generation,
                            error: e,
                        },
                    })
                } else {
                    self.search_in_flight = false;
                    ftui::Cmd::none()
                }
            }
            CassMsg::SearchCompleted {
                generation,
                hits,
                elapsed_ms,
                suggestions,
                wildcard_fallback,
                append,
            } => {
                if generation != self.search_generation {
                    // Stale async completion from an older query — ignore.
                    return ftui::Cmd::none();
                }
                self.search_in_flight = false;
                self.clear_loading_context(LoadingContext::Search);
                self.last_search_ms = Some(elapsed_ms);
                let page_size = self.search_page_size.max(1);
                if append {
                    let backend_returned = hits.len();
                    // Append page results without duplicating hits already loaded.
                    let mut seen: HashSet<SelectedHitKey> =
                        self.results.iter().map(SelectedHitKey::from_hit).collect();
                    let mut added = 0usize;
                    for hit in hits {
                        let key = SelectedHitKey::from_hit(&hit);
                        if seen.insert(key) {
                            self.results.push(hit);
                            added += 1;
                        }
                    }
                    self.search_backend_offset =
                        self.search_backend_offset.saturating_add(backend_returned);
                    // If backend returned fewer than a full page, assume we're at the end.
                    if backend_returned < page_size {
                        self.search_has_more = false;
                    }
                    self.regroup_panes();
                    self.status = format!(
                        "Loaded {} (+{added}) results · last page {}ms{}",
                        self.results.len(),
                        elapsed_ms,
                        if self.search_has_more {
                            " · more available"
                        } else {
                            ""
                        }
                    );
                    // If the user typed while the request was in-flight, schedule
                    // the next debounced search now that we're idle again.
                    if let Some(dirty_ts) = self.search_dirty_since {
                        let elapsed = dirty_ts.elapsed();
                        if elapsed >= SEARCH_DEBOUNCE {
                            return ftui::Cmd::msg(CassMsg::SearchRequested);
                        }
                        return ftui::Cmd::tick(SEARCH_DEBOUNCE.saturating_sub(elapsed));
                    }
                    return ftui::Cmd::none();
                }

                self.suggestions = suggestions;
                self.wildcard_fallback = wildcard_fallback;

                // Store results and group into panes using current mode.
                self.results = hits;
                self.search_backend_offset = self.results.len();
                self.search_has_more = self.results.len() >= page_size;
                self.regroup_panes();

                // Keep selection stable across reranking by retaining only keys that
                // still exist in the new result set.
                let available: HashSet<SelectedHitKey> =
                    self.results.iter().map(SelectedHitKey::from_hit).collect();
                self.selected.retain(|k| available.contains(k));
                if self.selected.is_empty() {
                    self.open_confirm_armed = false;
                }

                self.status = format!(
                    "Loaded {} results in {}ms{}",
                    self.results.len(),
                    elapsed_ms,
                    if self.search_has_more {
                        " · more available"
                    } else {
                        ""
                    }
                );
                if self.anim.enabled
                    && (RESULTS_REVEAL_MIN_HITS..=RESULTS_REVEAL_MAX_HITS)
                        .contains(&self.results.len())
                {
                    self.anim.start_reveal(self.results.len());
                    self.reveal_anim_start = Some(Instant::now());
                } else {
                    self.anim.clear_reveal();
                    self.reveal_anim_start = None;
                }
                // Reset scroll to top for new results.
                let mut state = self.results_list_state.borrow_mut();
                state.scroll_to_top();
                state.select(Some(0));
                // If the user typed while the request was in-flight, schedule
                // the next debounced search now that we're idle again.
                if let Some(dirty_ts) = self.search_dirty_since {
                    let elapsed = dirty_ts.elapsed();
                    if elapsed >= SEARCH_DEBOUNCE {
                        return ftui::Cmd::msg(CassMsg::SearchRequested);
                    }
                    return ftui::Cmd::tick(SEARCH_DEBOUNCE.saturating_sub(elapsed));
                }
                ftui::Cmd::none()
            }
            CassMsg::SearchFailed { generation, error } => {
                if generation != self.search_generation {
                    return ftui::Cmd::none();
                }
                self.search_in_flight = false;
                self.clear_loading_context(LoadingContext::Search);
                self.status = format!("Search error: {error}");
                // If the user typed while the request was in-flight, schedule
                // the next debounced search now that we're idle again.
                if let Some(dirty_ts) = self.search_dirty_since {
                    let elapsed = dirty_ts.elapsed();
                    if elapsed >= SEARCH_DEBOUNCE {
                        return ftui::Cmd::msg(CassMsg::SearchRequested);
                    }
                    return ftui::Cmd::tick(SEARCH_DEBOUNCE.saturating_sub(elapsed));
                }
                ftui::Cmd::none()
            }
            CassMsg::CursorMoved { delta } => {
                self.cursor_pos = move_cursor_by_chars(&self.query, self.cursor_pos, delta);
                ftui::Cmd::none()
            }
            CassMsg::CursorJumped { to_end } => {
                self.cursor_pos = if to_end { self.query.len() } else { 0 };
                ftui::Cmd::none()
            }
            CassMsg::WildcardFallbackToggled => {
                self.wildcard_fallback = !self.wildcard_fallback;
                ftui::Cmd::none()
            }

            // -- Filters ------------------------------------------------------
            CassMsg::FilterAgentSet(agents) => {
                self.push_undo("Set agent filter");
                self.filters.agents = agents;
                ftui::Cmd::msg(CassMsg::SearchRequested)
            }
            CassMsg::FilterWorkspaceSet(workspaces) => {
                self.push_undo("Set workspace filter");
                self.filters.workspaces = workspaces;
                ftui::Cmd::msg(CassMsg::SearchRequested)
            }
            CassMsg::FilterTimeSet { from, to } => {
                self.push_undo("Set time filter");
                self.filters.created_from = from;
                self.filters.created_to = to;
                ftui::Cmd::msg(CassMsg::SearchRequested)
            }
            CassMsg::FilterSourceSet(source) => {
                self.push_undo("Set source filter");
                self.filters.source_filter = source;
                ftui::Cmd::msg(CassMsg::SearchRequested)
            }
            CassMsg::FiltersClearAll => {
                self.push_undo("Clear all filters");
                self.filters = SearchFilters::default();
                self.time_preset = TimePreset::All;
                ftui::Cmd::msg(CassMsg::SearchRequested)
            }
            CassMsg::TimePresetCycled => {
                self.push_undo("Cycle time preset");
                self.time_preset = self.time_preset.next();
                let now = chrono::Utc::now().timestamp();
                let (from, to) = match self.time_preset {
                    TimePreset::All => (None, None),
                    TimePreset::Today => (Some(now - (now % 86400)), None),
                    TimePreset::Week => (Some(now - 7 * 86400), None),
                    TimePreset::Month => (Some(now - 30 * 86400), None),
                    TimePreset::Custom => (self.filters.created_from, self.filters.created_to),
                };
                self.filters.created_from = from;
                self.filters.created_to = to;
                ftui::Cmd::msg(CassMsg::SearchRequested)
            }
            CassMsg::SourceFilterCycled => {
                self.push_undo("Cycle source filter");
                self.filters.source_filter = self.filters.source_filter.cycle();
                self.status = format!(
                    "Source: {}",
                    Self::source_filter_status(&self.filters.source_filter)
                );
                ftui::Cmd::msg(CassMsg::SearchRequested)
            }

            // -- Mode cycling -------------------------------------------------
            CassMsg::SearchModeCycled => {
                self.search_mode = match self.search_mode {
                    SearchMode::Lexical => SearchMode::Semantic,
                    SearchMode::Semantic => SearchMode::Hybrid,
                    SearchMode::Hybrid => SearchMode::Lexical,
                };
                self.status = format!(
                    "Search mode: {} ({} to cycle)",
                    search_mode_str(self.search_mode),
                    shortcuts::SEARCH_MODE
                );
                self.dirty_since = Some(Instant::now());
                ftui::Cmd::msg(CassMsg::SearchRequested)
            }
            CassMsg::MatchModeCycled => {
                self.match_mode = match self.match_mode {
                    MatchMode::Standard => MatchMode::Prefix,
                    MatchMode::Prefix => MatchMode::Standard,
                };
                self.dirty_since = Some(Instant::now());
                ftui::Cmd::msg(CassMsg::SearchRequested)
            }
            CassMsg::RankingModeCycled => {
                self.ranking_mode = match self.ranking_mode {
                    RankingMode::RecentHeavy => RankingMode::Balanced,
                    RankingMode::Balanced => RankingMode::RelevanceHeavy,
                    RankingMode::RelevanceHeavy => RankingMode::MatchQualityHeavy,
                    RankingMode::MatchQualityHeavy => RankingMode::DateNewest,
                    RankingMode::DateNewest => RankingMode::DateOldest,
                    RankingMode::DateOldest => RankingMode::RecentHeavy,
                };
                self.dirty_since = Some(Instant::now());
                ftui::Cmd::none()
            }
            CassMsg::ContextWindowCycled => {
                self.context_window = match self.context_window {
                    ContextWindow::Small => ContextWindow::Medium,
                    ContextWindow::Medium => ContextWindow::Large,
                    ContextWindow::Large => ContextWindow::XLarge,
                    ContextWindow::XLarge => ContextWindow::Small,
                };
                self.dirty_since = Some(Instant::now());
                ftui::Cmd::none()
            }
            CassMsg::DensityModeCycled => {
                self.density_mode = match self.density_mode {
                    DensityMode::Compact => DensityMode::Cozy,
                    DensityMode::Cozy => DensityMode::Spacious,
                    DensityMode::Spacious => DensityMode::Compact,
                };
                self.status = format!("Density: {:?}", self.density_mode);
                self.dirty_since = Some(Instant::now());
                ftui::Cmd::none()
            }
            CassMsg::ThemeToggled => {
                self.theme_preset = self.theme_preset.next();
                self.theme_dark = !matches!(self.theme_preset, UiThemePreset::Light);
                self.style_options.dark_mode = self.theme_dark;
                self.style_options.preset = self.theme_preset;
                self.status = format!("Theme: {}", self.theme_preset.name());
                if let Err(err) = self.persist_theme_selection() {
                    self.status =
                        format!("Theme: {} (not persisted: {err})", self.theme_preset.name());
                }
                self.dirty_since = Some(Instant::now());
                ftui::Cmd::none()
            }

            // -- Navigation ---------------------------------------------------
            CassMsg::SelectionMoved { delta } => {
                if let Some(pane) = self.panes.get_mut(self.active_pane) {
                    let total = pane.hits.len();
                    let mut state = self.results_list_state.borrow_mut();
                    state.select(Some(pane.selected));
                    if delta > 0 {
                        for _ in 0..delta {
                            state.select_next(total);
                        }
                    } else {
                        for _ in 0..delta.unsigned_abs() {
                            state.select_previous(total);
                        }
                    }
                    pane.selected = state.selected.unwrap_or(0);
                }
                // In default query mode, establish focus on the results list
                // so subsequent Enter presses consistently open the detail
                // modal. Skip when the user is editing a filter (agent,
                // workspace, pane filter, etc.) to avoid stealing focus.
                if self.input_mode == InputMode::Query {
                    self.focus_manager.focus(focus_ids::RESULTS_LIST);
                }
                if self.search_has_more
                    && !self.search_in_flight
                    && self.surface == AppSurface::Search
                    && !self.show_detail_modal
                    && self
                        .panes
                        .get(self.active_pane)
                        .is_some_and(|pane| pane.hits.len().saturating_sub(pane.selected + 1) <= 3)
                {
                    ftui::Cmd::msg(CassMsg::SearchMoreRequested)
                } else {
                    ftui::Cmd::none()
                }
            }
            CassMsg::SelectionJumped { to_end } => {
                if let Some(pane) = self.panes.get_mut(self.active_pane) {
                    let total = pane.hits.len();
                    let mut state = self.results_list_state.borrow_mut();
                    if to_end {
                        state.scroll_to_bottom(total);
                        pane.selected = total.saturating_sub(1);
                    } else {
                        state.scroll_to_top();
                        pane.selected = 0;
                    }
                    state.select(Some(pane.selected));
                }
                if self.input_mode == InputMode::Query {
                    self.focus_manager.focus(focus_ids::RESULTS_LIST);
                }
                if to_end
                    && self.search_has_more
                    && !self.search_in_flight
                    && self.surface == AppSurface::Search
                    && !self.show_detail_modal
                {
                    ftui::Cmd::msg(CassMsg::SearchMoreRequested)
                } else {
                    ftui::Cmd::none()
                }
            }
            CassMsg::ActivePaneChanged { index } => {
                if index < self.panes.len() {
                    self.active_pane = index;
                    if let Some(pane) = self.panes.get(self.active_pane) {
                        self.results_list_state
                            .borrow_mut()
                            .select(Some(pane.selected));
                    }
                    self.adjust_pane_scroll_offset();
                    // Pane switches always indicate results navigation intent.
                    self.focus_manager.focus(focus_ids::RESULTS_LIST);
                }
                ftui::Cmd::none()
            }
            CassMsg::FocusToggled => {
                self.focus_manager.focus_next();
                self.focus_flash_until =
                    Some(Instant::now() + std::time::Duration::from_millis(220));
                self.anim.trigger_focus_flash();
                ftui::Cmd::none()
            }
            CassMsg::FocusDirectional { direction } => {
                let nav_dir = match direction {
                    FocusDirection::Left => NavDirection::Left,
                    FocusDirection::Right => NavDirection::Right,
                    FocusDirection::Up => NavDirection::Up,
                    FocusDirection::Down => NavDirection::Down,
                };
                self.focus_manager.navigate(nav_dir);
                ftui::Cmd::none()
            }
            CassMsg::DetailScrolled { delta } => {
                let max_scroll = self
                    .detail_content_lines
                    .get()
                    .saturating_sub(self.detail_visible_height.get());
                let new_scroll = (self.detail_scroll as i32 + delta).clamp(0, max_scroll as i32);
                self.detail_scroll = new_scroll as u16;
                ftui::Cmd::none()
            }
            CassMsg::PageScrolled { delta } => {
                if self.focused_region() == FocusRegion::Detail {
                    let max_scroll = self
                        .detail_content_lines
                        .get()
                        .saturating_sub(self.detail_visible_height.get());
                    let new_scroll =
                        (self.detail_scroll as i32 + (delta * 20)).clamp(0, max_scroll as i32);
                    self.detail_scroll = new_scroll as u16;
                } else if let Some(pane) = self.panes.get_mut(self.active_pane) {
                    let total = pane.hits.len();
                    if total == 0 {
                        return ftui::Cmd::none();
                    }
                    let mut state = self.results_list_state.borrow_mut();
                    // Page keys should move selection by a viewport-sized step.
                    let page_size = state.visible_count().max(1);
                    let steps = delta.unsigned_abs() as usize;
                    let step_size = page_size.saturating_mul(steps);
                    let target = if delta > 0 {
                        pane.selected
                            .saturating_add(step_size)
                            .min(total.saturating_sub(1))
                    } else {
                        pane.selected.saturating_sub(step_size)
                    };
                    pane.selected = target;
                    state.select(Some(target));
                }
                if delta > 0
                    && self.search_has_more
                    && !self.search_in_flight
                    && self.surface == AppSurface::Search
                    && !self.show_detail_modal
                    && self
                        .panes
                        .get(self.active_pane)
                        .is_some_and(|pane| pane.hits.len().saturating_sub(pane.selected + 1) <= 3)
                {
                    ftui::Cmd::msg(CassMsg::SearchMoreRequested)
                } else {
                    ftui::Cmd::none()
                }
            }

            // -- Undo/redo ----------------------------------------------------
            CassMsg::Undo => {
                let current = self.capture_undo_state("current");
                if let Some(entry) = self.undo_history.pop_undo(current) {
                    let desc = entry.description;
                    let cmd = self.restore_undo_state(entry);
                    self.status = format!("Undo: {desc}");
                    cmd
                } else {
                    self.status = "Nothing to undo".to_string();
                    ftui::Cmd::none()
                }
            }
            CassMsg::Redo => {
                let current = self.capture_undo_state("current");
                if let Some(entry) = self.undo_history.pop_redo(current) {
                    let desc = entry.description;
                    let cmd = self.restore_undo_state(entry);
                    self.status = format!("Redo: {desc}");
                    cmd
                } else {
                    self.status = "Nothing to redo".to_string();
                    ftui::Cmd::none()
                }
            }

            // -- Grouping & timeline -----------------------------------------
            CassMsg::GroupingCycled => {
                self.push_undo("Cycle grouping");
                self.grouping_mode = self.grouping_mode.next();
                self.regroup_panes();
                self.status = format!("Grouping: {}", self.grouping_mode.label());
                ftui::Cmd::none()
            }
            CassMsg::TimelineJumped { forward } => {
                if let Some(target) = self.timeline_jump_index(forward) {
                    if let Some(pane) = self.panes.get_mut(self.active_pane) {
                        pane.selected = target;
                        let mut state = self.results_list_state.borrow_mut();
                        state.select(Some(target));
                    }
                    self.status = format!(
                        "Jumped to {}",
                        if forward { "next day" } else { "previous day" }
                    );
                } else {
                    self.status = format!(
                        "No {} day boundary",
                        if forward { "next" } else { "previous" }
                    );
                }
                ftui::Cmd::none()
            }

            // -- Detail view --------------------------------------------------
            CassMsg::DetailOpened => {
                let focus_id = self.focus_manager.current();
                let selected_hit = self.selected_hit().cloned();

                // Re-entrant Enter while detail is already open should be a no-op.
                // This avoids stacking duplicate focus traps on rapid key repeats.
                if self.show_detail_modal {
                    tracing::debug!(
                        route = "detail_modal_noop",
                        reason = "modal_already_open",
                        focus_id = ?focus_id,
                        detail_tab = ?self.detail_tab,
                        "enter routing decision"
                    );
                    return ftui::Cmd::none();
                }

                // Enter should prioritize opening the selected hit in context.
                // If there is no active hit, fall back to query submit behavior.
                let Some(selected_hit) = selected_hit else {
                    tracing::debug!(
                        route = "query_submit_fallback",
                        reason = "no_selected_hit",
                        focus_id = ?focus_id,
                        show_detail_modal = self.show_detail_modal,
                        "enter routing decision"
                    );
                    return self.update(CassMsg::QuerySubmitted);
                };
                // Ensure Enter lands on the contextual conversation view.
                self.detail_tab = DetailTab::Messages;
                tracing::debug!(
                    route = "detail_modal_open",
                    reason = "selected_hit",
                    focus_id = ?focus_id,
                    show_detail_modal = self.show_detail_modal,
                    detail_tab = ?self.detail_tab,
                    "enter routing decision"
                );
                self.show_detail_modal = true;
                self.detail_scroll = 0;
                self.modal_scroll = 0;
                self.sync_detail_session_hit_state(&selected_hit);
                // Auto-scroll to the selected search hit once the Messages renderer
                // computes exact line offsets for session hit anchors.
                self.detail_session_hit_scroll_pending.set(true);
                self.detail_pending_scroll_to.set(None);
                // Seed modal-highlight terms from the active search query so
                // matches are visible immediately in full conversation context.
                let mut highlight_terms = extract_query_terms(&self.query);
                highlight_terms.retain(|term| {
                    !matches!(term.to_ascii_lowercase().as_str(), "and" | "or" | "not")
                });
                let highlight_query = if highlight_terms.is_empty() {
                    self.query.trim().to_string()
                } else {
                    highlight_terms.join(" ")
                };
                self.detail_find = if highlight_query.is_empty() {
                    None
                } else {
                    Some(DetailFindState {
                        query: highlight_query,
                        matches: Vec::new(),
                        current: 0,
                    })
                };
                self.detail_find_matches_cache.borrow_mut().clear();
                self.input_mode = InputMode::Query;
                // Auto-collapse tool/system messages on open for a compact
                // initial view; user can expand with Enter or 'e'.
                self.collapsed_tools.clear();
                if let Some((_, ref cv)) = self.cached_detail {
                    for (idx, msg) in cv.messages.iter().enumerate() {
                        if matches!(
                            msg.role,
                            crate::model::types::MessageRole::Tool
                                | crate::model::types::MessageRole::System
                        ) {
                            self.collapsed_tools.insert(idx);
                        }
                    }
                }
                self.focus_manager.push_trap(focus_ids::GROUP_DETAIL_MODAL);
                self.focus_manager.focus(focus_ids::DETAIL_MODAL);
                let source_path = selected_hit.source_path.clone();
                let needs_reload = self
                    .cached_detail
                    .as_ref()
                    .is_none_or(|(cached_path, _)| cached_path != &source_path);
                if needs_reload {
                    self.cached_detail = None;
                    self.set_loading_context(LoadingContext::DetailModal);
                    return ftui::Cmd::msg(CassMsg::DetailLoadRequested { source_path });
                }
                self.clear_loading_context(LoadingContext::DetailModal);
                ftui::Cmd::none()
            }
            CassMsg::DetailLoadRequested { source_path } => {
                let loaded_path = source_path.clone();
                if let Some(db) = self.db_reader.as_ref() {
                    match load_conversation(db, &source_path) {
                        Ok(Some(view)) => {
                            self.cached_detail = Some((loaded_path.clone(), view));
                        }
                        Ok(None) => {
                            // Keep fallback rendering from SearchHit content.
                        }
                        Err(err) => {
                            self.status = format!("Failed to load conversation detail: {err}");
                        }
                    }
                }

                // Now that the conversation is available, refresh in-session hit anchors
                // based on the full content so navigation can cover all hits, even when
                // the results list is paged.
                if self.show_detail_modal
                    && let Some(hit) = self.selected_hit().cloned()
                    && hit.source_path == loaded_path
                {
                    self.sync_detail_session_hit_state(&hit);
                    self.detail_session_hit_scroll_pending.set(true);
                    self.detail_pending_scroll_to.set(None);
                }
                self.clear_loading_context(LoadingContext::DetailModal);
                ftui::Cmd::none()
            }
            CassMsg::DetailClosed => {
                self.show_detail_modal = false;
                self.input_mode = InputMode::Query;
                self.detail_find = None;
                self.detail_find_matches_cache.borrow_mut().clear();
                self.detail_session_hit_lines.clear();
                self.detail_session_hit_offsets_cache.borrow_mut().clear();
                self.detail_session_hit_current = 0;
                self.detail_session_hit_scroll_pending.set(false);
                self.detail_pending_scroll_to.set(None);
                self.focus_manager.pop_trap();
                self.focus_manager.focus(focus_ids::RESULTS_LIST);
                self.clear_loading_context(LoadingContext::DetailModal);
                ftui::Cmd::none()
            }
            CassMsg::DetailTabChanged(tab) => {
                self.detail_tab = tab;
                self.detail_scroll = 0;
                if tab != DetailTab::Messages {
                    self.detail_session_hit_offsets_cache.borrow_mut().clear();
                    self.detail_session_hit_scroll_pending.set(false);
                    self.detail_pending_scroll_to.set(None);
                }
                ftui::Cmd::none()
            }
            CassMsg::ToggleJsonView => {
                if self.selected_hit().is_some() {
                    // Toggle: if already on Json tab, go back to Raw; otherwise switch to Json.
                    if self.detail_tab == DetailTab::Json {
                        self.detail_tab = DetailTab::Raw;
                    } else {
                        self.detail_tab = DetailTab::Json;
                    }
                    self.detail_scroll = 0;
                    // Only push a focus trap when the modal is freshly opened;
                    // avoid stacking duplicate traps on re-entry (e.g. pressing
                    // 'J' while the detail modal is already visible).
                    if !self.show_detail_modal {
                        self.show_detail_modal = true;
                        self.focus_manager.push_trap(focus_ids::GROUP_DETAIL_MODAL);
                    }
                    self.focus_manager.focus(focus_ids::DETAIL_MODAL);
                } else {
                    self.status = "No active result to view.".to_string();
                }
                ftui::Cmd::none()
            }
            CassMsg::DetailWrapToggled => {
                self.detail_wrap = !self.detail_wrap;
                ftui::Cmd::none()
            }
            CassMsg::ToolCollapseToggled(idx) => {
                if self.collapsed_tools.contains(&idx) {
                    self.collapsed_tools.remove(&idx);
                } else {
                    self.collapsed_tools.insert(idx);
                }
                ftui::Cmd::none()
            }
            CassMsg::ToolExpandAll => {
                self.collapsed_tools.clear();
                ftui::Cmd::none()
            }
            CassMsg::ToolCollapseAll => {
                // Collapse all tool/system messages from the cached detail.
                if let Some((_, ref cv)) = self.cached_detail {
                    for (idx, msg) in cv.messages.iter().enumerate() {
                        if matches!(
                            msg.role,
                            crate::model::types::MessageRole::Tool
                                | crate::model::types::MessageRole::System
                        ) {
                            self.collapsed_tools.insert(idx);
                        }
                    }
                }
                ftui::Cmd::none()
            }
            CassMsg::DetailMessageJumped { forward, user_only } => {
                let offsets = self.detail_message_offsets.borrow();
                if offsets.is_empty() {
                    return ftui::Cmd::none();
                }
                let current = self.detail_scroll;
                let target = if forward {
                    // Find first message offset strictly after current scroll
                    offsets
                        .iter()
                        .filter(|(offset, role)| {
                            *offset > current
                                && (!user_only
                                    || matches!(role, crate::model::types::MessageRole::User))
                        })
                        .map(|(o, _)| *o)
                        .next()
                } else {
                    // Find last message offset strictly before current scroll
                    offsets
                        .iter()
                        .rev()
                        .filter(|(offset, role)| {
                            *offset < current
                                && (!user_only
                                    || matches!(role, crate::model::types::MessageRole::User))
                        })
                        .map(|(o, _)| *o)
                        .next()
                };
                if let Some(pos) = target {
                    self.detail_scroll = pos;
                }
                ftui::Cmd::none()
            }
            CassMsg::StatsBarToggled => {
                self.show_stats_bar = !self.show_stats_bar;
                ftui::Cmd::none()
            }
            CassMsg::DetailFindToggled => {
                if self.detail_find.is_some() {
                    self.detail_find = None;
                    self.detail_find_matches_cache.borrow_mut().clear();
                    if self.input_mode == InputMode::DetailFind {
                        self.input_mode = InputMode::Query;
                    }
                } else {
                    self.detail_find = Some(DetailFindState::default());
                    self.detail_find_matches_cache.borrow_mut().clear();
                    self.input_mode = InputMode::DetailFind;
                }
                ftui::Cmd::none()
            }
            CassMsg::DetailFindQueryChanged(q) => {
                if let Some(ref mut find) = self.detail_find {
                    find.query = q;
                    find.current = 0;
                    // Matches are computed during rendering by apply_find_highlight,
                    // which writes back to find.matches. Clear stale matches here
                    // so the renderer recomputes from scratch.
                    find.matches.clear();
                }
                ftui::Cmd::none()
            }
            CassMsg::DetailFindNavigated { forward } => {
                // Sync matches from render cache before navigating
                if let Some(ref mut find) = self.detail_find {
                    let cached = self.detail_find_matches_cache.borrow();
                    if !cached.is_empty() {
                        find.matches = cached.clone();
                    }
                }
                if let Some(ref mut find) = self.detail_find
                    && !find.matches.is_empty()
                {
                    if forward {
                        find.current = (find.current + 1) % find.matches.len();
                    } else {
                        find.current = find
                            .current
                            .checked_sub(1)
                            .unwrap_or(find.matches.len() - 1);
                    }
                    // Auto-scroll to bring current match into view
                    let target_line = find.matches[find.current];
                    self.detail_scroll = target_line.saturating_sub(3);
                }
                ftui::Cmd::none()
            }
            CassMsg::DetailSessionHitNavigated { forward } => {
                if self.detail_tab != DetailTab::Messages {
                    self.detail_tab = DetailTab::Messages;
                    self.detail_scroll = 0;
                    return ftui::Cmd::none();
                }

                let cached_offsets = self.detail_session_hit_offsets_cache.borrow().clone();
                if cached_offsets.is_empty() {
                    if self.detail_session_hit_lines.is_empty() {
                        return self.update(CassMsg::DetailFindNavigated { forward });
                    }
                    // Allow single-key navigation even before the renderer has computed
                    // exact line offsets: advance the hit index now, then auto-scroll
                    // once offsets are available.
                    let total = self.detail_session_hit_lines.len();
                    if total > 0 {
                        let mut current =
                            self.detail_session_hit_current.min(total.saturating_sub(1));
                        if forward {
                            current = (current + 1) % total;
                        } else {
                            current = current.checked_sub(1).unwrap_or(total - 1);
                        }
                        self.detail_session_hit_current = current;
                        self.detail_session_hit_scroll_pending.set(true);
                    }
                    return ftui::Cmd::none();
                }

                let total = cached_offsets.len();
                let mut current = self.detail_session_hit_current.min(total.saturating_sub(1));
                if forward {
                    current = (current + 1) % total;
                } else {
                    current = current.checked_sub(1).unwrap_or(total - 1);
                }
                self.detail_session_hit_current = current;
                let target_line = cached_offsets[current];
                self.detail_scroll = target_line.saturating_sub(3);
                ftui::Cmd::none()
            }

            // -- Multi-select & bulk ------------------------------------------
            CassMsg::SelectionToggled => {
                if let Some(key) = self.active_hit_key() {
                    if self.selected.remove(&key) {
                        self.status = format!("Deselected ({} selected)", self.selected.len());
                    } else {
                        self.selected.insert(key);
                        self.status = format!(
                            "Selected ({} total) · {} bulk actions · Esc clear",
                            self.selected.len(),
                            shortcuts::BULK_MENU
                        );
                    }
                }
                self.open_confirm_armed = false;
                ftui::Cmd::none()
            }
            CassMsg::SelectAllToggled => {
                if let Some(pane) = self.panes.get(self.active_pane) {
                    let pane_keys: Vec<SelectedHitKey> =
                        pane.hits.iter().map(SelectedHitKey::from_hit).collect();
                    let all_selected = pane_keys.iter().all(|k| self.selected.contains(k));
                    if all_selected {
                        for key in &pane_keys {
                            self.selected.remove(key);
                        }
                        self.status =
                            format!("Deselected all in pane ({} total)", self.selected.len());
                    } else {
                        for key in pane_keys {
                            self.selected.insert(key);
                        }
                        self.status = format!(
                            "Selected all in pane ({} total) · {} bulk actions",
                            self.selected.len(),
                            shortcuts::BULK_MENU
                        );
                    }
                }
                self.open_confirm_armed = false;
                ftui::Cmd::none()
            }
            CassMsg::ItemEnqueued => {
                if let Some(key) = self.active_hit_key() {
                    self.selected.insert(key);
                    self.status = format!(
                        "Queued ({}) · Ctrl+Enter add · Ctrl+O open all",
                        self.selected.len()
                    );
                }
                self.open_confirm_armed = false;
                // Advance selection
                if let Some(pane) = self.panes.get_mut(self.active_pane)
                    && pane.selected + 1 < pane.hits.len()
                {
                    pane.selected += 1;
                }
                ftui::Cmd::none()
            }
            CassMsg::BulkActionsOpened => {
                if self.selected.is_empty() {
                    self.status =
                        "No items selected. Ctrl+X to select, Ctrl+A to select all.".to_string();
                } else {
                    self.show_bulk_modal = true;
                    self.bulk_action_idx = 0;
                    self.status =
                        "Bulk actions: ↑↓ navigate · Enter execute · Esc cancel".to_string();
                    self.focus_manager.push_trap(focus_ids::GROUP_BULK);
                    self.focus_manager.focus(focus_ids::BULK_MODAL);
                }
                ftui::Cmd::none()
            }
            CassMsg::BulkActionsClosed => {
                self.show_bulk_modal = false;
                self.focus_manager.pop_trap();
                ftui::Cmd::none()
            }
            CassMsg::BulkActionExecuted { action_index } => {
                self.show_bulk_modal = false;
                self.focus_manager.pop_trap();
                match action_index {
                    0 => {
                        // Open all in editor — delegate to OpenAllQueued
                        ftui::Cmd::msg(CassMsg::OpenAllQueued)
                    }
                    1 => {
                        let selected_hits = self.selected_hits();
                        let paths: Vec<String> = selected_hits
                            .iter()
                            .map(|h| h.source_path.clone())
                            .collect();
                        let text = paths.join("\n");
                        let count = paths.len();
                        match copy_to_clipboard(&text) {
                            Ok(()) => {
                                use crate::ui::components::toast::{Toast, ToastType};
                                self.selected.clear();
                                self.open_confirm_armed = false;
                                self.status = format!("Copied {count} paths to clipboard");
                                self.toast_manager.push(Toast::new(
                                    format!("Copied {count} paths"),
                                    ToastType::Success,
                                ));
                            }
                            Err(e) => {
                                use crate::ui::components::toast::{Toast, ToastType};
                                self.status = format!("Clipboard: {e}");
                                self.toast_manager.push(Toast::new(
                                    format!("Copy failed: {e}"),
                                    ToastType::Error,
                                ));
                            }
                        }
                        ftui::Cmd::none()
                    }
                    2 => {
                        let selected_hits = self.selected_hits();
                        let export: Vec<serde_json::Value> = selected_hits
                            .iter()
                            .map(|h| {
                                serde_json::json!({
                                    "source_path": h.source_path,
                                    "line_number": h.line_number,
                                    "title": h.title,
                                    "agent": h.agent,
                                    "workspace": h.workspace,
                                    "score": h.score,
                                    "snippet": h.snippet,
                                })
                            })
                            .collect();
                        let count = export.len();
                        match serde_json::to_string_pretty(&export) {
                            Ok(json) => match copy_to_clipboard(&json) {
                                Ok(()) => {
                                    use crate::ui::components::toast::{Toast, ToastType};
                                    self.selected.clear();
                                    self.open_confirm_armed = false;
                                    self.status =
                                        format!("Exported {count} items as JSON to clipboard");
                                    self.toast_manager.push(Toast::new(
                                        format!("Exported {count} items as JSON"),
                                        ToastType::Success,
                                    ));
                                }
                                Err(e) => {
                                    self.status = format!("JSON export failed: {e}");
                                }
                            },
                            Err(e) => {
                                self.status = format!("JSON export failed: {e}");
                            }
                        }
                        ftui::Cmd::none()
                    }
                    3 => {
                        // Clear selection
                        let count = self.selected.len();
                        self.selected.clear();
                        self.open_confirm_armed = false;
                        self.status = format!("Cleared {count} selections");
                        ftui::Cmd::none()
                    }
                    _ => ftui::Cmd::none(),
                }
            }

            // -- Actions on results -------------------------------------------
            CassMsg::CopySnippet => {
                use crate::ui::components::toast::{Toast, ToastType};
                if let Some(hit) = self.selected_hit() {
                    match copy_to_clipboard(hit.snippet.as_str()) {
                        Ok(()) => {
                            self.status = "Copied snippet to clipboard".to_string();
                            self.toast_manager
                                .push(Toast::new("Copied snippet".to_string(), ToastType::Success));
                        }
                        Err(e) => {
                            self.status = format!("Clipboard: {e}");
                            self.toast_manager
                                .push(Toast::new(format!("Copy failed: {e}"), ToastType::Error));
                        }
                    }
                } else {
                    self.status = "No active result to copy.".to_string();
                }
                ftui::Cmd::none()
            }
            CassMsg::CopyPath => {
                use crate::ui::components::toast::{Toast, ToastType};
                if let Some(hit) = self.selected_hit() {
                    match copy_to_clipboard(hit.source_path.as_str()) {
                        Ok(()) => {
                            self.status = "Copied path to clipboard".to_string();
                            self.toast_manager
                                .push(Toast::new("Copied path".to_string(), ToastType::Success));
                        }
                        Err(e) => {
                            self.status = format!("Clipboard: {e}");
                            self.toast_manager
                                .push(Toast::new(format!("Copy failed: {e}"), ToastType::Error));
                        }
                    }
                } else {
                    self.status = "No active result to copy.".to_string();
                }
                ftui::Cmd::none()
            }
            CassMsg::CopyContent => {
                use crate::ui::components::toast::{Toast, ToastType};
                if let Some(hit) = self.selected_hit() {
                    match copy_to_clipboard(hit.content.as_str()) {
                        Ok(()) => {
                            self.status = "Copied content to clipboard".to_string();
                            self.toast_manager
                                .push(Toast::new("Copied content".to_string(), ToastType::Success));
                        }
                        Err(e) => {
                            self.status = format!("Clipboard: {e}");
                            self.toast_manager
                                .push(Toast::new(format!("Copy failed: {e}"), ToastType::Error));
                        }
                    }
                } else {
                    self.status = "No active result to copy.".to_string();
                }
                ftui::Cmd::none()
            }
            CassMsg::CopyQuery => {
                use crate::ui::components::toast::{Toast, ToastType};
                if self.query.is_empty() {
                    self.status = "No query to copy.".to_string();
                } else {
                    match copy_to_clipboard(&self.query) {
                        Ok(()) => {
                            self.status = "Copied query to clipboard".to_string();
                            self.toast_manager
                                .push(Toast::new("Copied query".to_string(), ToastType::Success));
                        }
                        Err(e) => {
                            self.status = format!("Clipboard: {e}");
                            self.toast_manager
                                .push(Toast::new(format!("Copy failed: {e}"), ToastType::Error));
                        }
                    }
                }
                ftui::Cmd::none()
            }
            CassMsg::OpenInEditor => {
                if let Some(hit) = self.selected_hit().cloned() {
                    let editor_cmd = dotenvy::var("EDITOR")
                        .or_else(|_| dotenvy::var("VISUAL"))
                        .unwrap_or_else(|_| "code".to_string());
                    self.status = match open_hits_in_editor(std::slice::from_ref(&hit), &editor_cmd)
                    {
                        Ok((count, editor_bin)) => format!("Opened {count} file in {editor_bin}"),
                        Err(e) => format!("Failed to open editor: {e}"),
                    };
                } else {
                    self.status = "No active result to open.".to_string();
                }
                ftui::Cmd::none()
            }
            CassMsg::OpenInNano => {
                if let Some(hit) = self.selected_hit().cloned() {
                    self.status = match open_hits_in_editor(std::slice::from_ref(&hit), "nano") {
                        Ok((count, editor_bin)) => format!("Opened {count} file in {editor_bin}"),
                        Err(e) => format!("Failed to open editor: {e}"),
                    };
                } else {
                    self.status = "No active result to open.".to_string();
                }
                ftui::Cmd::none()
            }
            CassMsg::OpenAllQueued => {
                if self.selected.is_empty() {
                    self.status = "No items queued. Ctrl+Enter to queue items.".to_string();
                    self.open_confirm_armed = false;
                    return ftui::Cmd::none();
                }
                if self.selected.len() >= OPEN_CONFIRM_THRESHOLD && !self.open_confirm_armed {
                    // First press: arm confirmation
                    self.open_confirm_armed = true;
                    self.status = format!(
                        "Open {} queued items? Press Ctrl+O again to confirm.",
                        self.selected.len()
                    );
                    return ftui::Cmd::none();
                }
                // Execute: open all selected items
                let hits = self.selected_hits();
                let editor_cmd = dotenvy::var("EDITOR")
                    .or_else(|_| dotenvy::var("VISUAL"))
                    .unwrap_or_else(|_| "code".to_string());
                self.status = match open_hits_in_editor(&hits, &editor_cmd) {
                    Ok((count, editor_bin)) => {
                        self.selected.clear();
                        self.open_confirm_armed = false;
                        format!("Opened {count} files in {editor_bin}")
                    }
                    Err(e) => {
                        self.open_confirm_armed = false;
                        format!("Failed to open queued files: {e}")
                    }
                };
                ftui::Cmd::none()
            }
            CassMsg::ViewRaw => {
                if self.selected_hit().is_some() {
                    self.detail_tab = DetailTab::Raw;
                    self.detail_scroll = 0;
                    self.modal_scroll = 0;
                    // Guard against duplicate focus traps when modal is already
                    // open (e.g. pressing 'v' while in the detail view).
                    if !self.show_detail_modal {
                        self.show_detail_modal = true;
                        self.focus_manager.push_trap(focus_ids::GROUP_DETAIL_MODAL);
                    }
                    self.focus_manager.focus(focus_ids::DETAIL_MODAL);
                } else {
                    self.status = "No active result to view.".to_string();
                }
                ftui::Cmd::none()
            }
            CassMsg::PeekToggled => {
                if self.peek_window_saved.is_some() {
                    self.context_window = self
                        .peek_window_saved
                        .take()
                        .unwrap_or(ContextWindow::Medium);
                } else {
                    self.peek_window_saved = Some(self.context_window);
                    self.context_window = ContextWindow::XLarge;
                }
                self.peek_badge_until =
                    Some(Instant::now() + std::time::Duration::from_millis(1500));
                self.anim.show_peek_badge();
                ftui::Cmd::none()
            }
            CassMsg::ResultsRefreshed => ftui::Cmd::msg(CassMsg::SearchRequested),

            // -- Pane filter --------------------------------------------------
            CassMsg::PaneFilterOpened => {
                let seed = self.pane_filter.clone().unwrap_or_default();
                self.pane_filter = Some(seed.clone());
                self.input_mode = InputMode::PaneFilter;
                self.input_buffer = seed;
                self.focus_manager.focus(focus_ids::SEARCH_BAR);
                ftui::Cmd::none()
            }
            CassMsg::PaneFilterChanged(text) => {
                self.input_buffer = text.clone();
                self.pane_filter = Some(text);
                self.regroup_panes();
                ftui::Cmd::none()
            }
            CassMsg::PaneFilterClosed { apply } => {
                if !apply {
                    self.pane_filter = None;
                    self.regroup_panes();
                }
                self.input_mode = InputMode::Query;
                self.input_buffer.clear();
                ftui::Cmd::none()
            }

            // -- Input mode transitions ---------------------------------------
            CassMsg::InputModeEntered(mode) => {
                self.input_mode = mode;
                self.input_buffer.clear();
                self.focus_manager.focus(focus_ids::SEARCH_BAR);
                ftui::Cmd::none()
            }
            CassMsg::InputBufferChanged(text) => {
                self.input_buffer = text;
                ftui::Cmd::none()
            }
            CassMsg::InputModeApplied => {
                let buf = self.input_buffer.trim().to_string();
                let cmd = match self.input_mode {
                    InputMode::Agent if !buf.is_empty() => {
                        // Parse comma-separated agent names.
                        let agents: HashSet<String> =
                            buf.split(',').map(|s| s.trim().to_string()).collect();
                        ftui::Cmd::msg(CassMsg::FilterAgentSet(agents))
                    }
                    InputMode::Workspace if !buf.is_empty() => {
                        let workspaces: HashSet<String> =
                            buf.split(',').map(|s| s.trim().to_string()).collect();
                        ftui::Cmd::msg(CassMsg::FilterWorkspaceSet(workspaces))
                    }
                    InputMode::CreatedFrom => {
                        let ts = parse_time_input(&buf);
                        if ts.is_some() || buf.is_empty() {
                            self.time_preset = if ts.is_some() {
                                TimePreset::Custom
                            } else {
                                TimePreset::All
                            };
                            ftui::Cmd::msg(CassMsg::FilterTimeSet {
                                from: ts,
                                to: self.filters.created_to,
                            })
                        } else {
                            self.status = format!("Invalid date: {buf}");
                            ftui::Cmd::none()
                        }
                    }
                    InputMode::CreatedTo => {
                        let ts = parse_time_input(&buf);
                        if ts.is_some() || buf.is_empty() {
                            self.time_preset = TimePreset::Custom;
                            ftui::Cmd::msg(CassMsg::FilterTimeSet {
                                from: self.filters.created_from,
                                to: ts,
                            })
                        } else {
                            self.status = format!("Invalid date: {buf}");
                            ftui::Cmd::none()
                        }
                    }
                    _ => ftui::Cmd::none(),
                };
                self.input_mode = InputMode::Query;
                self.input_buffer.clear();
                cmd
            }
            CassMsg::InputModeCancelled => {
                self.input_mode = InputMode::Query;
                self.input_buffer.clear();
                ftui::Cmd::none()
            }
            CassMsg::InputAutoCompleted => {
                if let Some(completed) = self.autocomplete_input_buffer() {
                    self.input_buffer = completed;
                }
                ftui::Cmd::none()
            }

            // -- History ------------------------------------------------------
            CassMsg::HistoryNavigated { forward } => {
                let len = self.query_history.len();
                if len == 0 {
                    return ftui::Cmd::none();
                }
                let cursor = self.history_cursor.unwrap_or(0);
                self.history_cursor = Some(if forward {
                    (cursor + 1).min(len.saturating_sub(1))
                } else {
                    cursor.saturating_sub(1)
                });
                if let Some(idx) = self.history_cursor
                    && let Some(q) = self.query_history.get(idx)
                {
                    self.query = q.clone();
                    self.cursor_pos = self.query.len();
                }
                ftui::Cmd::none()
            }
            CassMsg::HistoryCycled => ftui::Cmd::msg(CassMsg::HistoryNavigated { forward: true }),

            // -- Command palette ----------------------------------------------
            CassMsg::PaletteOpened => {
                self.palette_state.query.clear();
                self.palette_state.selected = 0;
                self.palette_match_mode = PaletteMatchMode::default();
                self.palette_state.refilter();
                self.command_palette.set_match_filter(MatchFilter::All);
                self.command_palette.open();
                self.focus_manager.push_trap(focus_ids::GROUP_PALETTE);
                self.focus_manager.focus(focus_ids::COMMAND_PALETTE);
                ftui::Cmd::none()
            }
            CassMsg::PaletteClosed => {
                self.command_palette.close();
                self.show_palette_evidence = false;
                self.palette_latency.bench_mode = false;
                self.palette_latency.bench_start = None;
                self.focus_manager.pop_trap();
                ftui::Cmd::none()
            }
            CassMsg::PaletteEvidenceToggled => {
                self.show_palette_evidence = !self.show_palette_evidence;
                ftui::Cmd::none()
            }
            CassMsg::PaletteBenchToggled => {
                self.palette_latency.bench_mode = !self.palette_latency.bench_mode;
                if self.palette_latency.bench_mode {
                    self.palette_latency.reset();
                    self.palette_latency.bench_start = Some(std::time::Instant::now());
                } else {
                    self.palette_latency.bench_start = None;
                }
                ftui::Cmd::none()
            }
            CassMsg::PaletteMatchModeCycled => {
                self.palette_match_mode = self.palette_match_mode.cycle();
                let filter = match self.palette_match_mode {
                    PaletteMatchMode::All => MatchFilter::All,
                    PaletteMatchMode::Exact => MatchFilter::Exact,
                    PaletteMatchMode::Prefix => MatchFilter::Prefix,
                    PaletteMatchMode::WordStart => MatchFilter::WordStart,
                    PaletteMatchMode::Substring => MatchFilter::Substring,
                    PaletteMatchMode::Fuzzy => MatchFilter::Fuzzy,
                };
                self.command_palette.set_match_filter(filter);
                self.status = format!("Palette filter: {}", self.palette_match_mode.label());
                ftui::Cmd::none()
            }
            CassMsg::PaletteQueryChanged(q) => {
                self.palette_state.query = q;
                self.palette_state.refilter();
                self.palette_state.selected = 0;
                ftui::Cmd::none()
            }
            CassMsg::PaletteSelectionMoved { delta } => {
                let len = self.palette_state.filtered.len();
                if len > 0 {
                    let new_sel = self.palette_state.selected as i32 + delta;
                    self.palette_state.selected = new_sel.rem_euclid(len as i32) as usize;
                }
                ftui::Cmd::none()
            }
            CassMsg::PaletteActionExecuted => {
                let result = execute_selected(&self.palette_state);
                let palette_was_visible = self.command_palette.is_visible();
                self.command_palette.close();
                self.show_palette_evidence = false;
                self.palette_latency.bench_mode = false;
                self.palette_latency.bench_start = None;
                if palette_was_visible {
                    self.focus_manager.pop_trap();
                }
                self.palette_result_to_cmd(result)
            }

            // -- Help overlay -------------------------------------------------
            // -- Theme editor -------------------------------------------------
            CassMsg::ThemeEditorOpened => {
                if !self.show_theme_editor {
                    self.show_theme_editor = true;
                    self.theme_editor = Some(ThemeEditorState::from_data_dir(
                        self.theme_preset,
                        &self.data_dir,
                    ));
                }
                ftui::Cmd::none()
            }
            CassMsg::ThemeEditorClosed => {
                self.show_theme_editor = false;
                self.theme_editor = None;
                ftui::Cmd::none()
            }
            CassMsg::ThemeEditorMoved { delta } => {
                if let Some(editor) = self.theme_editor.as_mut()
                    && !editor.editing
                {
                    let n = ThemeColorSlot::ALL.len();
                    if delta > 0 {
                        editor.selected = (editor.selected + 1).min(n - 1);
                    } else if delta < 0 {
                        editor.selected = editor.selected.saturating_sub(1);
                    }
                }
                ftui::Cmd::none()
            }
            CassMsg::ThemeEditorEditStarted => {
                if let Some(editor) = self.theme_editor.as_mut() {
                    editor.editing = true;
                    let slot = editor.selected_slot();
                    editor.hex_buffer = slot.get(&editor.overrides).unwrap_or("").to_string();
                }
                ftui::Cmd::none()
            }
            CassMsg::ThemeEditorEditCommitted => {
                if let Some(editor) = self.theme_editor.as_mut()
                    && editor.editing
                {
                    let hex = editor.hex_buffer.trim().to_string();
                    let slot = editor.selected_slot();
                    if hex.is_empty() {
                        slot.set(&mut editor.overrides, None);
                    } else {
                        slot.set(&mut editor.overrides, Some(hex));
                    }
                    editor.editing = false;
                    editor.hex_buffer.clear();

                    // Live-apply the config to preview
                    let config = editor.to_config();
                    if let Ok(ctx) =
                        StyleContext::from_options_with_theme_config(self.style_options, &config)
                    {
                        editor.refresh_contrast(&ctx);
                    }
                }
                ftui::Cmd::none()
            }
            CassMsg::ThemeEditorEditCancelled => {
                if let Some(editor) = self.theme_editor.as_mut() {
                    editor.editing = false;
                    editor.hex_buffer.clear();
                }
                ftui::Cmd::none()
            }
            CassMsg::ThemeEditorHexChanged(text) => {
                if let Some(editor) = self.theme_editor.as_mut()
                    && editor.editing
                {
                    editor.hex_buffer = text;
                }
                ftui::Cmd::none()
            }
            CassMsg::ThemeEditorSlotCleared => {
                if let Some(editor) = self.theme_editor.as_mut() {
                    let slot = editor.selected_slot();
                    slot.set(&mut editor.overrides, None);
                }
                ftui::Cmd::none()
            }
            CassMsg::ThemeEditorPresetCycled => {
                if let Some(editor) = self.theme_editor.as_mut() {
                    editor.base_preset = editor.base_preset.next();
                }
                ftui::Cmd::none()
            }
            CassMsg::ThemeEditorExported => {
                if let Some(editor) = self.theme_editor.as_ref() {
                    let config = editor.to_config();
                    let path = self.data_dir.join("theme.json");
                    match config.save_to_path(&path) {
                        Ok(()) => {
                            // Apply saved theme to the live UI.
                            self.theme_preset = editor.base_preset;
                            self.style_options.preset = editor.base_preset;
                            self.theme_dark = !matches!(editor.base_preset, UiThemePreset::Light);
                            self.style_options.dark_mode = self.theme_dark;
                            self.theme_config = Some(config);
                            self.status = format!("Theme saved to {}", path.display());
                        }
                        Err(e) => {
                            self.status = format!("Failed to save theme: {e}");
                        }
                    }
                }
                ftui::Cmd::none()
            }

            // -- Inspector overlay -----------------------------------------
            CassMsg::InspectorToggled => {
                self.show_inspector = !self.show_inspector;
                if self.show_inspector {
                    self.inspector_state.toggle();
                }
                if !self.show_inspector && self.inspector_state.is_active() {
                    self.inspector_state.toggle();
                }
                ftui::Cmd::none()
            }
            CassMsg::InspectorTabCycled => {
                self.inspector_tab = self.inspector_tab.next();
                ftui::Cmd::none()
            }
            CassMsg::InspectorModeCycled => {
                self.inspector_state.cycle_mode();
                ftui::Cmd::none()
            }
            CassMsg::CockpitModeToggled => {
                self.cockpit.enabled = !self.cockpit.enabled;
                // When entering cockpit mode, jump to the first cockpit tab.
                if self.cockpit.enabled {
                    self.inspector_tab = InspectorTab::Diff;
                } else {
                    self.inspector_tab = InspectorTab::Timing;
                }
                ftui::Cmd::none()
            }
            CassMsg::CockpitExpandToggled => {
                self.cockpit.mode = self.cockpit.mode.cycle();
                ftui::Cmd::none()
            }

            CassMsg::HelpToggled => {
                self.show_help = !self.show_help;
                self.help_scroll = 0;
                self.dirty_since = Some(Instant::now());
                if self.show_help {
                    self.has_seen_help = true;
                    self.focus_manager.push_trap(focus_ids::GROUP_HELP);
                    self.focus_manager.focus(focus_ids::HELP_OVERLAY);
                } else {
                    self.focus_manager.pop_trap();
                }
                ftui::Cmd::none()
            }
            CassMsg::HelpScrolled { delta } => {
                let new_scroll = self.help_scroll as i32 + delta;
                self.help_scroll = new_scroll.max(0) as u16;
                ftui::Cmd::none()
            }
            CassMsg::HelpPinToggled => {
                self.help_pinned = !self.help_pinned;
                if self.help_pinned {
                    self.has_seen_help = true;
                }
                self.dirty_since = Some(Instant::now());
                ftui::Cmd::none()
            }

            // -- Export modal -------------------------------------------------
            CassMsg::ExportModalOpened => {
                // Initialize modal state from the currently selected hit + conversation.
                if let Some(hit) = self.selected_hit().cloned() {
                    let state = if let Some((_, ref cv)) = self.cached_detail {
                        ExportModalState::from_hit(&hit, cv)
                    } else {
                        // Fallback: build minimal state from hit alone.
                        ExportModalState {
                            agent_name: hit.agent.clone(),
                            workspace: hit.workspace.clone(),
                            ..Default::default()
                        }
                    };
                    self.export_modal_state = Some(state);
                    self.show_export_modal = true;
                    self.focus_manager.push_trap(focus_ids::GROUP_EXPORT);
                    self.focus_manager.focus(focus_ids::EXPORT_MODAL);
                }
                ftui::Cmd::none()
            }
            CassMsg::ExportModalClosed => {
                self.show_export_modal = false;
                self.export_modal_state = None;
                self.focus_manager.pop_trap();
                ftui::Cmd::none()
            }
            CassMsg::ExportFieldChanged { field, value } => {
                if let Some(ref mut state) = self.export_modal_state {
                    match field {
                        ExportField::OutputDir => {
                            state.output_dir_buffer = value;
                        }
                        ExportField::Password => {
                            state.password = value;
                        }
                        _ => {}
                    }
                }
                ftui::Cmd::none()
            }
            CassMsg::ExportFieldToggled(field) => {
                if let Some(ref mut state) = self.export_modal_state {
                    let prev_focused = state.focused;
                    state.focused = field;
                    state.toggle_current();
                    state.focused = prev_focused;
                }
                ftui::Cmd::none()
            }
            CassMsg::ExportFocusMoved { forward } => {
                if let Some(ref mut state) = self.export_modal_state {
                    if forward {
                        state.next_field();
                    } else {
                        state.prev_field();
                    }
                }
                ftui::Cmd::none()
            }
            CassMsg::ExportExecuted => {
                // Extract source_path before mutable borrow of export_modal_state.
                let source_path = self
                    .selected_hit()
                    .map(|h| h.source_path.clone())
                    .unwrap_or_default();
                if let Some(ref mut state) = self.export_modal_state {
                    if !state.can_export() {
                        return ftui::Cmd::none();
                    }
                    state.progress = ExportProgress::Preparing;
                    let output_dir = state.output_dir.clone();
                    let output_filename = state.filename_preview.clone();
                    let encrypt = state.encrypt;
                    let password = if encrypt {
                        Some(state.password.clone())
                    } else {
                        None
                    };
                    let show_timestamps = state.show_timestamps;
                    let include_tools = state.include_tools;
                    let title = state.title_preview.clone();
                    let agent_name = state.agent_name.clone();

                    // Dispatch the export as a background task.
                    return ftui::Cmd::task(move || {
                        export_session_task(
                            &source_path,
                            &output_dir,
                            &output_filename,
                            encrypt,
                            password.as_deref(),
                            show_timestamps,
                            include_tools,
                            &title,
                            &agent_name,
                        )
                    });
                }
                ftui::Cmd::none()
            }
            CassMsg::ExportProgressUpdated(progress) => {
                if let Some(ref mut state) = self.export_modal_state {
                    state.progress = progress;
                }
                ftui::Cmd::none()
            }
            CassMsg::ExportCompleted {
                output_path,
                file_size: _,
                encrypted: _,
            } => {
                self.show_export_modal = false;
                self.export_modal_state = None;
                self.focus_manager.pop_trap();
                self.status = format!("Exported to {}", output_path.display());
                ftui::Cmd::none()
            }
            CassMsg::ExportFailed(err) => {
                self.status = format!("Export failed: {err}");
                ftui::Cmd::none()
            }

            // -- Screenshot export --------------------------------------------
            CassMsg::ScreenshotRequested(format) => {
                self.screenshot_pending = Some(format);
                // The buffer capture happens in view(); on the next Tick we
                // pick it up and write the file.
                ftui::Cmd::none()
            }
            CassMsg::ScreenshotCompleted(path) => {
                self.status = format!("Screenshot saved: {}", path.display());
                let msg = format!("Saved to {}", path.display());
                ftui::Cmd::msg(CassMsg::ToastShown {
                    message: msg,
                    toast_type: crate::ui::components::toast::ToastType::Success,
                })
            }
            CassMsg::ScreenshotFailed(err) => {
                self.status = format!("Screenshot failed: {err}");
                ftui::Cmd::msg(CassMsg::ToastShown {
                    message: format!("Screenshot failed: {err}"),
                    toast_type: crate::ui::components::toast::ToastType::Error,
                })
            }

            // -- Consent dialog -----------------------------------------------
            CassMsg::ConsentDialogOpened => {
                self.show_consent_dialog = true;
                self.focus_manager.push_trap(focus_ids::GROUP_CONSENT);
                self.focus_manager.focus(focus_ids::CONSENT_DIALOG);
                ftui::Cmd::none()
            }
            CassMsg::ConsentDialogClosed => {
                self.show_consent_dialog = false;
                self.focus_manager.pop_trap();
                ftui::Cmd::none()
            }
            CassMsg::ModelDownloadAccepted => {
                if self.show_consent_dialog {
                    self.show_consent_dialog = false;
                    self.focus_manager.pop_trap();
                }
                self.semantic_availability = SemanticAvailability::Downloading {
                    progress_pct: 0,
                    bytes_downloaded: 0,
                    total_bytes: 0,
                };
                self.status = "Starting semantic model download...".to_string();
                self.toast_manager
                    .push(crate::ui::components::toast::Toast::info(
                        "Starting semantic model download...",
                    ));
                ftui::Cmd::none()
            }
            CassMsg::ModelDownloadProgress {
                bytes_downloaded,
                total,
            } => {
                // Respect explicit non-download semantic modes and ignore stale
                // download lifecycle events that may arrive out of order.
                if matches!(
                    self.semantic_availability,
                    SemanticAvailability::HashFallback | SemanticAvailability::Disabled { .. }
                ) {
                    return ftui::Cmd::none();
                }
                let progress_pct = bytes_downloaded
                    .saturating_mul(100)
                    .checked_div(total)
                    .map_or(0, |pct| pct.min(100));
                let progress_pct = u8::try_from(progress_pct).unwrap_or(100);
                self.semantic_availability = SemanticAvailability::Downloading {
                    progress_pct,
                    bytes_downloaded,
                    total_bytes: total,
                };
                if total > 0 {
                    let done_mb = bytes_downloaded as f64 / 1_048_576.0;
                    let total_mb = total as f64 / 1_048_576.0;
                    self.status = format!(
                        "Downloading semantic model: {progress_pct}% ({done_mb:.1}/{total_mb:.1} MB)"
                    );
                } else {
                    self.status = format!("Downloading semantic model: {bytes_downloaded} bytes");
                }
                ftui::Cmd::none()
            }
            CassMsg::ModelDownloadCompleted => {
                if matches!(
                    self.semantic_availability,
                    SemanticAvailability::HashFallback | SemanticAvailability::Disabled { .. }
                ) {
                    return ftui::Cmd::none();
                }
                if self.show_consent_dialog {
                    self.show_consent_dialog = false;
                    self.focus_manager.pop_trap();
                }
                self.semantic_availability = SemanticAvailability::Ready {
                    embedder_id:
                        crate::search::fastembed_embedder::FastEmbedder::embedder_id_static()
                            .to_string(),
                };
                self.status = "Semantic model ready. Run `cass index --semantic` to build or refresh vector search data.".to_string();
                self.toast_manager
                    .push(crate::ui::components::toast::Toast::success(
                        "Semantic model download complete",
                    ));
                ftui::Cmd::none()
            }
            CassMsg::ModelDownloadFailed(err) => {
                if matches!(
                    self.semantic_availability,
                    SemanticAvailability::HashFallback | SemanticAvailability::Disabled { .. }
                ) {
                    return ftui::Cmd::none();
                }
                if self.show_consent_dialog {
                    self.show_consent_dialog = false;
                    self.focus_manager.pop_trap();
                }
                self.semantic_availability = SemanticAvailability::NotInstalled;
                self.status = format!("Model download failed: {err}");
                self.toast_manager
                    .push(crate::ui::components::toast::Toast::error(format!(
                        "Model download failed: {err}"
                    )));
                ftui::Cmd::none()
            }
            CassMsg::ModelDownloadCancelled => {
                if matches!(
                    self.semantic_availability,
                    SemanticAvailability::HashFallback | SemanticAvailability::Disabled { .. }
                ) {
                    return ftui::Cmd::none();
                }
                if self.show_consent_dialog {
                    self.show_consent_dialog = false;
                    self.focus_manager.pop_trap();
                }
                self.semantic_availability = SemanticAvailability::NotInstalled;
                self.status =
                    "Model download cancelled. Semantic search remains disabled.".to_string();
                self.toast_manager
                    .push(crate::ui::components::toast::Toast::warning(
                        "Model download cancelled",
                    ));
                ftui::Cmd::none()
            }
            CassMsg::HashModeAccepted => {
                // User chose hash embedder fallback instead of downloading ML model.
                if self.show_consent_dialog {
                    self.show_consent_dialog = false;
                    self.focus_manager.pop_trap();
                }
                self.semantic_availability = SemanticAvailability::HashFallback;
                self.status = "Using hash embedder fallback for semantic mode.".to_string();
                self.toast_manager
                    .push(crate::ui::components::toast::Toast::info(
                        "Hash embedder fallback enabled",
                    ));
                ftui::Cmd::none()
            }

            // -- Source filter menu -------------------------------------------
            CassMsg::SourceFilterMenuToggled => {
                if self.source_filter_menu_open {
                    self.source_filter_menu_open = false;
                    self.status = "Source filter menu closed".to_string();
                    self.focus_manager.pop_trap();
                } else {
                    self.refresh_available_source_ids();
                    self.source_filter_menu_open = true;
                    self.focus_manager.push_trap(focus_ids::GROUP_SOURCE_FILTER);
                    self.focus_manager.focus(focus_ids::SOURCE_FILTER_MENU);
                    self.source_filter_menu_selection = match &self.filters.source_filter {
                        SourceFilter::All => 0,
                        SourceFilter::Local => 1,
                        SourceFilter::Remote => 2,
                        SourceFilter::SourceId(id) => self
                            .available_source_ids
                            .iter()
                            .position(|s| s == id)
                            .map(|idx| idx + 3)
                            .unwrap_or(0),
                    };
                    self.status =
                        "Source filter menu (↑/↓ select, Enter apply, Esc close)".to_string();
                }
                ftui::Cmd::none()
            }
            CassMsg::SourceFilterSelected(filter) => {
                self.source_filter_menu_open = false;
                self.focus_manager.pop_trap();
                self.status = format!("Source: {}", Self::source_filter_status(&filter));
                ftui::Cmd::msg(CassMsg::FilterSourceSet(filter))
            }

            // -- Update assistant ---------------------------------------------
            CassMsg::UpdateCheckCompleted(info) => {
                let should_show = info.should_show();
                let latest = info.latest_version.clone();
                let current = info.current_version.clone();
                let skipped = info.is_skipped;
                self.update_info = Some(info);
                self.update_upgrade_armed = false;
                if should_show {
                    self.update_dismissed = false;
                    self.status = format!(
                        "Update available v{} -> v{} (U=upgrade, N=notes, S=skip, Esc=dismiss)",
                        current, latest
                    );
                } else if skipped {
                    self.status = format!(
                        "Update v{} is skipped (open palette: Check updates for details).",
                        latest
                    );
                }
                ftui::Cmd::none()
            }
            CassMsg::UpdateUpgradeRequested => {
                if let Some(info) = &self.update_info {
                    if !info.should_show() {
                        self.status = "You're on the latest version.".to_string();
                        self.update_upgrade_armed = false;
                        return ftui::Cmd::none();
                    }
                    if !self.update_upgrade_armed {
                        self.update_upgrade_armed = true;
                        self.status = format!(
                            "Confirm upgrade to v{}: press U again. Esc cancels.",
                            info.latest_version
                        );
                        return ftui::Cmd::none();
                    }
                    self.update_upgrade_armed = false;
                    #[cfg(test)]
                    {
                        self.status = format!(
                            "TEST mode: would launch self-update to v{}.",
                            info.latest_version
                        );
                        ftui::Cmd::none()
                    }
                    #[cfg(not(test))]
                    {
                        self.status =
                            format!("Launching installer for v{}...", info.latest_version);
                        run_self_update(&info.tag_name);
                    }
                } else {
                    self.status = "No update information available yet.".to_string();
                    self.update_upgrade_armed = false;
                    ftui::Cmd::none()
                }
            }
            CassMsg::UpdateSkipped => {
                self.update_upgrade_armed = false;
                if let Some(info) = &self.update_info {
                    if !info.should_show() {
                        self.status = "Nothing to skip: no pending update.".to_string();
                        return ftui::Cmd::none();
                    }
                    if cfg!(test) {
                        self.update_dismissed = true;
                        self.status = format!(
                            "Skipped v{} (test mode, not persisted).",
                            info.latest_version
                        );
                    } else if let Err(e) = skip_version(&info.latest_version) {
                        self.status = format!("Failed to skip v{}: {e}", info.latest_version);
                    } else {
                        self.update_dismissed = true;
                        self.status = format!("Skipped v{}.", info.latest_version);
                    }
                } else {
                    self.status = "No update information available yet.".to_string();
                }
                ftui::Cmd::none()
            }
            CassMsg::UpdateReleaseNotesRequested => {
                if let Some(info) = &self.update_info {
                    if !info.should_show() {
                        self.status = "You're on the latest version.".to_string();
                        return ftui::Cmd::none();
                    }
                    match open_in_browser(&info.release_url) {
                        Ok(()) => {
                            self.status =
                                format!("Opened release notes for v{}.", info.latest_version);
                        }
                        Err(e) => {
                            self.status = format!("Failed to open release notes: {e}");
                        }
                    }
                } else {
                    self.status = "No update information available yet.".to_string();
                }
                ftui::Cmd::none()
            }
            CassMsg::UpdateDismissed => {
                self.update_dismissed = true;
                self.update_upgrade_armed = false;
                self.status = "Update banner dismissed for this session.".to_string();
                ftui::Cmd::none()
            }

            // -- Did-you-mean suggestions -------------------------------------
            CassMsg::SuggestionApplied(idx) => {
                let idx = idx.saturating_sub(1) as usize;
                if let Some(suggestion) = self.suggestions.get(idx)
                    && let Some(ref q) = suggestion.suggested_query
                {
                    self.query = q.clone();
                    return ftui::Cmd::msg(CassMsg::SearchRequested);
                }
                ftui::Cmd::none()
            }

            // -- Display ------------------------------------------------------
            CassMsg::BordersToggled => {
                self.fancy_borders = !self.fancy_borders;
                self.dirty_since = Some(Instant::now());
                ftui::Cmd::none()
            }
            CassMsg::PaneGrew => {
                if self.per_pane_limit > 0 {
                    self.per_pane_limit = self.per_pane_limit.saturating_add(10);
                }
                self.regroup_panes();
                self.dirty_since = Some(Instant::now());
                ftui::Cmd::none()
            }
            CassMsg::PaneShrunk => {
                self.per_pane_limit = if self.per_pane_limit == 0 {
                    50
                } else {
                    self.per_pane_limit.saturating_sub(10).max(1)
                };
                self.regroup_panes();
                self.dirty_since = Some(Instant::now());
                ftui::Cmd::none()
            }

            // -- Saved views --------------------------------------------------
            CassMsg::SavedViewsOpened => {
                self.sort_saved_views();
                self.clamp_saved_views_selection();
                self.show_saved_views_modal = true;
                self.saved_view_drag = None;
                self.saved_view_rename_mode = false;
                self.saved_view_rename_buffer.clear();
                self.focus_manager.push_trap(focus_ids::GROUP_SAVED_VIEWS);
                self.focus_manager.focus(focus_ids::SAVED_VIEWS_MODAL);
                if self.saved_views.is_empty() {
                    self.status = "No saved views. Use Ctrl+1..9 to save one.".to_string();
                } else {
                    self.status = format!("Saved views manager ({})", self.saved_views.len());
                }
                ftui::Cmd::none()
            }
            CassMsg::SavedViewsClosed => {
                self.show_saved_views_modal = false;
                self.saved_view_drag = None;
                self.saved_view_rename_mode = false;
                self.saved_view_rename_buffer.clear();
                self.focus_manager.pop_trap();
                self.status = "Saved views manager closed".to_string();
                ftui::Cmd::none()
            }
            CassMsg::SavedViewsSelectionMoved { delta } => {
                self.move_saved_views_selection(delta);
                ftui::Cmd::none()
            }
            CassMsg::SavedViewLoadedSelected => {
                if let Some(slot) = self.selected_saved_view_slot() {
                    let modal_was_open = self.show_saved_views_modal;
                    self.show_saved_views_modal = false;
                    self.saved_view_drag = None;
                    self.saved_view_rename_mode = false;
                    self.saved_view_rename_buffer.clear();
                    if modal_was_open {
                        self.focus_manager.pop_trap();
                    }
                    return ftui::Cmd::msg(CassMsg::ViewLoaded(slot));
                }
                use crate::ui::components::toast::{Toast, ToastType};
                self.status = "No saved view selected".to_string();
                self.toast_manager.push(Toast::new(
                    "No saved view selected".to_string(),
                    ToastType::Warning,
                ));
                ftui::Cmd::none()
            }
            CassMsg::SavedViewRenameStarted => {
                if let Some(slot) = self.selected_saved_view_slot() {
                    self.saved_view_drag = None;
                    self.saved_view_rename_mode = true;
                    self.saved_view_rename_buffer =
                        self.selected_saved_view_label().unwrap_or_default();
                    self.status = format!("Renaming slot {slot}. Enter to save.");
                } else {
                    self.status = "No saved view selected".to_string();
                }
                ftui::Cmd::none()
            }
            CassMsg::SavedViewRenameCommitted => {
                use crate::ui::components::toast::{Toast, ToastType};
                if let Some(view) = self.saved_views.get_mut(self.saved_views_selection) {
                    let slot = view.slot;
                    let trimmed = self.saved_view_rename_buffer.trim();
                    if trimmed.is_empty() {
                        view.label = None;
                        self.status = format!("Cleared label for slot {slot}");
                        self.toast_manager.push(Toast::new(
                            format!("Cleared label for slot {slot}"),
                            ToastType::Success,
                        ));
                    } else {
                        view.label = Some(trimmed.to_string());
                        self.status = format!("Renamed slot {slot} to \"{trimmed}\"");
                        self.toast_manager.push(Toast::new(
                            format!("Renamed slot {slot}"),
                            ToastType::Success,
                        ));
                    }
                    self.saved_view_rename_mode = false;
                    self.saved_view_drag = None;
                    self.saved_view_rename_buffer.clear();
                    self.dirty_since = Some(Instant::now());
                } else {
                    self.saved_view_rename_mode = false;
                    self.saved_view_drag = None;
                    self.saved_view_rename_buffer.clear();
                    self.status = "No saved view selected".to_string();
                }
                ftui::Cmd::none()
            }
            CassMsg::SavedViewDeletedSelected => {
                use crate::ui::components::toast::{Toast, ToastType};
                if let Some(slot) = self.selected_saved_view_slot() {
                    self.saved_views.retain(|v| v.slot != slot);
                    self.clamp_saved_views_selection();
                    self.saved_view_drag = None;
                    self.saved_view_rename_mode = false;
                    self.saved_view_rename_buffer.clear();
                    self.dirty_since = Some(Instant::now());
                    self.status = format!("Deleted saved view slot {slot}");
                    self.toast_manager.push(Toast::new(
                        format!("Deleted slot {slot}"),
                        ToastType::Warning,
                    ));
                } else {
                    self.status = "No saved view selected".to_string();
                }
                ftui::Cmd::none()
            }
            CassMsg::SavedViewsCleared => {
                use crate::ui::components::toast::{Toast, ToastType};
                let count = self.saved_views.len();
                self.saved_views.clear();
                self.saved_views_selection = 0;
                self.saved_view_drag = None;
                self.saved_view_rename_mode = false;
                self.saved_view_rename_buffer.clear();
                self.dirty_since = Some(Instant::now());
                self.status = format!("Cleared {count} saved view(s)");
                self.toast_manager.push(Toast::new(
                    format!("Cleared {count} saved view(s)"),
                    ToastType::Warning,
                ));
                ftui::Cmd::none()
            }
            CassMsg::ViewSaved(slot) => {
                use crate::ui::components::toast::{Toast, ToastType};
                let preserved_label = self
                    .saved_views
                    .iter()
                    .find(|v| v.slot == slot)
                    .and_then(|v| v.label.clone());
                let view = SavedView {
                    slot,
                    label: preserved_label,
                    agents: self.filters.agents.clone(),
                    workspaces: self.filters.workspaces.clone(),
                    created_from: self.filters.created_from,
                    created_to: self.filters.created_to,
                    ranking: self.ranking_mode,
                    source_filter: self.filters.source_filter.clone(),
                };
                // Replace existing slot or push
                let mut replaced = false;
                if let Some(existing) = self.saved_views.iter_mut().find(|v| v.slot == slot) {
                    *existing = view;
                    replaced = true;
                } else {
                    self.saved_views.push(view);
                }
                self.sort_saved_views();
                if let Some(idx) = self.saved_views.iter().position(|v| v.slot == slot) {
                    self.saved_views_selection = idx;
                }
                self.dirty_since = Some(Instant::now());
                let verb = if replaced { "Updated" } else { "Saved" };
                self.status = format!("{verb} current view to slot {slot}");
                self.toast_manager.push(Toast::new(
                    format!("{verb} slot {slot}"),
                    ToastType::Success,
                ));
                ftui::Cmd::none()
            }
            CassMsg::ViewLoaded(slot) => {
                use crate::ui::components::toast::{Toast, ToastType};
                if let Some(view) = self.saved_views.iter().find(|v| v.slot == slot).cloned() {
                    self.push_undo("Load saved view");
                    self.filters.agents = view.agents.clone();
                    self.filters.workspaces = view.workspaces.clone();
                    self.filters.created_from = view.created_from;
                    self.filters.created_to = view.created_to;
                    self.ranking_mode = view.ranking;
                    self.filters.source_filter = view.source_filter.clone();
                    let modal_was_open = self.show_saved_views_modal;
                    self.show_saved_views_modal = false;
                    self.saved_view_drag = None;
                    self.saved_view_rename_mode = false;
                    self.saved_view_rename_buffer.clear();
                    if modal_was_open {
                        self.focus_manager.pop_trap();
                    }
                    let label = view
                        .label
                        .filter(|s| !s.trim().is_empty())
                        .unwrap_or_else(|| format!("slot {slot}"));
                    self.status = format!("Loaded saved view {label}");
                    self.toast_manager
                        .push(Toast::new(format!("Loaded {label}"), ToastType::Success));
                    return ftui::Cmd::msg(CassMsg::SearchRequested);
                }
                self.status = format!("No saved view in slot {slot}");
                self.toast_manager.push(Toast::new(
                    format!("Slot {slot} is empty"),
                    ToastType::Warning,
                ));
                ftui::Cmd::none()
            }

            // -- Index --------------------------------------------------------
            CassMsg::IndexRefreshRequested => {
                if self.index_refresh_in_flight {
                    self.status = "Index refresh already running".to_string();
                    return ftui::Cmd::none();
                }
                self.index_refresh_in_flight = true;
                self.set_loading_context(LoadingContext::IndexRefresh);
                self.status = "Refreshing index...".to_string();
                let data_dir = self.data_dir.clone();
                let db_path = self.db_path.clone();
                #[cfg(test)]
                {
                    let _ = data_dir;
                    let _ = db_path;
                    ftui::Cmd::task(|| CassMsg::IndexRefreshCompleted)
                }
                #[cfg(not(test))]
                {
                    ftui::Cmd::task(move || {
                        let opts = crate::indexer::IndexOptions {
                            full: false,
                            force_rebuild: false,
                            watch: false,
                            watch_once_paths: None,
                            db_path,
                            data_dir,
                            semantic: false,
                            build_hnsw: false,
                            embedder: "fastembed".to_string(),
                            progress: None,
                        };
                        match crate::indexer::run_index(opts, None) {
                            Ok(()) => CassMsg::IndexRefreshCompleted,
                            Err(e) => CassMsg::IndexRefreshFailed(e.to_string()),
                        }
                    })
                }
            }
            CassMsg::IndexProgress {
                processed,
                total,
                new_items,
            } => {
                if total > 0 {
                    self.status = format!("Indexing {processed}/{total} (+{new_items} new)");
                }
                ftui::Cmd::none()
            }
            CassMsg::IndexRefreshCompleted => {
                self.index_refresh_in_flight = false;
                self.clear_loading_context(LoadingContext::IndexRefresh);
                self.status = "Index refresh complete".to_string();
                ftui::Cmd::none()
            }
            CassMsg::IndexRefreshFailed(err) => {
                self.index_refresh_in_flight = false;
                self.clear_loading_context(LoadingContext::IndexRefresh);
                self.status = format!("Index refresh failed: {err}");
                ftui::Cmd::none()
            }

            // -- State persistence --------------------------------------------
            CassMsg::StateLoadRequested => {
                self.set_loading_context(LoadingContext::StateLoad);
                let state_path = self.state_file_path();
                ftui::Cmd::task(move || match load_persisted_state_from_path(&state_path) {
                    Ok(Some(state)) => CassMsg::StateLoaded(Box::new(state)),
                    Ok(None) => CassMsg::StateLoaded(Box::new(persisted_state_defaults())),
                    Err(e) => CassMsg::StateLoadFailed(e),
                })
            }
            CassMsg::StateLoaded(state) => {
                self.clear_loading_context(LoadingContext::StateLoad);
                self.search_mode = state.search_mode;
                self.match_mode = state.match_mode;
                self.ranking_mode = state.ranking_mode;
                self.context_window = state.context_window;
                // If theme.json has an explicit preset, it is the source of truth.
                // Otherwise fall back to legacy dark/light persisted state.
                if let Some(config) = self.theme_config.as_ref() {
                    if let Some(preset) = config.base_preset {
                        self.theme_preset = preset;
                        self.theme_dark = !matches!(preset, UiThemePreset::Light);
                    } else {
                        self.theme_dark = state.theme_dark;
                        self.theme_preset = if self.theme_dark {
                            UiThemePreset::Dark
                        } else {
                            UiThemePreset::Light
                        };
                    }
                } else {
                    self.theme_dark = state.theme_dark;
                    self.theme_preset = if self.theme_dark {
                        UiThemePreset::Dark
                    } else {
                        UiThemePreset::Light
                    };
                }
                self.style_options.dark_mode = self.theme_dark;
                self.style_options.preset = self.theme_preset;
                self.density_mode = state.density_mode;
                self.per_pane_limit = state.per_pane_limit;
                self.query_history = state.query_history;
                self.saved_views = state.saved_views;
                self.analytics_filters.since_ms = state.analytics_since_ms;
                self.analytics_filters.until_ms = state.analytics_until_ms;
                self.analytics_filters.agents = state.analytics_agents;
                self.analytics_filters.workspaces = state.analytics_workspaces;
                self.analytics_filters.source_filter = state.analytics_source_filter;
                self.sort_saved_views();
                self.clamp_saved_views_selection();
                self.fancy_borders = state.fancy_borders;
                self.help_pinned = state.help_pinned;
                // Re-open help if the user pinned it, or on first run so key
                // hints are immediately discoverable.
                let should_show_help = state.help_pinned || !state.has_seen_help;
                self.show_help = should_show_help;
                self.help_scroll = 0;
                self.has_seen_help = state.has_seen_help || should_show_help;
                if should_show_help && !state.has_seen_help {
                    // Persist first-run auto-help dismissal state.
                    self.dirty_since = Some(Instant::now());
                }
                if should_show_help {
                    if self.focus_manager.current() != Some(focus_ids::HELP_OVERLAY) {
                        self.focus_manager.push_trap(focus_ids::GROUP_HELP);
                    }
                    self.focus_manager.focus(focus_ids::HELP_OVERLAY);
                }
                self.dirty_since = None;
                ftui::Cmd::none()
            }
            CassMsg::StateLoadFailed(err) => {
                self.clear_loading_context(LoadingContext::StateLoad);
                self.status = format!("Failed to load TUI state: {err}");
                ftui::Cmd::none()
            }
            CassMsg::StateSaveRequested => {
                let state_path = self.state_file_path();
                let snapshot = self.capture_persisted_state();
                self.dirty_since = None;
                ftui::Cmd::task(move || {
                    match save_persisted_state_to_path(&state_path, &snapshot) {
                        Ok(()) => CassMsg::StateSaved,
                        Err(e) => CassMsg::StateSaveFailed(e),
                    }
                })
            }
            CassMsg::StateSaved => ftui::Cmd::none(),
            CassMsg::StateSaveFailed(err) => {
                self.status = format!("Failed to save TUI state: {err}");
                ftui::Cmd::none()
            }
            CassMsg::StateResetRequested => {
                let state_path = self.state_file_path();
                let data_dir = self.data_dir.clone();
                let db_path = self.db_path.clone();
                let search_service = self.search_service.clone();
                let db_reader = self.db_reader.clone();
                let known_workspaces = self.known_workspaces.clone();
                let reset = CassApp {
                    data_dir,
                    db_path,
                    search_service,
                    db_reader,
                    known_workspaces,
                    ..CassApp::default()
                };
                *self = reset;
                // Re-resolve theme from the real data dir after reset so
                // custom theme.json remains authoritative.
                self.refresh_theme_config_from_data_dir();
                if let Err(e) = clear_persisted_state_file(&state_path) {
                    self.status = format!("State reset in-memory, but failed to remove file: {e}");
                } else {
                    self.status = "Reset TUI state to defaults".to_string();
                }
                ftui::Cmd::none()
            }

            // -- Toast notifications ------------------------------------------
            CassMsg::ToastShown {
                message,
                toast_type,
            } => {
                self.toast_manager
                    .push(crate::ui::components::toast::Toast::new(
                        message, toast_type,
                    ));
                ftui::Cmd::none()
            }
            CassMsg::ToastTick => {
                self.toast_manager.tick();
                ftui::Cmd::none()
            }

            // -- Window & terminal --------------------------------------------
            CassMsg::Resized { width, height } => {
                // Frame dimensions update automatically via ftui runtime
                self.pane_split_drag = None;
                self.last_terminal_size.set((width.max(1), height.max(1)));
                // Capture latest resize evidence after coalescer processes the event.
                self.evidence.refresh();
                ftui::Cmd::none()
            }
            CassMsg::TerminalFocusChanged(gained) => {
                self.terminal_focused = gained;
                ftui::Cmd::none()
            }
            CassMsg::Tick => {
                self.spinner_frame = self.spinner_frame.wrapping_add(1);
                let now = Instant::now();
                let dt = now.duration_since(self.last_tick);
                self.last_tick = now;
                // Apply scroll targets computed during rendering (e.g. jump to the
                // selected session hit after the Messages view builds hit anchors).
                if self.show_detail_modal {
                    if let Some(target) = self.detail_pending_scroll_to.get() {
                        self.detail_pending_scroll_to.set(None);
                        self.detail_scroll = target;
                    }
                } else {
                    self.detail_pending_scroll_to.set(None);
                }
                // Record frame interval for inspector overlay.
                if self.show_inspector {
                    self.frame_timing.record_frame();
                    // Refresh evidence snapshots from runtime telemetry.
                    self.evidence.refresh();
                    // Sync cockpit data contracts from evidence.
                    if self.cockpit.enabled {
                        self.evidence.sync_cockpit(&mut self.cockpit);
                    }
                }
                // Tick spring-based animations.
                self.anim.tick(dt);
                if self
                    .view_transition
                    .as_ref()
                    .is_some_and(|transition| transition.is_done(now))
                {
                    self.view_transition = None;
                }
                // Drive modal_open spring target from current modal state.
                let any_modal = self.show_export_modal
                    || self.show_bulk_modal
                    || self.show_saved_views_modal
                    || self.show_detail_modal
                    || self.show_help
                    || self.show_theme_editor
                    || self.show_inspector
                    || self.source_filter_menu_open
                    || self.command_palette.is_visible();
                if any_modal {
                    self.anim.open_modal();
                } else {
                    self.anim.close_modal();
                }
                // Clear expired legacy flash indicators.
                if self.focus_flash_until.is_some_and(|t| now > t) {
                    self.focus_flash_until = None;
                }
                if self.peek_badge_until.is_some_and(|t| now > t) {
                    self.peek_badge_until = None;
                }
                // Poll update-check channel once per tick.
                let mut update_check_done = false;
                let mut update_info_ready: Option<UpdateInfo> = None;
                if let Some(rx) = self.update_check_rx.as_ref() {
                    match rx.try_recv() {
                        Ok(info) => {
                            update_check_done = true;
                            update_info_ready = info;
                        }
                        Err(std::sync::mpsc::TryRecvError::Disconnected) => {
                            update_check_done = true;
                        }
                        Err(std::sync::mpsc::TryRecvError::Empty) => {}
                    }
                }
                if update_check_done {
                    self.update_check_rx = None;
                }

                let mut cmds = Vec::new();
                if let Some(info) = update_info_ready {
                    cmds.push(ftui::Cmd::msg(CassMsg::UpdateCheckCompleted(info)));
                }
                // Debounced search-as-you-type: fire SearchRequested once the
                // debounce window (60ms) has elapsed since the last query change.
                if let Some(dirty_ts) = self.search_dirty_since
                    && dirty_ts.elapsed() >= SEARCH_DEBOUNCE
                {
                    // Never overlap searches: if a search is already in-flight,
                    // leave `search_dirty_since` set and let SearchCompleted/Failed
                    // schedule the next attempt once the current request finishes.
                    if !self.search_in_flight {
                        cmds.push(ftui::Cmd::msg(CassMsg::SearchRequested));
                    }
                }
                if let Some(dirty_ts) = self.dirty_since
                    && dirty_ts.elapsed() >= STATE_SAVE_DEBOUNCE
                {
                    self.dirty_since = None;
                    cmds.push(ftui::Cmd::msg(CassMsg::StateSaveRequested));
                }
                cmds.push(ftui::Cmd::msg(CassMsg::ToastTick));
                // Advance macro playback and inject events as messages.
                if let Some(ref mut playback) = self.macro_playback {
                    let events = playback.advance(dt);
                    for event in events {
                        let msg = CassMsg::from(event);
                        cmds.push(ftui::Cmd::msg(msg));
                    }
                    if playback.is_done() {
                        self.macro_playback = None;
                        self.toast_manager
                            .push(crate::ui::components::toast::Toast::success(
                                "Macro playback complete",
                            ));
                        self.status = "Macro playback finished".to_string();
                    }
                }
                // Pick up screenshot buffer captured during view().
                if let Some((format, content)) = self.screenshot_result.borrow_mut().take() {
                    self.screenshot_pending = None;
                    cmds.push(write_screenshot_file(format, content));
                }
                if cmds.len() == 1 {
                    return cmds.remove(0);
                }
                ftui::Cmd::batch(cmds)
            }
            CassMsg::MouseEvent { kind, x, y } => {
                // ── Drag jitter filter ──────────────────────────────
                // Suppress LeftDrag events where the pointer hasn't moved enough
                // to matter. This eliminates touchpad/sub-cell noise.
                if kind == MouseEventKind::LeftDrag
                    && let Some((lx, ly)) = self.last_mouse_pos
                {
                    let dx = (x as i32 - lx as i32).unsigned_abs() as u16;
                    let dy = (y as i32 - ly as i32).unsigned_abs() as u16;
                    if dx < DRAG_JITTER_THRESHOLD && dy < DRAG_JITTER_THRESHOLD {
                        return ftui::Cmd::none(); // sub-threshold motion
                    }
                }
                // Update last-known mouse position for future jitter checks.
                match kind {
                    MouseEventKind::LeftClick | MouseEventKind::LeftDrag => {
                        self.last_mouse_pos = Some((x, y));
                    }
                    MouseEventKind::LeftRelease => {
                        self.last_mouse_pos = None;
                        self.drag_hover_settled_at = None;
                    }
                    _ => {}
                }

                let region = self.hit_test(x, y);

                if self.show_saved_views_modal {
                    match (kind, region) {
                        (MouseEventKind::LeftClick, MouseHitRegion::SavedViewRow { row_idx }) => {
                            let idx = row_idx.min(self.saved_views.len().saturating_sub(1));
                            self.saved_views_selection = idx;
                            self.saved_view_drag = Some(SavedViewDragState {
                                from_idx: idx,
                                hover_idx: idx,
                            });
                            return ftui::Cmd::none();
                        }
                        (MouseEventKind::LeftDrag, MouseHitRegion::SavedViewRow { row_idx }) => {
                            let idx = row_idx.min(self.saved_views.len().saturating_sub(1));
                            if let Some(drag) = self.saved_view_drag.as_mut() {
                                // Hover stabilization: only update if pointer has
                                // remained on the new row long enough to settle.
                                if idx != drag.hover_idx {
                                    let now = Instant::now();
                                    let settled = self.drag_hover_settled_at.is_some_and(|t| {
                                        t.elapsed() >= Duration::from_millis(DRAG_HOVER_SETTLE_MS)
                                    });
                                    if settled {
                                        drag.hover_idx = idx;
                                        self.saved_views_selection = idx;
                                        self.drag_hover_settled_at = Some(now);
                                    } else if self.drag_hover_settled_at.is_none() {
                                        self.drag_hover_settled_at = Some(now);
                                    }
                                }
                            }
                            return ftui::Cmd::none();
                        }
                        (MouseEventKind::LeftDrag, _) => return ftui::Cmd::none(),
                        (MouseEventKind::LeftRelease, MouseHitRegion::SavedViewRow { row_idx }) => {
                            if let Some(drag) = self.saved_view_drag.take() {
                                let to_idx = row_idx.min(self.saved_views.len().saturating_sub(1));
                                if self.reorder_saved_views(drag.from_idx, to_idx) {
                                    self.status =
                                        format!("Moved saved view to position {}", to_idx + 1);
                                    self.dirty_since = Some(Instant::now());
                                }
                            }
                            return ftui::Cmd::none();
                        }
                        (MouseEventKind::LeftRelease, _) => {
                            self.saved_view_drag = None;
                            return ftui::Cmd::none();
                        }
                        _ => return ftui::Cmd::none(),
                    }
                }

                if kind == MouseEventKind::LeftClick
                    && !matches!(region, MouseHitRegion::SplitHandle)
                {
                    self.pane_split_drag = None;
                }

                match (kind, region) {
                    // ── Pane split drag: click + drag divider ───────
                    (MouseEventKind::LeftClick, MouseHitRegion::SplitHandle) => {
                        self.pane_split_drag = Some(PaneSplitDragState);
                        let _ = self.apply_panel_ratio_from_mouse_x(x);
                        ftui::Cmd::none()
                    }
                    // ── Left click on a filter pill: edit that filter ──
                    (MouseEventKind::LeftClick, MouseHitRegion::Pill { index }) => {
                        let pill = {
                            let rects = self.last_pill_rects.borrow();
                            rects.get(index).map(|(_, pill)| pill.clone())
                        };
                        if let Some(pill) = pill {
                            match pill.label.as_str() {
                                "agent" => {
                                    self.input_mode = InputMode::Agent;
                                    self.input_buffer = if self.filters.agents.len() == 1 {
                                        self.filters
                                            .agents
                                            .iter()
                                            .next()
                                            .cloned()
                                            .unwrap_or_default()
                                    } else {
                                        String::new()
                                    };
                                    self.status =
                                        "Edit agent filter (Enter apply, Esc cancel)".to_string();
                                }
                                "ws" => {
                                    self.input_mode = InputMode::Workspace;
                                    self.input_buffer = if self.filters.workspaces.len() == 1 {
                                        self.filters
                                            .workspaces
                                            .iter()
                                            .next()
                                            .cloned()
                                            .unwrap_or_default()
                                    } else {
                                        String::new()
                                    };
                                    self.status = "Edit workspace filter (Enter apply, Esc cancel)"
                                        .to_string();
                                }
                                "pane" => {
                                    self.input_mode = InputMode::PaneFilter;
                                    self.input_buffer =
                                        self.pane_filter.clone().unwrap_or_default();
                                    self.status =
                                        "Edit pane filter (Enter apply, Esc cancel)".to_string();
                                }
                                "time" => {
                                    self.input_mode = InputMode::CreatedFrom;
                                    self.input_buffer = self
                                        .filters
                                        .created_from
                                        .map(|ts| ts.to_string())
                                        .unwrap_or_default();
                                    self.status =
                                        "Edit from timestamp (Enter apply, Esc cancel)".to_string();
                                }
                                "source" => {
                                    self.source_filter_menu_open = true;
                                    self.source_filter_menu_selection =
                                        match &self.filters.source_filter {
                                            SourceFilter::All => 0,
                                            SourceFilter::Local => 1,
                                            SourceFilter::Remote => 2,
                                            SourceFilter::SourceId(id) => self
                                                .available_source_ids
                                                .iter()
                                                .position(|s| s == id)
                                                .map(|i| i + 3)
                                                .unwrap_or(0),
                                        };
                                    self.focus_manager.push_trap(focus_ids::GROUP_SOURCE_FILTER);
                                    self.focus_manager.focus(focus_ids::SOURCE_FILTER_MENU);
                                    self.status = "Choose source filter".to_string();
                                }
                                _ => {}
                            }
                            if matches!(pill.label.as_str(), "agent" | "ws" | "pane" | "time") {
                                self.focus_manager.focus(focus_ids::SEARCH_BAR);
                            }
                        }
                        ftui::Cmd::none()
                    }
                    // ── Right click on a filter pill: clear that filter ──
                    (MouseEventKind::RightClick, MouseHitRegion::Pill { index }) => {
                        let pill = {
                            let rects = self.last_pill_rects.borrow();
                            rects.get(index).map(|(_, pill)| pill.clone())
                        };
                        let mut changed = false;
                        if let Some(pill) = pill {
                            match pill.label.as_str() {
                                "agent" if !self.filters.agents.is_empty() => {
                                    self.push_undo("Clear agent filter");
                                    self.filters.agents.clear();
                                    self.status = "Cleared agent filter".to_string();
                                    changed = true;
                                }
                                "ws" if !self.filters.workspaces.is_empty() => {
                                    self.push_undo("Clear workspace filter");
                                    self.filters.workspaces.clear();
                                    self.status = "Cleared workspace filter".to_string();
                                    changed = true;
                                }
                                "pane" if self.pane_filter.is_some() => {
                                    self.pane_filter = None;
                                    self.status = "Cleared pane filter".to_string();
                                    changed = true;
                                }
                                "time"
                                    if self.filters.created_from.is_some()
                                        || self.filters.created_to.is_some() =>
                                {
                                    self.push_undo("Clear time filter");
                                    self.filters.created_from = None;
                                    self.filters.created_to = None;
                                    self.time_preset = TimePreset::All;
                                    self.status = "Cleared time filter".to_string();
                                    changed = true;
                                }
                                "source" if !self.filters.source_filter.is_all() => {
                                    self.push_undo("Clear source filter");
                                    self.filters.source_filter = SourceFilter::All;
                                    self.status = "Cleared source filter".to_string();
                                    changed = true;
                                }
                                _ => {}
                            }
                        }
                        if changed {
                            self.search_dirty_since = Some(Instant::now());
                            self.cached_detail = None;
                        }
                        ftui::Cmd::none()
                    }
                    (MouseEventKind::LeftDrag, _) if self.pane_split_drag.is_some() => {
                        let _ = self.apply_panel_ratio_from_mouse_x(x);
                        ftui::Cmd::none()
                    }
                    (MouseEventKind::LeftRelease, _) => {
                        self.pane_split_drag = None;
                        ftui::Cmd::none()
                    }
                    // ── Scroll in results ────────────────────────────
                    (MouseEventKind::ScrollUp, MouseHitRegion::Results { pane_idx, .. }) => {
                        if pane_idx < self.panes.len() && pane_idx != self.active_pane {
                            self.active_pane = pane_idx;
                            if let Some(pane) = self.panes.get(self.active_pane) {
                                self.results_list_state
                                    .borrow_mut()
                                    .select(Some(pane.selected));
                            }
                            self.adjust_pane_scroll_offset();
                        }
                        self.enter_results_navigation_context();
                        ftui::Cmd::msg(CassMsg::SelectionMoved { delta: -3 })
                    }
                    (MouseEventKind::ScrollDown, MouseHitRegion::Results { pane_idx, .. }) => {
                        if pane_idx < self.panes.len() && pane_idx != self.active_pane {
                            self.active_pane = pane_idx;
                            if let Some(pane) = self.panes.get(self.active_pane) {
                                self.results_list_state
                                    .borrow_mut()
                                    .select(Some(pane.selected));
                            }
                            self.adjust_pane_scroll_offset();
                        }
                        self.enter_results_navigation_context();
                        ftui::Cmd::msg(CassMsg::SelectionMoved { delta: 3 })
                    }
                    // ── Scroll in detail ─────────────────────────────
                    (MouseEventKind::ScrollUp, MouseHitRegion::Detail) => {
                        ftui::Cmd::msg(CassMsg::DetailScrolled { delta: -3 })
                    }
                    (MouseEventKind::ScrollDown, MouseHitRegion::Detail) => {
                        ftui::Cmd::msg(CassMsg::DetailScrolled { delta: 3 })
                    }
                    // ── Hover in results: track hovered row ─────────
                    (MouseEventKind::Moved, MouseHitRegion::Results { item_idx, .. }) => {
                        let hit_count = self
                            .panes
                            .get(self.active_pane)
                            .map_or(self.results.len(), |p| p.hits.len());
                        let new_hover = if item_idx < hit_count {
                            Some(item_idx)
                        } else {
                            None
                        };
                        if self.hovered_result != new_hover {
                            self.hovered_result = new_hover;
                        }
                        ftui::Cmd::none()
                    }
                    // ── Hover outside results: clear hover ──────────
                    (MouseEventKind::Moved, _) => {
                        if self.hovered_result.is_some() {
                            self.hovered_result = None;
                        }
                        ftui::Cmd::none()
                    }
                    // ── Left click in results: select item ──────────
                    (MouseEventKind::LeftClick, MouseHitRegion::Results { pane_idx, item_idx }) => {
                        if pane_idx < self.panes.len() && pane_idx != self.active_pane {
                            self.active_pane = pane_idx;
                            if let Some(pane) = self.panes.get(self.active_pane) {
                                self.results_list_state
                                    .borrow_mut()
                                    .select(Some(pane.selected));
                            }
                            self.adjust_pane_scroll_offset();
                        }
                        self.enter_results_navigation_context();
                        let hit_count = self
                            .panes
                            .get(pane_idx)
                            .map_or(self.results.len(), |p| p.hits.len());
                        if item_idx < hit_count {
                            // Compute delta from current selection to clicked row.
                            let current =
                                self.panes.get(self.active_pane).map_or(0, |p| p.selected);
                            let delta = item_idx as i32 - current as i32;
                            if delta != 0 {
                                ftui::Cmd::msg(CassMsg::SelectionMoved { delta })
                            } else {
                                // Clicking the already-selected row opens detail.
                                ftui::Cmd::msg(CassMsg::DetailOpened)
                            }
                        } else {
                            ftui::Cmd::none()
                        }
                    }
                    // ── Right click in results: toggle select ───────
                    (
                        MouseEventKind::RightClick,
                        MouseHitRegion::Results { pane_idx, item_idx },
                    ) => {
                        if pane_idx < self.panes.len() && pane_idx != self.active_pane {
                            self.active_pane = pane_idx;
                            if let Some(pane) = self.panes.get(self.active_pane) {
                                self.results_list_state
                                    .borrow_mut()
                                    .select(Some(pane.selected));
                            }
                            self.adjust_pane_scroll_offset();
                        }
                        self.enter_results_navigation_context();
                        let hit_count = self
                            .panes
                            .get(pane_idx)
                            .map_or(self.results.len(), |p| p.hits.len());
                        if item_idx < hit_count {
                            // Move to the row first, then toggle selection.
                            let current =
                                self.panes.get(self.active_pane).map_or(0, |p| p.selected);
                            let delta = item_idx as i32 - current as i32;
                            let mut cmds = Vec::new();
                            if delta != 0 {
                                cmds.push(ftui::Cmd::msg(CassMsg::SelectionMoved { delta }));
                            }
                            cmds.push(ftui::Cmd::msg(CassMsg::SelectionToggled));
                            ftui::Cmd::batch(cmds)
                        } else {
                            ftui::Cmd::none()
                        }
                    }
                    // ── Click in detail: focus detail pane ──────────
                    (MouseEventKind::LeftClick, MouseHitRegion::Detail) => {
                        if self.focused_region() != FocusRegion::Detail {
                            ftui::Cmd::msg(CassMsg::FocusToggled)
                        } else {
                            ftui::Cmd::none()
                        }
                    }
                    // ── Click in search bar: focus results (query) ──
                    (MouseEventKind::LeftClick, MouseHitRegion::SearchBar) => {
                        if self.focused_region() != FocusRegion::Results {
                            ftui::Cmd::msg(CassMsg::FocusToggled)
                        } else {
                            ftui::Cmd::none()
                        }
                    }
                    // ── Scroll outside tracked regions: default to results
                    (MouseEventKind::ScrollUp, _) => {
                        ftui::Cmd::msg(CassMsg::SelectionMoved { delta: -3 })
                    }
                    (MouseEventKind::ScrollDown, _) => {
                        ftui::Cmd::msg(CassMsg::SelectionMoved { delta: 3 })
                    }
                    // ── Unhandled clicks ─────────────────────────────
                    _ => ftui::Cmd::none(),
                }
            }

            // -- Analytics surface ---------------------------------------------
            CassMsg::AnalyticsEntered => {
                self.pane_split_drag = None;
                let previous_surface = self.surface;
                if self.surface != AppSurface::Analytics {
                    self.view_stack.push(self.surface);
                    self.surface = AppSurface::Analytics;
                    self.start_surface_transition(previous_surface, self.surface);
                }
                // Deferred load on entry so the UI can render a loading frame first.
                if self.analytics_cache.is_none() {
                    return self.schedule_analytics_reload();
                }
                ftui::Cmd::none()
            }
            CassMsg::AnalyticsLoadRequested => {
                if self.db_reader.is_none() {
                    self.clear_loading_context(LoadingContext::Analytics);
                    return ftui::Cmd::none();
                }
                let db_path = self.db_path.clone();
                let filters = self.analytics_filters.clone();
                let group_by = self.explorer_group_by;
                #[cfg(test)]
                {
                    let _ = (db_path, filters, group_by);
                    ftui::Cmd::task(|| CassMsg::AnalyticsChartDataLoaded(Box::default()))
                }
                #[cfg(not(test))]
                {
                    ftui::Cmd::task(move || {
                        match crate::storage::sqlite::SqliteStorage::open_readonly(&db_path) {
                            Ok(db) => {
                                let mut data = super::analytics_charts::load_chart_data(
                                    &db, &filters, group_by,
                                );

                                let should_auto_rebuild = if data.daily_tokens.is_empty() {
                                    match crate::analytics::query::query_status(
                                        db.raw(),
                                        &crate::analytics::AnalyticsFilter::default(),
                                    ) {
                                        Ok(status) => {
                                            status.coverage.total_messages > 0
                                                && (status
                                                    .recommended_action
                                                    .starts_with("rebuild")
                                                    || status.drift.signals.iter().any(|signal| {
                                                        matches!(
                                                            signal.signal.as_str(),
                                                            "missing_rollups" | "no_analytics_data"
                                                        )
                                                    }))
                                        }
                                        Err(_) => false,
                                    }
                                } else {
                                    false
                                };

                                if should_auto_rebuild {
                                    match crate::storage::sqlite::SqliteStorage::open(&db_path) {
                                        Ok(mut db_rw) => match db_rw.rebuild_analytics() {
                                            Ok(_) => {
                                                let mut refreshed =
                                                    super::analytics_charts::load_chart_data(
                                                        &db_rw, &filters, group_by,
                                                    );
                                                refreshed.auto_rebuilt = true;
                                                data = refreshed;
                                            }
                                            Err(err) => {
                                                data.auto_rebuild_error = Some(format!(
                                                    "analytics rebuild failed: {err}"
                                                ));
                                            }
                                        },
                                        Err(err) => {
                                            data.auto_rebuild_error =
                                                Some(format!("failed opening analytics DB: {err}"));
                                        }
                                    }
                                }

                                CassMsg::AnalyticsChartDataLoaded(Box::new(data))
                            }
                            Err(e) => CassMsg::AnalyticsChartDataFailed(e.to_string()),
                        }
                    })
                }
            }
            CassMsg::AnalyticsChartDataLoaded(data) => {
                if data.auto_rebuilt {
                    self.status = "Analytics data rebuilt automatically.".to_string();
                } else if let Some(err) = data.auto_rebuild_error.as_deref() {
                    self.status = format!("Automatic analytics rebuild failed: {err}");
                }
                self.analytics_cache = Some(*data);
                self.clear_loading_context(LoadingContext::Analytics);
                ftui::Cmd::none()
            }
            CassMsg::AnalyticsChartDataFailed(err) => {
                self.clear_loading_context(LoadingContext::Analytics);
                self.status = format!("Analytics load failed: {err}");
                ftui::Cmd::none()
            }
            CassMsg::AnalyticsViewChanged(view) => {
                let view = view.canonical();
                let previous_view = self.analytics_view;
                if previous_view != view {
                    self.analytics_view = view;
                    self.analytics_selection = 0; // reset selection on view change
                    self.start_analytics_view_transition(previous_view, view);
                }
                if self.surface == AppSurface::Analytics && self.analytics_cache.is_none() {
                    return self.schedule_analytics_reload();
                }
                ftui::Cmd::none()
            }
            CassMsg::ViewStackPopped => {
                self.pane_split_drag = None;
                let previous_surface = self.surface;
                if let Some(prev) = self.view_stack.pop() {
                    self.surface = prev;
                } else {
                    self.surface = AppSurface::Search;
                }
                self.start_surface_transition(previous_surface, self.surface);
                if self.surface != AppSurface::Analytics {
                    self.clear_loading_context(LoadingContext::Analytics);
                }
                ftui::Cmd::none()
            }
            CassMsg::AnalyticsTimeRangeSet { since_ms, until_ms } => {
                self.analytics_filters.since_ms = since_ms;
                self.analytics_filters.until_ms = until_ms;
                self.dirty_since = Some(Instant::now());
                self.analytics_cache = None; // invalidate chart data on filter change
                if self.surface == AppSurface::Analytics {
                    return self.schedule_analytics_reload();
                }
                ftui::Cmd::none()
            }
            CassMsg::AnalyticsAgentFilterSet(agents) => {
                self.analytics_filters.agents = agents;
                self.dirty_since = Some(Instant::now());
                self.analytics_cache = None;
                if self.surface == AppSurface::Analytics {
                    return self.schedule_analytics_reload();
                }
                ftui::Cmd::none()
            }
            CassMsg::AnalyticsWorkspaceFilterSet(workspaces) => {
                self.analytics_filters.workspaces = workspaces;
                self.dirty_since = Some(Instant::now());
                self.analytics_cache = None;
                if self.surface == AppSurface::Analytics {
                    return self.schedule_analytics_reload();
                }
                ftui::Cmd::none()
            }
            CassMsg::AnalyticsSourceFilterSet(sf) => {
                self.analytics_filters.source_filter = sf;
                self.dirty_since = Some(Instant::now());
                self.analytics_cache = None;
                if self.surface == AppSurface::Analytics {
                    return self.schedule_analytics_reload();
                }
                ftui::Cmd::none()
            }
            CassMsg::AnalyticsFiltersClearAll => {
                self.analytics_filters = AnalyticsFilterState::default();
                self.dirty_since = Some(Instant::now());
                self.analytics_cache = None;
                if self.surface == AppSurface::Analytics {
                    return self.schedule_analytics_reload();
                }
                ftui::Cmd::none()
            }
            CassMsg::AnalyticsSelectionMoved { delta } => {
                let count = self.analytics_selectable_count();
                if count > 0 {
                    let cur = self.analytics_selection as i32;
                    let next = (cur + delta).rem_euclid(count as i32) as usize;
                    self.analytics_selection = next;
                }
                ftui::Cmd::none()
            }
            CassMsg::AnalyticsDrilldown(ctx) => {
                let DrilldownContext {
                    since_ms,
                    until_ms,
                    agent,
                    workspace,
                    source_filter: drill_source_filter,
                    model,
                } = ctx;
                tracing::debug!(
                    since_ms = ?since_ms,
                    until_ms = ?until_ms,
                    agent = ?agent,
                    workspace = ?workspace,
                    source_filter = ?drill_source_filter,
                    model = ?model,
                    "analytics drilldown requested"
                );

                // Push analytics surface onto the back-stack.
                let previous_surface = self.surface;
                self.view_stack.push(AppSurface::Analytics);
                self.surface = AppSurface::Search;
                self.start_surface_transition(previous_surface, self.surface);

                // Convert drilldown context into search filters.
                self.filters.created_from = since_ms;
                self.filters.created_to = until_ms;

                // Start from analytics filters to avoid leaking stale search filters.
                self.filters.agents = self.analytics_filters.agents.clone();
                self.filters.workspaces = self.analytics_filters.workspaces.clone();
                self.filters.source_filter = self.analytics_filters.source_filter.clone();
                self.filters.session_paths.clear();

                // Apply selected dimension filter (agent) on top of inherited globals.
                if let Some(agent) = agent {
                    self.filters.agents.clear();
                    self.filters.agents.insert(agent);
                }
                // Apply selected workspace filter on top of inherited globals.
                if let Some(workspace) = workspace {
                    self.filters.workspaces.clear();
                    self.filters.workspaces.insert(workspace);
                }
                // Apply selected source filter on top of inherited globals.
                if let Some(source_filter) = drill_source_filter {
                    self.filters.source_filter = source_filter;
                }
                // Seed the query for model-driven drilldowns so analytics selections
                // immediately narrow to relevant sessions.
                self.query.clear();
                if let Some(ref model_name) = model {
                    self.query = model_name.clone();
                }
                self.cursor_pos = self.query.len();
                self.input_mode = InputMode::Query;

                let mut origin_parts = Vec::new();
                if let Some(ref agent) = self.filters.agents.iter().next()
                    && self.filters.agents.len() == 1
                {
                    origin_parts.push(format!("agent: {agent}"));
                }
                if let Some(ref workspace) = self.filters.workspaces.iter().next()
                    && self.filters.workspaces.len() == 1
                {
                    origin_parts.push(format!("workspace: {workspace}"));
                }
                if !self.filters.source_filter.is_all() {
                    origin_parts.push(format!("source: {}", self.filters.source_filter));
                }
                if let Some(model) = model.as_ref() {
                    origin_parts.push(format!("model: {model}"));
                }
                let suffix = if origin_parts.is_empty() {
                    String::new()
                } else {
                    format!(" ({})", origin_parts.join(", "))
                };
                self.status = format!("Drilldown from analytics{suffix} — type a query or browse");
                self.clear_loading_context(LoadingContext::Analytics);
                ftui::Cmd::msg(CassMsg::SearchRequested)
            }
            CassMsg::ExplorerMetricCycled { forward } => {
                self.explorer_metric = if forward {
                    self.explorer_metric.next()
                } else {
                    self.explorer_metric.prev()
                };
                ftui::Cmd::none()
            }
            CassMsg::ExplorerOverlayCycled => {
                self.explorer_overlay = self.explorer_overlay.next();
                ftui::Cmd::none()
            }
            CassMsg::ExplorerGroupByCycled { forward } => {
                self.explorer_group_by = if forward {
                    self.explorer_group_by.next()
                } else {
                    self.explorer_group_by.prev()
                };
                // Hourly timelines become noisy at broad ranges; selecting Hour
                // defaults Explorer to the most useful dense window.
                if self.explorer_group_by == crate::analytics::GroupBy::Hour {
                    self.explorer_zoom = ExplorerZoom::Week;
                    let (since_ms, until_ms) = self.explorer_zoom.to_range();
                    self.analytics_filters.since_ms = since_ms;
                    self.analytics_filters.until_ms = until_ms;
                    self.dirty_since = Some(Instant::now());
                    self.status = "Explorer set to Hourly (last 7 days).".to_string();
                }
                // Invalidate cache so timeseries reloads with new granularity.
                self.analytics_cache = None;
                if self.surface == AppSurface::Analytics {
                    return self.schedule_analytics_reload();
                }
                ftui::Cmd::none()
            }
            CassMsg::ExplorerZoomCycled { forward } => {
                self.explorer_zoom = if forward {
                    self.explorer_zoom.next()
                } else {
                    self.explorer_zoom.prev()
                };

                // Hourly granularity is constrained to short windows.
                if self.explorer_group_by == crate::analytics::GroupBy::Hour
                    && matches!(
                        self.explorer_zoom,
                        ExplorerZoom::All | ExplorerZoom::Month | ExplorerZoom::Quarter
                    )
                {
                    self.explorer_group_by = crate::analytics::GroupBy::Day;
                    self.status =
                        "Hourly Explorer supports up to 7 days; switched to Daily.".to_string();
                }

                let (since_ms, until_ms) = self.explorer_zoom.to_range();
                self.analytics_filters.since_ms = since_ms;
                self.analytics_filters.until_ms = until_ms;
                self.dirty_since = Some(Instant::now());
                self.analytics_cache = None;
                if self.surface == AppSurface::Analytics {
                    return self.schedule_analytics_reload();
                }
                ftui::Cmd::none()
            }
            CassMsg::BreakdownTabCycled { forward } => {
                self.breakdown_tab = if forward {
                    self.breakdown_tab.next()
                } else {
                    self.breakdown_tab.prev()
                };
                self.analytics_selection = 0; // reset selection on tab change
                ftui::Cmd::none()
            }
            CassMsg::HeatmapMetricCycled { forward } => {
                self.heatmap_metric = if forward {
                    self.heatmap_metric.next()
                } else {
                    self.heatmap_metric.prev()
                };
                ftui::Cmd::none()
            }

            // -- Sources management (2noh9.4.9) ----------------------------------
            CassMsg::SourcesEntered => {
                self.pane_split_drag = None;
                let previous_surface = self.surface;
                if self.surface != AppSurface::Sources {
                    self.view_stack.push(self.surface);
                    self.surface = AppSurface::Sources;
                    self.start_surface_transition(previous_surface, self.surface);
                }
                self.clear_loading_context(LoadingContext::Analytics);
                #[cfg(not(test))]
                self.load_sources_view();
                ftui::Cmd::none()
            }
            CassMsg::SourcesRefreshed => {
                #[cfg(not(test))]
                self.load_sources_view();
                self.sources_view.status = "Sources refreshed".into();
                ftui::Cmd::none()
            }
            CassMsg::SourcesSelectionMoved { delta } => {
                let count = self.sources_view.items.len();
                if count > 0 {
                    let cur = self.sources_view.selected as i32;
                    let next = (cur + delta).rem_euclid(count as i32) as usize;
                    self.sources_view.selected = next;
                }
                ftui::Cmd::none()
            }
            CassMsg::SourceSyncRequested(ref name) => {
                let name = name.clone();
                if let Some(item) = self.sources_view.items.iter_mut().find(|i| i.name == name) {
                    item.busy = true;
                }
                self.sources_view.status = format!("Syncing '{name}'...");

                // Spawn background sync task.
                let source_name = name.clone();
                let data_dir = self.data_dir.clone();
                #[cfg(not(test))]
                {
                    use crate::sources::{SourcesConfig, SyncEngine};
                    let config = SourcesConfig::load().unwrap_or_default();
                    if let Some(source_def) = config.find_source(&source_name) {
                        let source_def = source_def.clone();
                        ftui::Cmd::task(move || {
                            let engine = SyncEngine::new(&data_dir);
                            match engine.sync_source(&source_def) {
                                Ok(report) => {
                                    let msg = if report.all_succeeded {
                                        format!(
                                            "Sync '{}' OK: {} files, {} bytes",
                                            source_name,
                                            report.total_files(),
                                            report.total_bytes()
                                        )
                                    } else {
                                        format!(
                                            "Sync '{}' partial: {}/{} paths OK",
                                            source_name,
                                            report.successful_paths(),
                                            report.successful_paths() + report.failed_paths()
                                        )
                                    };
                                    CassMsg::SourceSyncCompleted {
                                        source_name,
                                        message: msg,
                                    }
                                }
                                Err(e) => CassMsg::SourceSyncCompleted {
                                    source_name,
                                    message: format!("Sync failed: {e}"),
                                },
                            }
                        })
                    } else {
                        self.sources_view.status =
                            format!("Source '{source_name}' not found in config");
                        ftui::Cmd::none()
                    }
                }
                #[cfg(test)]
                {
                    let _ = data_dir;
                    let _ = source_name;
                    ftui::Cmd::none()
                }
            }
            CassMsg::SourceSyncCompleted {
                ref source_name,
                ref message,
            } => {
                let source_name = source_name.clone();
                let message = message.clone();
                if let Some(item) = self
                    .sources_view
                    .items
                    .iter_mut()
                    .find(|i| i.name == source_name)
                {
                    item.busy = false;
                }
                self.sources_view.status = message;
                ftui::Cmd::none()
            }
            CassMsg::SourceDoctorRequested(ref name) => {
                let name = name.clone();
                if let Some(item) = self.sources_view.items.iter_mut().find(|i| i.name == name) {
                    item.busy = true;
                }
                self.sources_view.status = format!("Running doctor on '{name}'...");

                // Spawn background doctor/probe task.
                let source_name = name.clone();
                #[cfg(not(test))]
                {
                    use crate::sources::{DiscoveredHost, SourcesConfig, probe_host};
                    let config = SourcesConfig::load().unwrap_or_default();
                    if let Some(source_def) = config.find_source(&source_name) {
                        let host_str = source_def
                            .host
                            .clone()
                            .unwrap_or_else(|| source_name.clone());
                        ftui::Cmd::task(move || {
                            let host = DiscoveredHost {
                                name: host_str,
                                hostname: None,
                                user: None,
                                port: None,
                                identity_file: None,
                            };
                            let result = probe_host(&host, 15);
                            let mut passed = 0usize;
                            let mut warnings = 0usize;
                            let mut failed = 0usize;

                            // SSH reachable?
                            if result.reachable {
                                passed += 1;
                            } else {
                                failed += 1;
                            }
                            // Cass installed?
                            if result.has_cass() {
                                passed += 1;
                            } else {
                                warnings += 1;
                            }
                            // Agent data present?
                            if result.has_agent_data() {
                                passed += 1;
                            } else {
                                warnings += 1;
                            }
                            // Disk space available?
                            if let Some(ref res) = result.resources {
                                if res.disk_available_mb >= 1024 {
                                    passed += 1;
                                } else {
                                    warnings += 1;
                                }
                            }

                            CassMsg::SourceDoctorCompleted {
                                source_name,
                                passed,
                                warnings,
                                failed,
                            }
                        })
                    } else {
                        self.sources_view.status =
                            format!("Source '{source_name}' not found in config");
                        ftui::Cmd::none()
                    }
                }
                #[cfg(test)]
                {
                    let _ = source_name;
                    ftui::Cmd::none()
                }
            }
            CassMsg::SourceDoctorCompleted {
                ref source_name,
                passed,
                warnings,
                failed,
            } => {
                let source_name = source_name.clone();
                if let Some(item) = self
                    .sources_view
                    .items
                    .iter_mut()
                    .find(|i| i.name == source_name)
                {
                    item.busy = false;
                    item.doctor_summary = Some((passed, warnings, failed));
                }
                self.sources_view.status = format!(
                    "Doctor '{source_name}': {passed} pass, {warnings} warn, {failed} fail"
                );
                ftui::Cmd::none()
            }

            // -- Lifecycle ----------------------------------------------------
            CassMsg::QuitRequested => {
                // ESC unwind: check pending state before quitting
                // If on analytics or sources surface, pop back.
                if self.surface == AppSurface::Analytics || self.surface == AppSurface::Sources {
                    return ftui::Cmd::msg(CassMsg::ViewStackPopped);
                }
                if self.show_consent_dialog {
                    self.show_consent_dialog = false;
                    self.focus_manager.pop_trap();
                    return ftui::Cmd::none();
                }
                if self.show_theme_editor {
                    self.show_theme_editor = false;
                    self.theme_editor = None;
                    return ftui::Cmd::none();
                }
                if self.show_inspector {
                    self.show_inspector = false;
                    if self.inspector_state.is_active() {
                        self.inspector_state.toggle();
                    }
                    return ftui::Cmd::none();
                }
                if self.show_export_modal {
                    self.show_export_modal = false;
                    self.export_modal_state = None;
                    self.focus_manager.pop_trap();
                    return ftui::Cmd::none();
                }
                if self.show_bulk_modal {
                    self.show_bulk_modal = false;
                    self.focus_manager.pop_trap();
                    return ftui::Cmd::none();
                }
                if self.show_saved_views_modal {
                    if self.saved_view_rename_mode {
                        self.saved_view_rename_mode = false;
                        self.saved_view_rename_buffer.clear();
                        self.saved_view_drag = None;
                        self.status = "Cancelled saved view rename".to_string();
                    } else {
                        self.show_saved_views_modal = false;
                        self.saved_view_drag = None;
                        self.status = "Saved views manager closed".to_string();
                        self.focus_manager.pop_trap();
                    }
                    return ftui::Cmd::none();
                }
                if self.source_filter_menu_open {
                    self.source_filter_menu_open = false;
                    self.focus_manager.pop_trap();
                    return ftui::Cmd::none();
                }
                if self.command_palette.is_visible() {
                    self.command_palette.close();
                    self.show_palette_evidence = false;
                    self.palette_latency.bench_mode = false;
                    self.palette_latency.bench_start = None;
                    self.focus_manager.pop_trap();
                    return ftui::Cmd::none();
                }
                if self.show_help {
                    self.show_help = false;
                    self.focus_manager.pop_trap();
                    return ftui::Cmd::none();
                }
                if self.show_detail_modal {
                    return self.update(CassMsg::DetailClosed);
                }
                if self.detail_find.is_some() {
                    self.detail_find = None;
                    return ftui::Cmd::none();
                }
                if self.pane_filter.is_some() {
                    self.pane_filter = None;
                    self.input_mode = InputMode::Query;
                    return ftui::Cmd::none();
                }
                if !self.selected.is_empty() {
                    let count = self.selected.len();
                    self.selected.clear();
                    self.open_confirm_armed = false;
                    self.status = format!("Cleared {count} selections");
                    return ftui::Cmd::none();
                }
                if self.input_mode != InputMode::Query {
                    self.input_mode = InputMode::Query;
                    self.input_buffer.clear();
                    return ftui::Cmd::none();
                }
                if self.dirty_since.is_some() {
                    let state_path = self.state_file_path();
                    let snapshot = self.capture_persisted_state();
                    if let Err(err) = save_persisted_state_to_path(&state_path, &snapshot) {
                        self.status = format!("Failed to save TUI state before quit: {err}");
                    } else {
                        self.dirty_since = None;
                    }
                }
                ftui::Cmd::quit()
            }
            // -- Macro recording/playback -----------------------------------------
            CassMsg::MacroRecordingToggled => {
                if let Some(recorder) = self.macro_recorder.take() {
                    // Stop recording and save.
                    let recorded = recorder.finish();
                    let macro_dir = macro_save_dir();
                    if let Err(e) = std::fs::create_dir_all(&macro_dir) {
                        self.toast_manager
                            .push(crate::ui::components::toast::Toast::error(format!(
                                "Failed to create macro dir: {e}"
                            )));
                        return ftui::Cmd::none();
                    }
                    let filename = format!(
                        "cass-macro-{}.jsonl",
                        chrono::Local::now().format("%Y%m%d-%H%M%S")
                    );
                    let path = macro_dir.join(&filename);
                    match macro_file::save_macro(&path, &recorded, self.macro_redact_paths) {
                        Ok(()) => {
                            self.toast_manager
                                .push(crate::ui::components::toast::Toast::success(format!(
                                    "Macro saved ({} events): {}",
                                    recorded.len(),
                                    path.display()
                                )));
                            self.status = format!("Macro saved: {}", path.display());
                        }
                        Err(e) => {
                            self.toast_manager
                                .push(crate::ui::components::toast::Toast::error(format!(
                                    "Failed to save macro: {e}"
                                )));
                        }
                    }
                } else {
                    // Start recording.
                    let mut recorder = MacroRecorder::new("cass-interactive");
                    // Use the most recently observed terminal size for metadata.
                    let (w, h) = self.last_terminal_size.get();
                    recorder = recorder.with_terminal_size(w, h);
                    self.macro_recorder = Some(recorder);
                    self.toast_manager
                        .push(crate::ui::components::toast::Toast::info(
                            "Macro recording started (Alt+M to stop)",
                        ));
                    self.status = "Recording macro...".to_string();
                }
                ftui::Cmd::none()
            }
            CassMsg::MacroRecordingSaved(path) => {
                self.status = format!("Macro saved: {}", path.display());
                ftui::Cmd::none()
            }
            CassMsg::MacroRecordingFailed(err) => {
                self.toast_manager
                    .push(crate::ui::components::toast::Toast::error(format!(
                        "Macro error: {err}"
                    )));
                ftui::Cmd::none()
            }

            CassMsg::ForceQuit => ftui::Cmd::quit(),
        }
    }

    fn view(&self, frame: &mut super::ftui_adapter::Frame) {
        let area = Rect::from_size(frame.buffer.width(), frame.buffer.height());
        self.last_terminal_size
            .set((area.width.max(1), area.height.max(1)));
        if area.is_empty() {
            return;
        }

        // Ultra-narrow fallback: show a compact message for terminals too
        // small to render any meaningful UI. Prevents layout panics and
        // unreadable content at degenerate sizes.
        if LayoutBreakpoint::is_ultra_narrow(area.width, area.height) {
            let msg: &str = if area.width >= 20 {
                "cass: terminal too small"
            } else if area.width >= 10 {
                "resize terminal"
            } else {
                "~"
            };
            let y = area.height / 2;
            if y < area.height {
                // Paragraph handles overflow/truncation internally, so we
                // can pass the full message and let it clip to the area.
                Paragraph::new(msg).render(Rect::new(area.x, area.y + y, area.width, 1), frame);
            }
            return;
        }

        let degradation = frame.degradation;

        let breakpoint = LayoutBreakpoint::from_width(area.width);
        let deco = style_system::DecorativePolicy::resolve(
            self.style_options,
            degradation,
            breakpoint,
            self.fancy_borders,
        );
        let border_type = match deco.border_tier {
            style_system::BorderTier::Rounded => BorderType::Rounded,
            style_system::BorderTier::Square | style_system::BorderTier::None => BorderType::Square,
        };
        let effective_density = self.density_mode.effective(area.width);
        let row_h = effective_density.row_height();
        let adaptive_borders = if deco.border_tier == style_system::BorderTier::None {
            Borders::NONE
        } else {
            Borders::ALL
        };
        let render_content = deco.render_content;

        let styles = self.resolved_style_context();
        let plain = ftui::Style::default();

        let apply_style = deco.use_styling;
        let root_style = if apply_style {
            styles.style(style_system::STYLE_APP_ROOT)
        } else {
            plain
        };
        let pane_style = if apply_style {
            styles.style(style_system::STYLE_PANE_BASE)
        } else {
            plain
        };
        let pane_focused_style = if apply_style {
            styles.style(style_system::STYLE_PANE_FOCUSED)
        } else {
            plain
        };
        let row_style = if apply_style {
            styles.style(style_system::STYLE_RESULT_ROW)
        } else {
            plain
        };
        let row_alt_style = if apply_style {
            styles.style(style_system::STYLE_RESULT_ROW_ALT)
        } else {
            plain
        };
        let row_selected_style = if apply_style {
            styles.style(style_system::STYLE_RESULT_ROW_SELECTED)
        } else {
            plain
        };
        let text_muted_style = if apply_style {
            styles.style(style_system::STYLE_TEXT_MUTED)
        } else {
            plain
        };
        let warning_style = if apply_style {
            styles.style(style_system::STYLE_STATUS_WARNING)
        } else {
            plain
        };
        let danger_style = if apply_style {
            styles.style(style_system::STYLE_STATUS_ERROR)
        } else {
            plain
        };
        let pane_title_focused_style = if apply_style {
            styles.style(style_system::STYLE_PANE_TITLE_FOCUSED)
        } else {
            plain
        };
        let pane_title_unfocused_style = if apply_style {
            styles.style(style_system::STYLE_PANE_TITLE_UNFOCUSED)
        } else {
            plain
        };
        let split_handle_style = if apply_style {
            styles.style(style_system::STYLE_SPLIT_HANDLE)
        } else {
            plain
        };

        // Paint root background across the entire terminal.
        Block::new().style(root_style).render(area, frame);

        // Optional update banner shown as top strip.
        let mut layout_area = area;
        if self.update_banner_visible()
            && area.height >= 2
            && let Some(info) = self.update_info.as_ref()
        {
            let banner_area = Rect::new(area.x, area.y, area.width, 1);
            let mut banner_text = if self.update_upgrade_armed {
                format!(
                    "Update v{} -> v{} | Press U again to confirm upgrade | N notes | S skip | Esc dismiss",
                    info.current_version, info.latest_version
                )
            } else {
                format!(
                    "Update v{} -> v{} | U upgrade | N notes | S skip | Esc dismiss",
                    info.current_version, info.latest_version
                )
            };
            if banner_text.chars().count() > banner_area.width as usize {
                banner_text = elide_text(&banner_text, banner_area.width as usize);
            }
            Paragraph::new(&*banner_text)
                .style(if self.update_upgrade_armed {
                    danger_style
                } else {
                    warning_style
                })
                .render(banner_area, frame);
            layout_area = Rect::new(area.x, area.y + 1, area.width, area.height - 1);
        }

        // Global shell strip: surface tabs + high-signal global shortcuts.
        // Only enabled when there's enough space to preserve tiny-terminal resilience.
        if layout_area.height >= 9 && layout_area.width >= 52 {
            let shell_area = Rect::new(layout_area.x, layout_area.y, layout_area.width, 1);
            let shell_bg_style = if apply_style {
                styles.style(style_system::STYLE_TAB_INACTIVE)
            } else {
                plain
            };
            Block::new().style(shell_bg_style).render(shell_area, frame);
            let shell_line = self.build_surface_shell_line(shell_area.width, &styles, apply_style);
            Paragraph::new(ftui::text::Text::from_lines(vec![shell_line]))
                .style(shell_bg_style)
                .render(shell_area, frame);
            layout_area = Rect::new(
                layout_area.x,
                layout_area.y + 1,
                layout_area.width,
                layout_area.height - 1,
            );
        }

        // ── Surface routing ──────────────────────────────────────────────
        match self.surface {
            AppSurface::Search => {
                // ── Main vertical split: search bar | content | status ──
                let vertical = Flex::vertical()
                    .constraints([
                        Constraint::Fixed(5), // Search bar (query + pills + breadcrumbs)
                        Constraint::Min(4),   // Content area (results + detail)
                        Constraint::Fixed(2), // Status footer (status + key hints)
                    ])
                    .split(layout_area);

                // Record hit regions for mouse support.
                *self.last_search_bar_area.borrow_mut() = Some(vertical[0]);
                *self.last_status_area.borrow_mut() = Some(vertical[2]);

                // ── Search bar ──────────────────────────────────────────
                let mode_label = match self.search_mode {
                    SearchMode::Lexical => "Lexical",
                    SearchMode::Semantic => "Semantic",
                    SearchMode::Hybrid => "Hybrid",
                };
                let match_label = match self.match_mode {
                    MatchMode::Standard => "Standard",
                    MatchMode::Prefix => "Prefix",
                };
                let vis = breakpoint.visibility_policy();
                let query_title = if vis.show_theme_in_title {
                    format!(
                        "cass | {} | {mode_label}/{match_label}",
                        self.theme_preset.name()
                    )
                } else {
                    // Narrow layouts prioritize explicit mode tags over theme text.
                    format!(
                        "cass | mode:{} | match:{}",
                        search_mode_str(self.search_mode),
                        match_mode_str(self.match_mode)
                    )
                };
                let query_block = Block::new()
                    .borders(adaptive_borders)
                    .border_type(border_type)
                    .title(&query_title)
                    .title_alignment(Alignment::Left)
                    .style(if self.focused_region() == FocusRegion::Results {
                        pane_focused_style
                    } else {
                        pane_style
                    });
                let query_inner = query_block.inner(vertical[0]);
                query_block.render(vertical[0], frame);
                self.last_pill_rects.borrow_mut().clear();
                if !query_inner.is_empty() {
                    let rows = if query_inner.height >= 3 {
                        Flex::vertical()
                            .constraints([
                                Constraint::Fixed(1),
                                Constraint::Fixed(1),
                                Constraint::Min(1),
                            ])
                            .split(query_inner)
                    } else if query_inner.height == 2 {
                        Flex::vertical()
                            .constraints([Constraint::Fixed(1), Constraint::Min(1)])
                            .split(query_inner)
                    } else {
                        vec![query_inner]
                    };

                    let query_row = rows[0];
                    let query_is_active = self.input_mode == InputMode::Query;
                    let query_primary_style = if apply_style {
                        styles.style(style_system::STYLE_TEXT_PRIMARY)
                    } else {
                        plain
                    };
                    let caret_style = if apply_style {
                        if query_is_active {
                            styles.style(style_system::STYLE_KBD_KEY)
                        } else {
                            text_muted_style
                        }
                    } else {
                        plain
                    };
                    let query_inset_style = if apply_style && degradation.render_decorative() {
                        if query_is_active {
                            styles.style(style_system::STYLE_SEARCH_FOCUS)
                        } else {
                            styles.style(style_system::STYLE_TAB_INACTIVE)
                        }
                    } else {
                        plain
                    };
                    Block::new()
                        .style(query_inset_style)
                        .render(query_row, frame);
                    let query_line = match self.input_mode {
                        InputMode::Query => {
                            if self.query.is_empty() {
                                ftui::text::Line::from_spans(vec![
                                    ftui::text::Span::styled("\u{2502}", caret_style),
                                    ftui::text::Span::styled("<type to search>", text_muted_style),
                                ])
                            } else {
                                let cpos = clamp_cursor_boundary(&self.query, self.cursor_pos);
                                ftui::text::Line::from_spans(vec![
                                    ftui::text::Span::styled(
                                        self.query[..cpos].to_string(),
                                        query_primary_style,
                                    ),
                                    ftui::text::Span::styled("\u{2502}", caret_style),
                                    ftui::text::Span::styled(
                                        self.query[cpos..].to_string(),
                                        query_primary_style,
                                    ),
                                ])
                            }
                        }
                        InputMode::Agent => ftui::text::Line::from_spans(vec![
                            ftui::text::Span::styled("[agent] ", text_muted_style),
                            ftui::text::Span::styled(
                                self.input_buffer.clone(),
                                query_primary_style,
                            ),
                            ftui::text::Span::styled("\u{2502}", caret_style),
                        ]),
                        InputMode::Workspace => ftui::text::Line::from_spans(vec![
                            ftui::text::Span::styled("[workspace] ", text_muted_style),
                            ftui::text::Span::styled(
                                self.input_buffer.clone(),
                                query_primary_style,
                            ),
                            ftui::text::Span::styled("\u{2502}", caret_style),
                        ]),
                        InputMode::CreatedFrom => ftui::text::Line::from_spans(vec![
                            ftui::text::Span::styled("[from] ", text_muted_style),
                            ftui::text::Span::styled(
                                self.input_buffer.clone(),
                                query_primary_style,
                            ),
                            ftui::text::Span::styled("\u{2502}", caret_style),
                        ]),
                        InputMode::CreatedTo => ftui::text::Line::from_spans(vec![
                            ftui::text::Span::styled("[to] ", text_muted_style),
                            ftui::text::Span::styled(
                                self.input_buffer.clone(),
                                query_primary_style,
                            ),
                            ftui::text::Span::styled("\u{2502}", caret_style),
                        ]),
                        InputMode::PaneFilter => ftui::text::Line::from_spans(vec![
                            ftui::text::Span::styled("[pane] ", text_muted_style),
                            ftui::text::Span::styled(
                                self.input_buffer.clone(),
                                query_primary_style,
                            ),
                            ftui::text::Span::styled("\u{2502}", caret_style),
                        ]),
                        InputMode::DetailFind => ftui::text::Line::from_spans(vec![
                            ftui::text::Span::styled("[detail-find] ", text_muted_style),
                            ftui::text::Span::styled(
                                self.input_buffer.clone(),
                                query_primary_style,
                            ),
                            ftui::text::Span::styled("\u{2502}", caret_style),
                        ]),
                    };
                    Paragraph::new(query_line).render(query_row, frame);

                    if rows.len() > 1 {
                        let pills = self.filter_pills();
                        let pill_active_style = styles.style(style_system::STYLE_PILL_ACTIVE);
                        let pill_inactive_style = styles.style(style_system::STYLE_PILL_INACTIVE);
                        let pill_label_style = styles.style(style_system::STYLE_PILL_LABEL);
                        let (pill_line, pill_rects) = self.build_pills_row(
                            rows[1],
                            &pills,
                            pill_active_style,
                            pill_inactive_style,
                            pill_label_style,
                            text_muted_style,
                        );
                        *self.last_pill_rects.borrow_mut() = pill_rects;
                        Paragraph::new(pill_line).render(rows[1], frame);
                    }

                    if rows.len() > 2 {
                        let crumb_active_style = styles.style(style_system::STYLE_CRUMB_ACTIVE);
                        let crumb_inactive_style = styles.style(style_system::STYLE_CRUMB_INACTIVE);
                        let crumb_sep_style = styles.style(style_system::STYLE_CRUMB_SEPARATOR);
                        let crumb_line = self.breadcrumb_line(
                            rows[2].width,
                            crumb_active_style,
                            crumb_inactive_style,
                            crumb_sep_style,
                        );
                        Paragraph::new(crumb_line).render(rows[2], frame);
                    }
                }

                // ── Content area: responsive layout ─────────────────────
                let content_area = vertical[1];
                *self.last_content_area.borrow_mut() = Some(content_area);

                // Reset hit regions — they'll be repopulated by render_*_pane().
                *self.last_results_inner.borrow_mut() = None;
                *self.last_detail_area.borrow_mut() = None;
                *self.last_split_handle_area.borrow_mut() = None;

                self.last_pane_rects.borrow_mut().clear();
                *self.last_pane_first_index.borrow_mut() = 0;
                let results_focused = self.focused_region() == FocusRegion::Results;
                let reveal_motion_enabled =
                    self.results_reveal_motion_enabled(degradation, self.results.len());
                let focus_flash_intensity =
                    self.results_focus_flash_intensity(degradation, results_focused);

                let topo = breakpoint.search_topology();
                if topo.dual_pane {
                    // Dual-pane: split content area using topology-defined minimums.
                    let (results_area, detail_area, split_handle) =
                        self.split_content_area(content_area, topo.min_results, topo.min_detail);
                    *self.last_split_handle_area.borrow_mut() = split_handle;
                    self.render_results_pane(
                        frame,
                        results_area,
                        row_h,
                        border_type,
                        adaptive_borders,
                        &styles,
                        pane_style,
                        pane_focused_style,
                        pane_title_focused_style,
                        pane_title_unfocused_style,
                        row_style,
                        row_alt_style,
                        row_selected_style,
                        text_muted_style,
                        reveal_motion_enabled,
                        focus_flash_intensity,
                    );
                    self.render_detail_pane(
                        frame,
                        detail_area,
                        border_type,
                        adaptive_borders,
                        &styles,
                        pane_style,
                        pane_focused_style,
                        pane_title_focused_style,
                        pane_title_unfocused_style,
                        text_muted_style,
                    );
                    // Render split handle as a subtle vertical divider.
                    if let Some(handle) = split_handle {
                        let mut handle_style = split_handle_style;
                        if apply_style {
                            let accent = self
                                .panes
                                .get(self.active_pane)
                                .map(|pane| legacy_agent_color(&pane.agent))
                                .or_else(|| styles.style(style_system::STYLE_STATUS_INFO).fg)
                                .unwrap_or(ftui::PackedRgba::rgb(100, 170, 240));
                            let handle_focused = matches!(
                                self.focused_region(),
                                FocusRegion::Results | FocusRegion::Detail
                            );
                            let pulse = if self.anim.enabled && handle_focused {
                                (1.0 - self.anim.focus_flash_progress()).clamp(0.0, 1.0)
                            } else {
                                0.0
                            };
                            let base_fg = split_handle_style
                                .fg
                                .unwrap_or(ftui::PackedRgba::rgb(90, 96, 118));
                            let base_bg = split_handle_style
                                .bg
                                .unwrap_or(ftui::PackedRgba::rgb(14, 18, 28));
                            let fg_mix = if handle_focused {
                                (0.38 + pulse * 0.24).clamp(0.0, 0.75)
                            } else {
                                0.20
                            };
                            let bg_mix = if handle_focused {
                                (0.06 + pulse * 0.08).clamp(0.0, 0.22)
                            } else {
                                0.03
                            };
                            let rail_fg = ftui::PackedRgba::rgb(
                                lerp_u8(base_fg.r(), accent.r(), fg_mix),
                                lerp_u8(base_fg.g(), accent.g(), fg_mix),
                                lerp_u8(base_fg.b(), accent.b(), fg_mix),
                            );
                            let rail_bg = ftui::PackedRgba::rgb(
                                lerp_u8(base_bg.r(), accent.r(), bg_mix),
                                lerp_u8(base_bg.g(), accent.g(), bg_mix),
                                lerp_u8(base_bg.b(), accent.b(), bg_mix),
                            );
                            handle_style = handle_style.fg(rail_fg).bg(rail_bg);
                            if pulse > 0.08 {
                                handle_style = handle_style.bold();
                            }
                        }
                        let divider: String = (0..handle.height).map(|_| "\u{2502}\n").collect();
                        Paragraph::new(divider.trim_end())
                            .style(handle_style)
                            .render(handle, frame);
                    }
                } else {
                    // Single-pane: show whichever pane has focus, full-width.
                    match self.focused_region() {
                        FocusRegion::Results => {
                            self.render_results_pane(
                                frame,
                                content_area,
                                row_h,
                                border_type,
                                adaptive_borders,
                                &styles,
                                pane_style,
                                pane_focused_style,
                                pane_title_focused_style,
                                pane_title_unfocused_style,
                                row_style,
                                row_alt_style,
                                row_selected_style,
                                text_muted_style,
                                reveal_motion_enabled,
                                focus_flash_intensity,
                            );
                        }
                        FocusRegion::Detail => {
                            self.render_detail_pane(
                                frame,
                                content_area,
                                border_type,
                                adaptive_borders,
                                &styles,
                                pane_style,
                                pane_focused_style,
                                pane_title_focused_style,
                                pane_title_unfocused_style,
                                text_muted_style,
                            );
                        }
                    }
                }

                // ── Status footer ───────────────────────────────────────
                let bp_label = breakpoint.footer_label();
                let density_label = match effective_density {
                    DensityMode::Compact => "compact",
                    DensityMode::Cozy => "cozy",
                    DensityMode::Spacious => "spacious",
                };
                let hits_for_status = if self.panes.is_empty() {
                    self.results.len()
                } else {
                    self.panes.iter().map(|pane| pane.total_count).sum()
                };
                let kbd_key_s = if apply_style {
                    styles.style(style_system::STYLE_KBD_KEY)
                } else {
                    text_muted_style
                };
                let kbd_desc_s = if apply_style {
                    styles.style(style_system::STYLE_KBD_DESC)
                } else {
                    text_muted_style
                };
                let status_success_s = if apply_style {
                    styles.style(style_system::STYLE_STATUS_SUCCESS)
                } else {
                    text_muted_style
                };
                let status_warning_s = if apply_style {
                    styles.style(style_system::STYLE_STATUS_WARNING)
                } else {
                    text_muted_style
                };
                let status_error_s = if apply_style {
                    styles.style(style_system::STYLE_STATUS_ERROR)
                } else {
                    text_muted_style
                };
                let status_info_s = if apply_style {
                    styles.style(style_system::STYLE_STATUS_INFO)
                } else {
                    text_muted_style
                };
                let query_lane = format!(
                    "{} / {} ({})",
                    search_mode_token(self.search_mode),
                    match_mode_token(self.match_mode),
                    shortcuts::SEARCH_MODE
                );
                let source_scope = if self.filters.source_filter.is_all() {
                    "all".to_string()
                } else {
                    self.filters.source_filter.to_string()
                };
                let scope_lane = format!(
                    "rank:{} ctx:{} src:{}{}",
                    ranking_mode_label(self.ranking_mode).to_ascii_lowercase(),
                    context_window_token(self.context_window),
                    source_scope,
                    if self.wildcard_fallback {
                        " ✱fuzzy"
                    } else {
                        ""
                    }
                );
                let perf_lane = format!(
                    "lat:{} cache:{}",
                    self.last_search_ms
                        .map_or_else(|| "—".to_string(), |ms| format!("{ms}ms")),
                    if self.cached_detail.is_some() {
                        "warm"
                    } else {
                        "cold"
                    }
                );
                let perf_lane_style = match self.last_search_ms {
                    Some(ms) if ms >= 350 => status_warning_s,
                    Some(_) => status_success_s,
                    None => status_info_s,
                };
                let mut runtime_parts = Vec::with_capacity(3);
                if !degradation.is_full() {
                    runtime_parts.push(format!("deg:{}", degradation.as_str()));
                }
                if let Some(loading) = self.loading_hud_token() {
                    runtime_parts.push(loading);
                }
                if !self.selected.is_empty() {
                    runtime_parts.push(format!("sel:{}", self.selected.len()));
                }
                if self.macro_recorder.is_some() {
                    runtime_parts.push("●REC".to_string());
                } else if self.macro_playback.is_some() {
                    runtime_parts.push("▶PLAY".to_string());
                }
                let runtime_lane = if runtime_parts.is_empty() {
                    "stable".to_string()
                } else {
                    runtime_parts.join(" ")
                };
                let runtime_lane_style = match degradation {
                    ftui::render::budget::DegradationLevel::Full => status_success_s,
                    ftui::render::budget::DegradationLevel::SimpleBorders
                    | ftui::render::budget::DegradationLevel::NoStyling => status_warning_s,
                    ftui::render::budget::DegradationLevel::EssentialOnly
                    | ftui::render::budget::DegradationLevel::Skeleton
                    | ftui::render::budget::DegradationLevel::SkipFrame => status_error_s,
                };
                let mut hud_lanes = Vec::with_capacity(8);
                if !self.status.is_empty() {
                    // Animate the status text only for active-operation messages
                    // (avoid a spinner on informational or error statuses).
                    let status_value = if self.loading_context.is_some()
                        && (self.status.starts_with("Searching")
                            || self.status.starts_with("Indexing")
                            || self.status.starts_with("Refreshing"))
                    {
                        format!("{} {}", self.loading_spinner_glyph(), self.status)
                    } else {
                        self.status.clone()
                    };
                    hud_lanes.push(FooterHudLane {
                        key: "status",
                        value: status_value,
                        value_style: status_warning_s,
                    });
                }
                hud_lanes.push(FooterHudLane {
                    key: "hits",
                    value: hits_for_status.to_string(),
                    value_style: status_info_s,
                });
                hud_lanes.push(FooterHudLane {
                    key: "view",
                    value: format!("{bp_label}/{density_label}"),
                    value_style: kbd_desc_s,
                });
                hud_lanes.push(FooterHudLane {
                    key: "query",
                    value: query_lane,
                    value_style: kbd_desc_s,
                });
                hud_lanes.push(FooterHudLane {
                    key: "perf",
                    value: perf_lane,
                    value_style: perf_lane_style,
                });
                hud_lanes.push(FooterHudLane {
                    key: "runtime",
                    value: runtime_lane,
                    value_style: runtime_lane_style,
                });
                hud_lanes.push(FooterHudLane {
                    key: "scope",
                    value: scope_lane,
                    value_style: status_info_s,
                });
                if !self.terminal_focused {
                    hud_lanes.push(FooterHudLane {
                        key: "focus",
                        value: "unfocused".to_string(),
                        value_style: status_warning_s,
                    });
                }
                let footer_area = vertical[2];
                if footer_area.height >= 2 {
                    // Row 1: Status info
                    let row1 = Rect::new(footer_area.x, footer_area.y, footer_area.width, 1);
                    let status_line =
                        build_footer_hud_line(&hud_lanes, row1.width, kbd_key_s, text_muted_style);
                    Paragraph::new(ftui::text::Text::from_lines(vec![status_line]))
                        .style(text_muted_style)
                        .render(row1, frame);

                    // Row 2: Styled key hints
                    let row2 = Rect::new(footer_area.x, footer_area.y + 1, footer_area.width, 1);
                    let hints_text = self.build_contextual_footer_hints(footer_area.width);
                    let hint_spans = build_styled_hints(&hints_text, kbd_key_s, kbd_desc_s);
                    let hints_line = ftui::text::Line::from_spans(hint_spans);
                    Paragraph::new(ftui::text::Text::from_lines(vec![hints_line]))
                        .style(text_muted_style)
                        .render(row2, frame);
                } else {
                    // Fallback: single row HUD line.
                    let status_line = build_footer_hud_line(
                        &hud_lanes,
                        footer_area.width,
                        kbd_key_s,
                        text_muted_style,
                    );
                    Paragraph::new(ftui::text::Text::from_lines(vec![status_line]))
                        .style(text_muted_style)
                        .render(footer_area, frame);
                }
            }

            AppSurface::Analytics => {
                // Clear search hit regions — not visible on analytics surface.
                *self.last_search_bar_area.borrow_mut() = None;
                *self.last_results_inner.borrow_mut() = None;
                *self.last_detail_area.borrow_mut() = None;
                *self.last_status_area.borrow_mut() = None;
                *self.last_content_area.borrow_mut() = None;
                *self.last_split_handle_area.borrow_mut() = None;
                self.last_pill_rects.borrow_mut().clear();
                self.last_pane_rects.borrow_mut().clear();
                *self.last_pane_first_index.borrow_mut() = 0;
                self.last_saved_view_row_areas.borrow_mut().clear();

                // ── Analytics surface layout ─────────────────────────────
                let atopo = breakpoint.analytics_topology();
                let vertical = Flex::vertical()
                    .constraints([
                        Constraint::Fixed(atopo.header_rows), // Header / nav bar
                        Constraint::Min(4),                   // Content
                        Constraint::Fixed(1),                 // Status footer
                    ])
                    .split(layout_area);

                let empty_data = super::analytics_charts::AnalyticsChartData::default();
                let chart_data = self.analytics_cache.as_ref().unwrap_or(&empty_data);
                let analytics_accent = match self.analytics_view {
                    AnalyticsView::Dashboard => ftui::PackedRgba::rgb(90, 180, 255),
                    AnalyticsView::Explorer => ftui::PackedRgba::rgb(120, 220, 140),
                    AnalyticsView::Heatmap => ftui::PackedRgba::rgb(255, 180, 90),
                    AnalyticsView::Breakdowns => ftui::PackedRgba::rgb(210, 140, 255),
                    AnalyticsView::Tools => ftui::PackedRgba::rgb(255, 120, 160),
                    AnalyticsView::Plans => ftui::PackedRgba::rgb(140, 220, 220),
                    AnalyticsView::Coverage => ftui::PackedRgba::rgb(190, 220, 130),
                };

                // ── Analytics header with tab strip + KPI ribbon ──────────
                let header_block = Block::new()
                    .borders(adaptive_borders)
                    .border_type(border_type)
                    .title("cass analytics")
                    .title_alignment(Alignment::Left)
                    .border_style(pane_focused_style.fg(analytics_accent).bold())
                    .style(pane_focused_style.bg(dim_packed_color(analytics_accent, 0.08)));
                let header_inner = header_block.inner(vertical[0]);
                header_block.render(vertical[0], frame);
                if render_content && !header_inner.is_empty() {
                    let header_rows = if header_inner.height >= 3 {
                        Flex::vertical()
                            .constraints([
                                Constraint::Fixed(1),
                                Constraint::Fixed(1),
                                Constraint::Min(1),
                            ])
                            .split(header_inner)
                    } else if header_inner.height == 2 {
                        Flex::vertical()
                            .constraints([Constraint::Fixed(1), Constraint::Min(1)])
                            .split(header_inner)
                    } else {
                        vec![header_inner]
                    };

                    let tab_line = self.analytics_tabs_line(
                        atopo.show_tab_bar,
                        ftui::Style::new()
                            .fg(analytics_accent)
                            .bg(dim_packed_color(analytics_accent, 0.20))
                            .bold(),
                        ftui::Style::new().fg(dim_packed_color(analytics_accent, 0.70)),
                        text_muted_style,
                    );
                    Paragraph::new(tab_line)
                        .style(text_muted_style)
                        .render(header_rows[0], frame);

                    if header_rows.len() > 1 {
                        let metrics_line = self.analytics_metrics_line(
                            chart_data,
                            header_rows[1].width,
                            ftui::Style::new().fg(analytics_accent).bold(),
                            text_muted_style,
                        );
                        Paragraph::new(metrics_line)
                            .style(text_muted_style)
                            .render(header_rows[1], frame);
                    }

                    if header_rows.len() > 2 && atopo.show_filter_summary {
                        let filter_desc = self.analytics_filter_summary();
                        Paragraph::new(&*filter_desc)
                            .style(text_muted_style)
                            .render(header_rows[2], frame);
                    }
                }

                // ── Analytics content placeholder ────────────────────────
                let content_block = Block::new()
                    .borders(adaptive_borders)
                    .border_type(border_type)
                    .title(self.analytics_view.label())
                    .title_alignment(Alignment::Left)
                    .border_style(pane_focused_style.fg(analytics_accent).bold())
                    .style(pane_style.bg(dim_packed_color(analytics_accent, 0.04)));
                let content_inner = content_block.inner(vertical[1]);
                content_block.render(vertical[1], frame);
                if render_content && !content_inner.is_empty() {
                    if self.loading_context == Some(LoadingContext::Analytics) {
                        let loading_line =
                            format!("{} Loading analytics...", self.loading_spinner_glyph());
                        Paragraph::new(loading_line)
                            .style(text_muted_style)
                            .render(content_inner, frame);
                    } else {
                        let explorer_state = super::analytics_charts::ExplorerState {
                            metric: self.explorer_metric,
                            overlay: self.explorer_overlay,
                            group_by: self.explorer_group_by,
                            zoom: self.explorer_zoom,
                        };
                        super::analytics_charts::render_analytics_content(
                            self.analytics_view,
                            chart_data,
                            &explorer_state,
                            self.breakdown_tab,
                            self.heatmap_metric,
                            self.analytics_selection,
                            content_inner,
                            frame,
                        );
                    }
                }

                // ── Analytics status footer ──────────────────────────────
                let mut footer_spans: Vec<ftui::text::Span> = Vec::new();
                footer_spans.push(ftui::text::Span::styled("analytics ", text_muted_style));
                footer_spans.push(ftui::text::Span::styled(
                    self.analytics_view.label(),
                    ftui::Style::new().fg(analytics_accent).bold(),
                ));
                footer_spans.push(ftui::text::Span::styled(
                    format!("  [{}]", breakpoint.footer_label()),
                    text_muted_style,
                ));

                if self.analytics_selectable_count() > 0 {
                    footer_spans.push(ftui::text::Span::styled("  \u{2502} ", text_muted_style));
                    footer_spans.push(ftui::text::Span::styled(
                        format!(
                            "row {}/{}",
                            self.analytics_selection + 1,
                            self.analytics_selectable_count()
                        ),
                        ftui::Style::new().fg(dim_packed_color(analytics_accent, 0.85)),
                    ));
                }

                if atopo.show_footer_hints {
                    footer_spans.push(ftui::text::Span::styled("  \u{2502} ", text_muted_style));
                    footer_spans.push(ftui::text::Span::styled(
                        "\u{2190}\u{2192} views  \u{2191}\u{2193} select  Enter drilldown  Esc back",
                        text_muted_style,
                    ));
                } else {
                    footer_spans.push(ftui::text::Span::styled(
                        "  \u{2502} Esc back",
                        text_muted_style,
                    ));
                }

                if !degradation.is_full() {
                    footer_spans.push(ftui::text::Span::styled("  \u{2502} ", text_muted_style));
                    footer_spans.push(ftui::text::Span::styled(
                        format!("deg:{}", degradation.as_str()),
                        ftui::Style::new().fg(ftui::PackedRgba::rgb(255, 190, 90)),
                    ));
                }
                if self.loading_context == Some(LoadingContext::Analytics) {
                    footer_spans.push(ftui::text::Span::styled("  \u{2502} ", text_muted_style));
                    footer_spans.push(ftui::text::Span::styled(
                        format!("{} loading", self.loading_spinner_glyph()),
                        ftui::Style::new().fg(analytics_accent).bold(),
                    ));
                }

                Paragraph::new(ftui::text::Text::from_lines(vec![
                    ftui::text::Line::from_spans(footer_spans),
                ]))
                .style(text_muted_style)
                .render(vertical[2], frame);
            }

            AppSurface::Sources => {
                // Clear search hit regions — not visible on sources surface.
                *self.last_search_bar_area.borrow_mut() = None;
                *self.last_results_inner.borrow_mut() = None;
                *self.last_detail_area.borrow_mut() = None;
                *self.last_status_area.borrow_mut() = None;
                *self.last_content_area.borrow_mut() = None;
                *self.last_split_handle_area.borrow_mut() = None;
                self.last_pill_rects.borrow_mut().clear();
                self.last_pane_rects.borrow_mut().clear();
                *self.last_pane_first_index.borrow_mut() = 0;
                self.last_saved_view_row_areas.borrow_mut().clear();

                // ── Sources surface layout ─────────────────────────────
                let vertical = Flex::vertical()
                    .constraints([
                        Constraint::Fixed(3), // Header
                        Constraint::Min(4),   // Source list
                        Constraint::Fixed(1), // Status footer
                    ])
                    .split(layout_area);

                // ── Header ───────────────────────────────────────────
                let header_title = format!(
                    "cass sources | {} source(s) | {}",
                    self.sources_view.items.len(),
                    self.sources_view.config_path
                );
                let header_block = Block::new()
                    .borders(adaptive_borders)
                    .border_type(border_type)
                    .title(&header_title)
                    .title_alignment(Alignment::Left)
                    .style(pane_focused_style);
                let header_inner = header_block.inner(vertical[0]);
                header_block.render(vertical[0], frame);
                if render_content && !header_inner.is_empty() {
                    let hints = " s=sync  d=doctor  r=refresh  Esc=back";
                    Paragraph::new(hints)
                        .style(text_muted_style)
                        .render(header_inner, frame);
                }

                // ── Source list ───────────────────────────────────────
                let content_block = Block::new()
                    .borders(adaptive_borders)
                    .border_type(border_type)
                    .title("Configured Sources")
                    .title_alignment(Alignment::Left)
                    .style(pane_style);
                let content_inner = content_block.inner(vertical[1]);
                content_block.render(vertical[1], frame);

                if render_content && !content_inner.is_empty() {
                    let sv = &self.sources_view;
                    if sv.items.is_empty() {
                        Paragraph::new(
                            "No sources configured.\nRun `cass sources add <host>` to add one.",
                        )
                        .style(text_muted_style)
                        .render(content_inner, frame);
                    } else {
                        // Render each source row.
                        let visible_rows = content_inner.height as usize;
                        let start = sv.scroll;
                        let end = (start + visible_rows).min(sv.items.len());

                        for (vis_idx, src_idx) in (start..end).enumerate() {
                            let item = &sv.items[src_idx];
                            let row_y = content_inner.y + vis_idx as u16;
                            if row_y >= content_inner.y + content_inner.height {
                                break;
                            }
                            let row_area =
                                Rect::new(content_inner.x, row_y, content_inner.width, 1);

                            let is_selected = src_idx == sv.selected;
                            let kind_tag = match item.kind {
                                crate::sources::SourceKind::Local => "[local]",
                                crate::sources::SourceKind::Ssh => "[ssh]  ",
                            };
                            let host_str = item.host.as_deref().unwrap_or("-");
                            let sync_str = if item.busy {
                                "\u{23F3}".to_string() // hourglass
                            } else if let Some((p, w, f)) = item.doctor_summary {
                                format!("dr:{p}p/{w}w/{f}f")
                            } else {
                                format!("last:{}", item.last_result)
                            };

                            // Truncate row to fit.
                            let row_text = format!(
                                " {kind_tag} {:<16} {:<24} {:<8} paths:{} {sync_str}",
                                item.name, host_str, item.schedule, item.path_count
                            );
                            let display: String = row_text
                                .chars()
                                .take(content_inner.width as usize)
                                .collect();

                            let row_style = if is_selected {
                                styles.style(style_system::STYLE_RESULT_ROW_SELECTED)
                            } else {
                                styles.style(style_system::STYLE_TEXT_PRIMARY)
                            };
                            Paragraph::new(&*display)
                                .style(row_style)
                                .render(row_area, frame);
                        }
                    }
                }

                // ── Sources status footer ────────────────────────────
                let sources_status = format!(
                    " Sources: [{}/{}] | {}",
                    self.sources_view.selected + 1,
                    self.sources_view.items.len(),
                    self.sources_view.status
                );
                Paragraph::new(&*sources_status)
                    .style(text_muted_style)
                    .render(vertical[2], frame);
            }
        }

        self.capture_view_transition_snapshot(frame);
        self.render_view_transition_overlay(frame, area, &styles, degradation, apply_style);

        // ── Modal backdrop dim ────────────────────────────────────────
        // When any modal is open, render a dimmed backdrop over the full
        // screen before drawing modal content.  Opacity follows the
        // modal_open spring for a smooth fade-in / fade-out.
        let modal_visible = self.show_export_modal
            || self.show_bulk_modal
            || self.show_saved_views_modal
            || self.show_detail_modal
            || self.show_help
            || self.show_theme_editor
            || self.show_inspector
            || self.show_consent_dialog
            || self.source_filter_menu_open
            || self.command_palette.is_visible();
        if modal_visible && apply_style {
            let spring_t = self.anim.modal_open.position().clamp(0.0, 1.0) as f32;
            if spring_t > 0.01 {
                let backdrop_style = styles.style(style_system::STYLE_MODAL_BACKDROP);
                // Blend the backdrop toward the themed dim color proportional
                // to the spring position so it fades in smoothly.
                let dim_bg = backdrop_style.bg.unwrap_or(ftui::PackedRgba::rgb(0, 0, 0));
                let root_bg_color = root_style.bg.unwrap_or(ftui::PackedRgba::rgb(0, 0, 0));
                let blended = ftui::PackedRgba::rgb(
                    lerp_u8(root_bg_color.r(), dim_bg.r(), spring_t),
                    lerp_u8(root_bg_color.g(), dim_bg.g(), spring_t),
                    lerp_u8(root_bg_color.b(), dim_bg.b(), spring_t),
                );
                Block::new()
                    .style(ftui::Style::new().bg(blended))
                    .render(area, frame);
            }
        }

        // ── Detail modal overlay ─────────────────────────────────────
        if self.show_detail_modal {
            // Render as a large near-fullscreen overlay.
            let margin_x = if area.width > 8 { 2 } else { 0 };
            let margin_y = if area.height > 6 { 1 } else { 0 };
            let modal_w = area.width.saturating_sub(margin_x * 2).max(1);
            let modal_h = area.height.saturating_sub(margin_y * 2).max(1);
            let modal_area = Rect::new(area.x + margin_x, area.y + margin_y, modal_w, modal_h);
            Block::new().style(pane_style).render(modal_area, frame);
            self.render_detail_pane(
                frame,
                modal_area,
                border_type,
                adaptive_borders,
                &styles,
                pane_style,
                pane_focused_style,
                pane_title_focused_style,
                pane_title_unfocused_style,
                text_muted_style,
            );
        }

        // ── Export modal overlay ─────────────────────────────────────
        if self.show_export_modal {
            self.render_export_overlay(frame, area, &styles);
        }

        // ── Bulk actions modal overlay ───────────────────────────────
        if self.show_bulk_modal {
            let modal_w = 40u16.min(area.width.saturating_sub(4));
            let modal_h = (BULK_ACTIONS.len() as u16 + 2).min(area.height.saturating_sub(4));
            let mx = area.x + (area.width.saturating_sub(modal_w)) / 2;
            let my = area.y + (area.height.saturating_sub(modal_h)) / 2;
            let modal_area = Rect::new(mx, my, modal_w, modal_h);

            // Clear area behind modal
            Block::new().style(root_style).render(modal_area, frame);

            let title = format!(" Bulk Actions ({} selected) ", self.selected.len());
            let modal_block = Block::new()
                .borders(adaptive_borders)
                .border_type(border_type)
                .title(&title)
                .title_alignment(Alignment::Left)
                .style(pane_focused_style);
            let inner = modal_block.inner(modal_area);
            modal_block.render(modal_area, frame);

            if render_content && !inner.is_empty() {
                for (i, label) in BULK_ACTIONS.iter().enumerate() {
                    if i as u16 >= inner.height {
                        break;
                    }
                    let row_area = Rect::new(inner.x, inner.y + i as u16, inner.width, 1);
                    let prefix = if i == self.bulk_action_idx {
                        "> "
                    } else {
                        "  "
                    };
                    let line = format!("{prefix}{label}");
                    let row_style_here = if i == self.bulk_action_idx {
                        row_selected_style
                    } else {
                        text_muted_style
                    };
                    Paragraph::new(&*line)
                        .style(row_style_here)
                        .render(row_area, frame);
                }
            }
        }

        if self.show_saved_views_modal {
            self.render_saved_views_overlay(frame, area, &styles);
        } else {
            self.last_saved_view_row_areas.borrow_mut().clear();
        }

        if self.source_filter_menu_open {
            self.render_source_filter_menu_overlay(frame, area, &styles);
        }

        if self.show_consent_dialog {
            self.render_consent_overlay(frame, area, &styles);
        }

        // ── Help overlay ─────────────────────────────────────────────
        if self.show_help {
            self.render_help_overlay(frame, area, &styles);
        }

        // ── Theme editor overlay ─────────────────────────────────────
        if self.show_theme_editor {
            self.render_theme_editor_overlay(frame, area, &styles);
        }

        // ── Inspector overlay ────────────────────────────────────────
        if self.show_inspector {
            self.render_inspector_overlay(frame, area, &styles);
        }

        // ── Command palette overlay ──────────────────────────────────
        if self.command_palette.is_visible() {
            use super::ftui_adapter::Widget;
            self.command_palette.render(area, frame);
            if self.show_palette_evidence {
                self.render_palette_evidence(frame, area, &styles);
            }
        }

        // ── Screenshot capture (runs after all rendering completes) ──
        if let Some(format) = self.screenshot_pending {
            let exported =
                match format {
                    ScreenshotFormat::Html => ftui_extras::export::HtmlExporter::default()
                        .export(&frame.buffer, frame.pool),
                    ScreenshotFormat::Svg => ftui_extras::export::SvgExporter::default()
                        .export(&frame.buffer, frame.pool),
                    ScreenshotFormat::Text => {
                        ftui_extras::export::TextExporter::plain().export(&frame.buffer, frame.pool)
                    }
                };
            *self.screenshot_result.borrow_mut() = Some((format, exported));
        }
    }
}

// =========================================================================
// Entry Point
// =========================================================================

/// Write a screenshot file to ~/Downloads and emit a completion or failure message.
fn write_screenshot_file(format: ScreenshotFormat, content: String) -> ftui::Cmd<CassMsg> {
    ftui::Cmd::msg(write_screenshot_file_sync(format, content))
}

fn write_screenshot_file_sync(format: ScreenshotFormat, content: String) -> CassMsg {
    let downloads = dirs::download_dir().unwrap_or_else(|| {
        dirs::home_dir()
            .unwrap_or_else(|| PathBuf::from("."))
            .join("Downloads")
    });
    if let Err(e) = std::fs::create_dir_all(&downloads) {
        return CassMsg::ScreenshotFailed(format!("Cannot create dir: {e}"));
    }
    let ts = chrono::Local::now().format("%Y%m%d_%H%M%S");
    let filename = format!("cass_screenshot_{ts}.{}", format.extension());
    let path = downloads.join(&filename);
    match std::fs::write(&path, content.as_bytes()) {
        Ok(()) => CassMsg::ScreenshotCompleted(path),
        Err(e) => CassMsg::ScreenshotFailed(format!("Write failed: {e}")),
    }
}

/// Background task: export a session to HTML.
///
/// Runs on a background thread via `Cmd::task` so the UI stays responsive.
#[allow(clippy::too_many_arguments)]
fn export_session_task(
    source_path: &str,
    output_dir: &std::path::Path,
    output_filename: &str,
    encrypt: bool,
    password: Option<&str>,
    show_timestamps: bool,
    include_tools: bool,
    title: &str,
    agent_name: &str,
) -> CassMsg {
    use crate::html_export::{
        ExportOptions as HtmlExportOptions, HtmlExporter, Message as HtmlMessage, TemplateMetadata,
    };
    use std::fs::File;
    use std::io::{BufRead, BufReader, Write};

    let session = std::path::Path::new(source_path);
    if !session.exists() {
        return CassMsg::ExportFailed(format!("Session not found: {source_path}"));
    }

    // Read and parse session messages.
    let file = match File::open(session) {
        Ok(f) => f,
        Err(e) => return CassMsg::ExportFailed(format!("Cannot open session: {e}")),
    };
    let reader = BufReader::new(file);
    let mut messages: Vec<HtmlMessage> = Vec::new();

    for line in reader.lines() {
        let line = match line {
            Ok(l) => l,
            Err(_) => continue,
        };
        let trimmed = line.trim();
        if trimmed.is_empty() {
            continue;
        }
        let val: serde_json::Value = match serde_json::from_str(trimmed) {
            Ok(v) => v,
            Err(_) => continue,
        };
        // Extract role and content from the JSON line.
        let role = val
            .get("role")
            .and_then(|r| r.as_str())
            .unwrap_or("unknown")
            .to_string();
        let content = val
            .get("content")
            .and_then(|c| {
                if c.is_string() {
                    c.as_str().map(|s| s.to_string())
                } else if c.is_array() {
                    // Handle array content (e.g., Claude Code format).
                    let parts: Vec<String> = c
                        .as_array()
                        .unwrap_or(&Vec::new())
                        .iter()
                        .filter_map(|part| {
                            part.get("text")
                                .and_then(|t| t.as_str())
                                .map(|s| s.to_string())
                        })
                        .collect();
                    if parts.is_empty() {
                        None
                    } else {
                        Some(parts.join("\n"))
                    }
                } else {
                    None
                }
            })
            .unwrap_or_default();

        if content.is_empty() && !include_tools {
            continue;
        }
        messages.push(HtmlMessage {
            role,
            content,
            timestamp: val
                .get("timestamp")
                .and_then(|t| t.as_str())
                .map(|s| s.to_string()),
            tool_call: None,
            index: None,
            author: None,
        });
    }

    if messages.is_empty() {
        return CassMsg::ExportFailed("No messages found in session".to_string());
    }

    // Build export options and generate HTML.
    let options = HtmlExportOptions {
        title: Some(title.to_string()),
        include_cdn: true,
        syntax_highlighting: true,
        include_search: true,
        include_theme_toggle: true,
        encrypt,
        print_styles: true,
        agent_name: Some(agent_name.to_string()),
        show_timestamps,
        show_tool_calls: include_tools,
    };

    let exporter = HtmlExporter::with_options(options);
    let metadata = TemplateMetadata {
        timestamp: None,
        agent: Some(agent_name.to_string()),
        message_count: messages.len(),
        duration: None,
        project: None,
    };

    let groups = crate::group_messages_for_export(messages);
    let html = match exporter.export_messages(title, &groups, metadata, password) {
        Ok(h) => h,
        Err(e) => return CassMsg::ExportFailed(format!("HTML generation failed: {e}")),
    };

    // Write output file.
    let output_path = output_dir.join(output_filename);
    if let Some(parent) = output_path.parent()
        && !parent.exists()
        && let Err(e) = std::fs::create_dir_all(parent)
    {
        return CassMsg::ExportFailed(format!("Cannot create output directory: {e}"));
    }
    match File::create(&output_path).and_then(|mut f| f.write_all(html.as_bytes())) {
        Ok(()) => CassMsg::ExportCompleted {
            output_path: output_path.clone(),
            file_size: html.len(),
            encrypted: encrypt,
        },
        Err(e) => CassMsg::ExportFailed(format!("Failed to write export: {e}")),
    }
}

/// Configuration for inline TUI mode.
pub struct InlineTuiConfig {
    /// Height of the inline UI in terminal rows.
    pub ui_height: u16,
    /// Whether the UI is anchored to the top or bottom of the terminal.
    pub anchor: super::ftui_adapter::UiAnchor,
}

/// Configuration for macro recording/playback.
pub struct MacroConfig {
    /// Path to write recorded macro events.
    pub record_path: Option<std::path::PathBuf>,
    /// Path to read and play back macro events.
    pub play_path: Option<std::path::PathBuf>,
}

/// Default directory for interactively saved macros.
fn macro_save_dir() -> PathBuf {
    dirs::data_local_dir()
        .unwrap_or_else(|| PathBuf::from("."))
        .join("coding-agent-search")
        .join("macros")
}

/// Build the BOCPD-based resize coalescer configuration.
///
/// This is extracted as a standalone function so all launch modes share
/// identical config and the parity matrix can be tested without a terminal.
///
/// Returns `(CoalescerConfig, EvidenceSinkConfig)`.
pub fn build_resize_config(
    data_dir: &std::path::Path,
) -> (
    ftui::runtime::resize_coalescer::CoalescerConfig,
    ftui::runtime::evidence_sink::EvidenceSinkConfig,
) {
    use ftui::runtime::bocpd::BocpdConfig;
    use ftui::runtime::evidence_sink::{EvidenceSinkConfig, EvidenceSinkDestination};
    use ftui::runtime::resize_coalescer::CoalescerConfig;

    // BOCPD replaces the simple rate-threshold heuristic with Bayesian
    // changepoint detection for principled steady/burst regime switching.
    // The "responsive" preset uses lower thresholds for faster detection,
    // matching cass's interactive search-as-you-type profile.
    let bocpd_disabled = dotenvy::var("CASS_BOCPD")
        .map(|v| v == "0" || v.eq_ignore_ascii_case("false"))
        .unwrap_or(false);

    let coalescer = if bocpd_disabled {
        CoalescerConfig::default()
    } else {
        let bocpd = BocpdConfig::responsive().with_logging(true);
        CoalescerConfig::default()
            .with_bocpd_config(bocpd)
            .with_logging(true)
    };

    // Evidence sink: write resize/BOCPD decision logs to data_dir.
    // Consumed by the explainability cockpit (1mfw3.3.x) for UI-facing
    // evidence summaries and the inspector's resize panel.
    let evidence_path = dotenvy::var("CASS_RESIZE_EVIDENCE_FILE")
        .map(PathBuf::from)
        .unwrap_or_else(|_| data_dir.join("resize_evidence.jsonl"));
    let evidence_sink = if bocpd_disabled {
        EvidenceSinkConfig::disabled()
    } else {
        EvidenceSinkConfig {
            enabled: true,
            destination: EvidenceSinkDestination::file(&evidence_path),
            flush_on_write: false, // batch flush for lower I/O overhead
        }
    };

    (coalescer, evidence_sink)
}

/// Cass-specific frame budget profile tuned for visual stability.
///
/// Rationale:
/// - Keep `allow_frame_skip=false` so we don't drop whole frames in interactive UX.
/// - Use longer cooldown + higher upgrade threshold to reduce degradation oscillation.
/// - Scale phase budgets above ftui defaults so overrun signals are meaningful with a
///   120ms total frame target, while preserving style layers on capable terminals.
fn cass_runtime_budget_config() -> ftui::render::budget::FrameBudgetConfig {
    use ftui::render::budget::{FrameBudgetConfig, PhaseBudgets};

    FrameBudgetConfig {
        total: Duration::from_millis(120),
        phase_budgets: PhaseBudgets {
            diff: Duration::from_millis(6),
            present: Duration::from_millis(12),
            render: Duration::from_millis(24),
        },
        allow_frame_skip: false,
        degradation_cooldown: 20,
        upgrade_threshold: 0.40,
    }
}

fn env_truthy_opt(raw: Option<String>) -> bool {
    raw.map(|v| {
        matches!(
            v.trim().to_ascii_lowercase().as_str(),
            "1" | "true" | "yes" | "on"
        )
    })
    .unwrap_or(false)
}

fn should_upgrade_style_profile_for_dumb_term(
    style_options: StyleOptions,
    term_is_dumb: bool,
    allow_raw_dumb: bool,
    headless: bool,
    explicit_no_color: bool,
    explicit_color_profile: bool,
) -> bool {
    term_is_dumb
        && !allow_raw_dumb
        && !headless
        && !explicit_no_color
        && !explicit_color_profile
        && style_options.color_profile != ftui::ColorProfile::TrueColor
}

/// Run the cass TUI using the ftui Program runtime.
///
/// This replaces the manual crossterm event loop in `run_tui()`.
/// The ftui runtime handles terminal lifecycle (raw mode, alt-screen),
/// event polling, rendering, and cleanup via RAII.
///
/// When `inline_config` is `Some`, the TUI runs in inline mode: the UI
/// chrome is anchored (top or bottom) within the terminal and scrollback
/// is preserved. When `None`, fullscreen alt-screen mode is used.
///
/// When `macro_config` has a `record_path`, events are recorded and saved
/// to the specified file on exit. When `play_path` is set, events are
/// loaded and replayed.
pub fn run_tui_ftui(
    inline_config: Option<InlineTuiConfig>,
    macro_config: MacroConfig,
    data_dir_override: Option<PathBuf>,
) -> anyhow::Result<()> {
    use ftui::ProgramConfig;
    use ftui::core::capability_override::{CapabilityOverride, push_override};
    use ftui::runtime::MouseCapturePolicy;

    // Auto-upgrade obviously bad inherited terminal profiles in interactive
    // TUI sessions. This keeps UX consistent when wrapper shells export
    // TERM=dumb even though the host terminal supports rich features.
    let term_raw = dotenvy::var("TERM").unwrap_or_default();
    let term_lower = term_raw.trim().to_ascii_lowercase();
    let term_is_dumb = term_lower == "dumb";
    let allow_raw_dumb = env_truthy_opt(dotenvy::var("CASS_ALLOW_DUMB_TERM").ok());
    let headless = dotenvy::var("TUI_HEADLESS").is_ok();
    let explicit_no_color = env_truthy_opt(dotenvy::var("CASS_NO_COLOR").ok())
        || (env_truthy_opt(dotenvy::var("CASS_RESPECT_NO_COLOR").ok())
            && dotenvy::var("NO_COLOR").is_ok());
    let explicit_color_profile = dotenvy::var("CASS_COLOR_PROFILE").is_ok();
    let _caps_override = if term_is_dumb && !allow_raw_dumb && !headless {
        eprintln!(
            "info: TERM=dumb detected; enabling compatibility TUI profile (rich color + unicode, safe controls)."
        );
        Some(push_override(
            CapabilityOverride::new()
                .true_color(Some(true))
                .colors_256(Some(true))
                .unicode_box_drawing(Some(true))
                .unicode_emoji(Some(true))
                .double_width(Some(true))
                .scroll_region(Some(true))
                .focus_events(Some(true))
                .bracketed_paste(Some(true))
                .mouse_sgr(Some(true))
                .osc52_clipboard(Some(true))
                .sync_output(Some(false))
                .osc8_hyperlinks(Some(false))
                .kitty_keyboard(Some(false)),
        ))
    } else {
        None
    };

    let mut model = CassApp::default();
    if should_upgrade_style_profile_for_dumb_term(
        model.style_options,
        term_is_dumb,
        allow_raw_dumb,
        headless,
        explicit_no_color,
        explicit_color_profile,
    ) {
        // TERM=dumb wrappers often force a monochrome inferred style profile.
        // If the user did not explicitly opt into no-color or an explicit
        // profile, align style profile with the rich compatibility caps.
        model.style_options.color_profile = ftui::ColorProfile::TrueColor;
        model.style_options.no_color = false;
        eprintln!("info: TERM=dumb compatibility also upgraded style color profile to truecolor.");
    }
    let data_dir = data_dir_override.unwrap_or_else(crate::default_data_dir);
    model.data_dir = data_dir.clone();
    model.db_path = data_dir.join("agent_search.db");
    model.refresh_theme_config_from_data_dir();
    model.search_service = match crate::search::tantivy::index_dir(&data_dir) {
        Ok(index_path) => match crate::search::query::SearchClient::open_with_options(
            &index_path,
            Some(&model.db_path),
            crate::search::query::SearchClientOptions {
                enable_reload: true,
                enable_warm: true,
            },
        ) {
            Ok(Some(client)) => {
                let service = TantivySearchService::new(Arc::new(client));
                Some(Arc::new(service))
            }
            Ok(None) => {
                if model.status.is_empty() {
                    model.status =
                        "Search index not found. Run `cass index --full` to enable search."
                            .to_string();
                }
                None
            }
            Err(e) => {
                if model.status.is_empty() {
                    model.status = format!("Search unavailable: failed to open index ({e})");
                }
                None
            }
        },
        Err(e) => {
            if model.status.is_empty() {
                model.status = format!("Search unavailable: failed to resolve index path ({e})");
            }
            None
        }
    };

    // Quality-first budget profile: favor full visuals and smooth transitions.
    let budget = cass_runtime_budget_config();

    // Resize coalescer + evidence sink — shared across all launch modes.
    let (coalescer, evidence_sink) = build_resize_config(&data_dir);

    // Build ProgramConfig once — all launch paths share this baseline.
    let mut config = if let Some(ref cfg) = inline_config {
        let mut c = ProgramConfig::inline(cfg.ui_height);
        c.ui_anchor = cfg.anchor;
        c
    } else {
        ProgramConfig::fullscreen()
    };
    config.budget = budget;
    config.mouse_capture_policy = MouseCapturePolicy::On;
    config.resize_coalescer = coalescer;
    config.evidence_sink = evidence_sink;

    // Load macro playback data into model before program creation.
    if let Some(ref play_path) = macro_config.play_path {
        let macro_data = macro_file::load_macro(play_path)?;
        eprintln!(
            "Playing macro: {} ({} events, {:.1}s)",
            macro_data.metadata().name,
            macro_data.len(),
            macro_data.total_duration().as_secs_f64()
        );
        model.macro_playback = Some(MacroPlayback::new(macro_data));
    }

    // All paths use the native ftui backend (no crossterm compat).
    let mut program = ftui::Program::with_native_backend(model, config)
        .map_err(|e| anyhow::anyhow!("ftui program creation error: {e}"))?;

    if macro_config.record_path.is_some() {
        program.start_recording("cass-session");
    }

    let result = program.run();

    // Save recorded macro on exit (only if recording was active).
    if let Some(ref record_path) = macro_config.record_path
        && let Some(recorded) = program.stop_recording()
    {
        macro_file::save_macro(record_path, &recorded, false)?;
        eprintln!("Macro saved to: {}", record_path.display());
    }

    result.map_err(|e| anyhow::anyhow!("ftui runtime error: {e}"))
}

/// Macro file serialization/deserialization.
mod macro_file {
    use std::io::{BufRead, BufReader, Write};
    use std::path::Path;
    use std::time::Duration;

    use ftui::runtime::input_macro::MacroMetadata;
    use ftui::runtime::{InputMacro, TimedEvent};
    use ftui::{Event, KeyCode, KeyEvent, Modifiers};

    /// Save an InputMacro to a JSONL file.
    ///
    /// When `redact_paths` is true, absolute directory paths in Paste events
    /// are replaced with `~` to avoid leaking sensitive filesystem layout.
    pub fn save_macro(
        path: &Path,
        input_macro: &InputMacro,
        redact_paths: bool,
    ) -> anyhow::Result<()> {
        let home_dir = dirs::home_dir().unwrap_or_default();
        let mut file = std::fs::File::create(path)?;

        // Header line with metadata.
        let meta = input_macro.metadata();
        writeln!(
            file,
            "{{\"type\":\"header\",\"name\":{},\"terminal_size\":[{},{}],\"total_duration_ms\":{},\"event_count\":{}}}",
            serde_json::to_string(&meta.name)?,
            meta.terminal_size.0,
            meta.terminal_size.1,
            meta.total_duration.as_millis(),
            input_macro.len()
        )?;

        // One line per event.
        for timed in input_macro.events() {
            let event = if redact_paths {
                redact_event_paths(&timed.event, &home_dir)
            } else {
                timed.event.clone()
            };
            let event_json = serialize_event(&event);
            writeln!(
                file,
                "{{\"type\":\"event\",\"delay_ms\":{},\"event\":{}}}",
                timed.delay.as_millis(),
                event_json
            )?;
        }

        Ok(())
    }

    /// Load an InputMacro from a JSONL file.
    pub fn load_macro(path: &Path) -> anyhow::Result<InputMacro> {
        let file = std::fs::File::open(path)?;
        let reader = BufReader::new(file);
        let mut events = Vec::new();
        let mut name = String::from("loaded");
        let mut terminal_size = (80u16, 24u16);
        let mut total_duration = Duration::ZERO;

        for line in reader.lines() {
            let line = line?;
            let v: serde_json::Value = serde_json::from_str(&line)?;

            match v.get("type").and_then(|t| t.as_str()) {
                Some("header") => {
                    name = v
                        .get("name")
                        .and_then(|n| n.as_str())
                        .unwrap_or("loaded")
                        .to_string();
                    if let (Some(w), Some(h)) = (
                        v.get("terminal_size")
                            .and_then(|s| s.get(0))
                            .and_then(|n| n.as_u64()),
                        v.get("terminal_size")
                            .and_then(|s| s.get(1))
                            .and_then(|n| n.as_u64()),
                    ) {
                        terminal_size = (w as u16, h as u16);
                    }
                    if let Some(ms) = v.get("total_duration_ms").and_then(|n| n.as_u64()) {
                        total_duration = Duration::from_millis(ms);
                    }
                }
                Some("event") => {
                    let delay_ms = v.get("delay_ms").and_then(|n| n.as_u64()).unwrap_or(0);
                    if let Some(event_val) = v.get("event")
                        && let Some(event) = deserialize_event(event_val)
                    {
                        events.push(TimedEvent::new(event, Duration::from_millis(delay_ms)));
                    }
                }
                _ => {} // Skip unknown line types
            }
        }

        let metadata = MacroMetadata {
            name,
            terminal_size,
            total_duration,
        };

        Ok(InputMacro::new(events, metadata))
    }

    fn serialize_event(event: &Event) -> String {
        match event {
            Event::Key(key) => {
                let code = serialize_keycode(&key.code);
                let mods = serialize_modifiers(key.modifiers);
                format!("{{\"key\":{code},\"modifiers\":{mods}}}")
            }
            Event::Resize { width, height } => {
                format!("{{\"resize\":[{width},{height}]}}")
            }
            Event::Focus(gained) => {
                format!("{{\"focus\":{gained}}}")
            }
            Event::Paste(paste) => {
                let text = serde_json::to_string(&paste.text).unwrap_or_default();
                format!("{{\"paste\":{text}}}")
            }
            Event::Mouse(_) => {
                // Mouse events are not serialized for macro files
                "null".to_string()
            }
            _ => "null".to_string(),
        }
    }

    fn serialize_keycode(code: &KeyCode) -> String {
        match code {
            KeyCode::Char(c) => {
                let s = serde_json::to_string(&c.to_string()).unwrap_or_default();
                format!("{{\"char\":{s}}}")
            }
            KeyCode::Enter => "\"Enter\"".to_string(),
            KeyCode::Backspace => "\"Backspace\"".to_string(),
            KeyCode::Tab => "\"Tab\"".to_string(),
            KeyCode::Escape => "\"Escape\"".to_string(),
            KeyCode::Up => "\"Up\"".to_string(),
            KeyCode::Down => "\"Down\"".to_string(),
            KeyCode::Left => "\"Left\"".to_string(),
            KeyCode::Right => "\"Right\"".to_string(),
            KeyCode::Home => "\"Home\"".to_string(),
            KeyCode::End => "\"End\"".to_string(),
            KeyCode::PageUp => "\"PageUp\"".to_string(),
            KeyCode::PageDown => "\"PageDown\"".to_string(),
            KeyCode::Delete => "\"Delete\"".to_string(),
            KeyCode::Insert => "\"Insert\"".to_string(),
            KeyCode::F(n) => format!("{{\"f\":{n}}}"),
            _ => "null".to_string(),
        }
    }

    fn serialize_modifiers(mods: Modifiers) -> String {
        let mut parts = Vec::new();
        if mods.contains(Modifiers::SHIFT) {
            parts.push("\"shift\"");
        }
        if mods.contains(Modifiers::CTRL) {
            parts.push("\"ctrl\"");
        }
        if mods.contains(Modifiers::ALT) {
            parts.push("\"alt\"");
        }
        format!("[{}]", parts.join(","))
    }

    fn deserialize_event(v: &serde_json::Value) -> Option<Event> {
        if v.is_null() {
            return None;
        }

        if let Some(key_val) = v.get("key") {
            let code = deserialize_keycode(key_val)?;
            let modifiers = v
                .get("modifiers")
                .map(deserialize_modifiers)
                .unwrap_or(Modifiers::empty());
            return Some(Event::Key(KeyEvent {
                code,
                modifiers,
                kind: ftui::KeyEventKind::Press,
            }));
        }

        if let Some(resize) = v.get("resize") {
            let w = resize.get(0)?.as_u64()? as u16;
            let h = resize.get(1)?.as_u64()? as u16;
            return Some(Event::Resize {
                width: w,
                height: h,
            });
        }

        if let Some(focus) = v.get("focus") {
            return Some(Event::Focus(focus.as_bool()?));
        }

        if let Some(paste) = v.get("paste") {
            return Some(Event::Paste(ftui::core::event::PasteEvent {
                text: paste.as_str()?.to_string(),
                bracketed: true,
            }));
        }

        None
    }

    fn deserialize_keycode(v: &serde_json::Value) -> Option<KeyCode> {
        if let Some(s) = v.as_str() {
            return match s {
                "Enter" => Some(KeyCode::Enter),
                "Backspace" => Some(KeyCode::Backspace),
                "Tab" => Some(KeyCode::Tab),
                "Escape" => Some(KeyCode::Escape),
                "Up" => Some(KeyCode::Up),
                "Down" => Some(KeyCode::Down),
                "Left" => Some(KeyCode::Left),
                "Right" => Some(KeyCode::Right),
                "Home" => Some(KeyCode::Home),
                "End" => Some(KeyCode::End),
                "PageUp" => Some(KeyCode::PageUp),
                "PageDown" => Some(KeyCode::PageDown),
                "Delete" => Some(KeyCode::Delete),
                "Insert" => Some(KeyCode::Insert),
                _ => None,
            };
        }

        if let Some(obj) = v.as_object() {
            if let Some(c) = obj.get("char").and_then(|c| c.as_str()) {
                return c.chars().next().map(KeyCode::Char);
            }
            if let Some(n) = obj.get("f").and_then(|n| n.as_u64()) {
                return Some(KeyCode::F(n as u8));
            }
        }

        None
    }

    fn deserialize_modifiers(v: &serde_json::Value) -> Modifiers {
        let mut mods = Modifiers::empty();
        if let Some(arr) = v.as_array() {
            for item in arr {
                if let Some(s) = item.as_str() {
                    match s {
                        "shift" => mods |= Modifiers::SHIFT,
                        "ctrl" => mods |= Modifiers::CTRL,
                        "alt" => mods |= Modifiers::ALT,
                        _ => {}
                    }
                }
            }
        }
        mods
    }

    /// Replace absolute paths in Paste events with `~` to avoid leaking
    /// sensitive filesystem layout in shared macro files.
    fn redact_event_paths(event: &Event, home: &std::path::Path) -> Event {
        match event {
            Event::Paste(paste) => {
                let home_str = home.to_string_lossy();
                let redacted = if !home_str.is_empty() {
                    paste.text.replace(home_str.as_ref(), "~")
                } else {
                    paste.text.clone()
                };
                Event::Paste(ftui::core::event::PasteEvent {
                    text: redacted,
                    bracketed: paste.bracketed,
                })
            }
            other => other.clone(),
        }
    }

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn roundtrip_key_event() {
            let event = Event::Key(KeyEvent {
                code: KeyCode::Char('a'),
                modifiers: Modifiers::CTRL,
                kind: ftui::KeyEventKind::Press,
            });
            let json = serialize_event(&event);
            let parsed: serde_json::Value = serde_json::from_str(&json).unwrap();
            let restored = deserialize_event(&parsed).unwrap();
            assert!(matches!(&restored, Event::Key(_)), "expected Key event");
            if let Event::Key(k) = restored {
                assert_eq!(k.code, KeyCode::Char('a'));
                assert!(k.modifiers.contains(Modifiers::CTRL));
            }
        }

        #[test]
        fn roundtrip_special_keys() {
            for code in [
                KeyCode::Enter,
                KeyCode::Escape,
                KeyCode::Tab,
                KeyCode::Backspace,
                KeyCode::Up,
                KeyCode::Down,
                KeyCode::F(5),
            ] {
                let event = Event::Key(KeyEvent {
                    code,
                    modifiers: Modifiers::empty(),
                    kind: ftui::KeyEventKind::Press,
                });
                let json = serialize_event(&event);
                let parsed: serde_json::Value = serde_json::from_str(&json).unwrap();
                let restored = deserialize_event(&parsed).unwrap();
                assert!(
                    matches!(&restored, Event::Key(_)),
                    "expected Key event for {:?}",
                    code
                );
                if let Event::Key(k) = restored {
                    assert_eq!(k.code, code, "roundtrip failed for {:?}", code);
                }
            }
        }

        #[test]
        fn roundtrip_resize_event() {
            let event = Event::Resize {
                width: 120,
                height: 40,
            };
            let json = serialize_event(&event);
            let parsed: serde_json::Value = serde_json::from_str(&json).unwrap();
            let restored = deserialize_event(&parsed).unwrap();
            assert!(matches!(
                restored,
                Event::Resize {
                    width: 120,
                    height: 40
                }
            ));
        }

        #[test]
        fn roundtrip_modifier_combinations() {
            let mods = Modifiers::SHIFT | Modifiers::ALT;
            let json = serialize_modifiers(mods);
            let parsed: serde_json::Value = serde_json::from_str(&json).unwrap();
            let restored = deserialize_modifiers(&parsed);
            assert!(restored.contains(Modifiers::SHIFT));
            assert!(restored.contains(Modifiers::ALT));
            assert!(!restored.contains(Modifiers::CTRL));
        }

        #[test]
        fn save_load_roundtrip() {
            let events = vec![
                TimedEvent::new(
                    Event::Key(KeyEvent {
                        code: KeyCode::Char('h'),
                        modifiers: Modifiers::empty(),
                        kind: ftui::KeyEventKind::Press,
                    }),
                    Duration::from_millis(100),
                ),
                TimedEvent::new(
                    Event::Key(KeyEvent {
                        code: KeyCode::Enter,
                        modifiers: Modifiers::empty(),
                        kind: ftui::KeyEventKind::Press,
                    }),
                    Duration::from_millis(200),
                ),
                TimedEvent::new(
                    Event::Key(KeyEvent {
                        code: KeyCode::Escape,
                        modifiers: Modifiers::empty(),
                        kind: ftui::KeyEventKind::Press,
                    }),
                    Duration::from_millis(50),
                ),
            ];
            let metadata = MacroMetadata {
                name: "test-macro".to_string(),
                terminal_size: (80, 24),
                total_duration: Duration::from_millis(350),
            };
            let original = InputMacro::new(events, metadata);

            let tmp = tempfile::NamedTempFile::new().unwrap();
            save_macro(tmp.path(), &original, false).unwrap();
            let loaded = load_macro(tmp.path()).unwrap();

            assert_eq!(loaded.len(), 3);
            assert_eq!(loaded.metadata().name, "test-macro");
            assert_eq!(loaded.metadata().terminal_size, (80, 24));
        }

        #[test]
        fn null_events_are_skipped() {
            let event = Event::Mouse(ftui::MouseEvent {
                kind: ftui::MouseEventKind::Moved,
                x: 0,
                y: 0,
                modifiers: Modifiers::empty(),
            });
            let json = serialize_event(&event);
            assert_eq!(json, "null");
            let parsed: serde_json::Value = serde_json::from_str(&json).unwrap();
            assert!(deserialize_event(&parsed).is_none());
        }

        #[test]
        fn path_redaction_replaces_home_dir_in_paste() {
            let home = std::path::PathBuf::from("/home/testuser");
            let event = Event::Paste(ftui::core::event::PasteEvent {
                text: "/home/testuser/projects/foo/bar.rs".to_string(),
                bracketed: true,
            });
            let redacted = redact_event_paths(&event, &home);
            assert!(matches!(&redacted, Event::Paste(_)), "expected Paste event");
            if let Event::Paste(p) = redacted {
                assert_eq!(p.text, "~/projects/foo/bar.rs");
                assert!(p.bracketed);
            }
        }

        #[test]
        fn path_redaction_preserves_non_paste_events() {
            let home = std::path::PathBuf::from("/home/testuser");
            let event = Event::Key(KeyEvent {
                code: KeyCode::Char('a'),
                modifiers: Modifiers::empty(),
                kind: ftui::KeyEventKind::Press,
            });
            let redacted = redact_event_paths(&event, &home);
            assert!(matches!(redacted, Event::Key(_)));
        }

        #[test]
        fn save_load_roundtrip_with_redaction() {
            let events = vec![
                TimedEvent::new(
                    Event::Paste(ftui::core::event::PasteEvent {
                        text: "/home/testuser/secret/data.txt".to_string(),
                        bracketed: true,
                    }),
                    Duration::from_millis(100),
                ),
                TimedEvent::new(
                    Event::Key(KeyEvent {
                        code: KeyCode::Enter,
                        modifiers: Modifiers::empty(),
                        kind: ftui::KeyEventKind::Press,
                    }),
                    Duration::from_millis(50),
                ),
            ];
            let metadata = MacroMetadata {
                name: "redact-test".to_string(),
                terminal_size: (80, 24),
                total_duration: Duration::from_millis(150),
            };
            let original = InputMacro::new(events, metadata);

            let tmp = tempfile::NamedTempFile::new().unwrap();
            // Save with redaction using /home/testuser as home dir.
            // We test by temporarily overriding... actually just use the function directly.
            save_macro(tmp.path(), &original, true).unwrap();
            let loaded = load_macro(tmp.path()).unwrap();

            assert_eq!(loaded.len(), 2);
            // The paste event should have the home dir replaced.
            // Note: redaction depends on dirs::home_dir(), which may differ.
            // So we verify the key event survived intact.
            assert_eq!(loaded.metadata().name, "redact-test");
        }
    }
}

// =========================================================================
// Clipboard & editor helpers
// =========================================================================

fn split_editor_command(editor: &str) -> (String, Vec<String>) {
    let trimmed = editor.trim();
    if trimmed.is_empty() {
        return ("vi".to_string(), Vec::new());
    }
    match shell_words::split(trimmed) {
        Ok(parts) if !parts.is_empty() => (parts[0].clone(), parts[1..].to_vec()),
        _ => (trimmed.to_string(), Vec::new()),
    }
}

#[cfg(test)]
fn copy_to_clipboard(_text: &str) -> Result<(), String> {
    Ok(())
}

/// Copy text to the system clipboard using OSC52 with fallback to external tools.
///
/// Uses ftui-extras [`Clipboard::auto`] for full auto-detection: OSC52 (works
/// over SSH), multiplexer passthrough (tmux/screen), then external tools
/// (pbcopy/wl-copy/xclip/xsel).
#[cfg(not(test))]
fn copy_to_clipboard(text: &str) -> Result<(), String> {
    use ftui::TerminalCapabilities;
    use ftui_extras::clipboard::{Clipboard, ClipboardSelection};

    if text.is_empty() {
        return Ok(());
    }

    let caps = TerminalCapabilities::detect();
    let clipboard = Clipboard::auto(caps);

    if !clipboard.is_available() {
        return Err(
            "no clipboard backend available (no OSC52 support and no clipboard tool found)"
                .to_string(),
        );
    }

    let mut stdout = std::io::stdout();
    clipboard
        .set(text, ClipboardSelection::Clipboard, &mut stdout)
        .map_err(|e| format!("{e}"))
}

#[cfg(test)]
fn run_editor_command(_cmd: &mut StdCommand) -> Result<(), String> {
    Ok(())
}

#[cfg(not(test))]
fn run_editor_command(cmd: &mut StdCommand) -> Result<(), String> {
    let program = cmd.get_program().to_string_lossy().into_owned();
    let status = cmd
        .status()
        .map_err(|e| format!("failed to launch editor '{program}': {e}"))?;
    if status.success() {
        Ok(())
    } else {
        Err(format!("editor '{program}' exited with {status}"))
    }
}

/// Open one or more search hits in an editor. Returns `(count_opened, editor_binary)`.
fn open_hits_in_editor(hits: &[SearchHit], editor_cmd: &str) -> Result<(usize, String), String> {
    if hits.is_empty() {
        return Ok((0, String::new()));
    }
    let (editor_bin, editor_args) = split_editor_command(editor_cmd);
    for hit in hits {
        let mut cmd = StdCommand::new(&editor_bin);
        cmd.args(&editor_args);
        if editor_bin == "code" {
            if let Some(line) = hit.line_number {
                cmd.arg("--goto").arg(format!("{}:{line}", hit.source_path));
            } else {
                cmd.arg(&hit.source_path);
            }
        } else if editor_bin == "vim"
            || editor_bin == "vi"
            || editor_bin == "nvim"
            || editor_bin == "nano"
        {
            if let Some(line) = hit.line_number {
                cmd.arg(format!("+{line}"));
            }
            cmd.arg(&hit.source_path);
        } else {
            cmd.arg(&hit.source_path);
        }
        run_editor_command(&mut cmd)?;
    }
    Ok((hits.len(), editor_bin))
}

// =========================================================================
// Tests
// =========================================================================

#[cfg(test)]
#[allow(clippy::field_reassign_with_default)]
mod tests {
    use super::*;
    use crate::ftui_harness;
    use crate::model::types::Message;
    use crate::search::query::MatchType;
    use crate::ui::components::palette::PaletteAction;
    use std::sync::{Arc, Mutex};

    #[derive(Clone)]
    struct TraceBufferWriter(Arc<Mutex<Vec<u8>>>);

    impl std::io::Write for TraceBufferWriter {
        fn write(&mut self, buf: &[u8]) -> std::io::Result<usize> {
            if let Ok(mut bytes) = self.0.lock() {
                bytes.extend_from_slice(buf);
            }
            Ok(buf.len())
        }

        fn flush(&mut self) -> std::io::Result<()> {
            Ok(())
        }
    }

    fn capture_trace_output<F>(f: F) -> String
    where
        F: FnOnce(),
    {
        let sink = Arc::new(Mutex::new(Vec::new()));
        let writer = TraceBufferWriter(sink.clone());
        let subscriber = tracing_subscriber::fmt()
            .with_ansi(false)
            .without_time()
            .with_max_level(tracing::Level::DEBUG)
            .with_level(false)
            .with_target(false)
            .with_writer(move || writer.clone())
            .finish();

        tracing::subscriber::with_default(subscriber, f);
        String::from_utf8(sink.lock().map(|b| b.clone()).unwrap_or_default()).unwrap_or_default()
    }

    #[test]
    fn cass_app_default_initializes_with_sane_defaults() {
        let app = CassApp::default();
        assert!(app.query.is_empty());
        assert!(app.panes.is_empty());
        assert!(app.results.is_empty());
        assert_eq!(app.active_pane, 0);
        assert_eq!(app.per_pane_limit, 0);
        assert_eq!(app.input_mode, InputMode::Query);
        assert_eq!(app.focused_region(), FocusRegion::Results);
        assert_eq!(app.search_mode, SearchMode::Lexical);
        assert_eq!(app.match_mode, MatchMode::Standard);
        assert_eq!(app.ranking_mode, RankingMode::Balanced);
        assert_eq!(app.context_window, ContextWindow::Medium);
        assert_eq!(app.density_mode, DensityMode::Cozy);
        assert!(app.theme_dark);
        assert_eq!(app.theme_preset, UiThemePreset::Dark);
        assert!(app.fancy_borders);
        assert!(!app.show_help);
        assert!(!app.show_detail_modal);
        assert!(!app.show_export_modal);
        assert!(!app.show_bulk_modal);
        assert!(!app.show_consent_dialog);
        assert!(!app.source_filter_menu_open);
        assert_eq!(app.source_filter_menu_selection, 0);
        assert!(app.available_source_ids.is_empty());
        assert!(app.selected.is_empty());
        assert!(app.saved_views.is_empty());
        assert!(app.query_history.is_empty());
    }

    #[test]
    fn model_download_accepted_closes_consent_and_sets_downloading_state() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::ConsentDialogOpened);
        assert!(app.show_consent_dialog);

        let _ = app.update(CassMsg::ModelDownloadAccepted);

        assert!(!app.show_consent_dialog);
        assert!(matches!(
            app.semantic_availability,
            SemanticAvailability::Downloading {
                progress_pct: 0,
                bytes_downloaded: 0,
                total_bytes: 0
            }
        ));
        assert!(app.status.contains("Starting semantic model download"));
        assert_eq!(app.toast_manager.len(), 1);
    }

    #[test]
    fn model_download_progress_updates_downloading_state() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::ModelDownloadProgress {
            bytes_downloaded: 50,
            total: 100,
        });

        assert!(matches!(
            app.semantic_availability,
            SemanticAvailability::Downloading {
                progress_pct: 50,
                bytes_downloaded: 50,
                total_bytes: 100
            }
        ));
        assert!(app.status.contains("50%"));
    }

    #[test]
    fn model_download_completed_sets_ready_state() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::ModelDownloadCompleted);

        assert!(matches!(
            app.semantic_availability,
            SemanticAvailability::Ready { .. }
        ));
        assert!(app.status.contains("Semantic model ready"));
        assert_eq!(app.toast_manager.len(), 1);
    }

    #[test]
    fn model_download_failed_sets_not_installed_state() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::ModelDownloadFailed("network timeout".to_string()));

        assert!(matches!(
            app.semantic_availability,
            SemanticAvailability::NotInstalled
        ));
        assert!(app.status.contains("network timeout"));
        assert_eq!(app.toast_manager.len(), 1);
    }

    #[test]
    fn hash_mode_accept_sets_hash_fallback_state() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::ConsentDialogOpened);
        assert!(app.show_consent_dialog);

        let _ = app.update(CassMsg::HashModeAccepted);

        assert!(!app.show_consent_dialog);
        assert!(matches!(
            app.semantic_availability,
            SemanticAvailability::HashFallback
        ));
        assert!(app.status.contains("hash embedder fallback"));
        assert_eq!(app.toast_manager.len(), 1);
    }

    #[test]
    fn model_download_events_do_not_override_hash_fallback() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::HashModeAccepted);
        let status_after_hash = app.status.clone();

        let _ = app.update(CassMsg::ModelDownloadProgress {
            bytes_downloaded: 10,
            total: 100,
        });
        assert!(matches!(
            app.semantic_availability,
            SemanticAvailability::HashFallback
        ));
        assert_eq!(app.status, status_after_hash);

        let _ = app.update(CassMsg::ModelDownloadCompleted);
        assert!(matches!(
            app.semantic_availability,
            SemanticAvailability::HashFallback
        ));
        assert_eq!(app.status, status_after_hash);

        let _ = app.update(CassMsg::ModelDownloadFailed("late failure".to_string()));
        assert!(matches!(
            app.semantic_availability,
            SemanticAvailability::HashFallback
        ));
        assert_eq!(app.status, status_after_hash);

        let _ = app.update(CassMsg::ModelDownloadCancelled);
        assert!(matches!(
            app.semantic_availability,
            SemanticAvailability::HashFallback
        ));
        assert_eq!(app.status, status_after_hash);
    }

    #[test]
    fn all_detail_tab_variants_constructible() {
        let _msgs = DetailTab::Messages;
        let _snip = DetailTab::Snippets;
        let _raw = DetailTab::Raw;
        let _json = DetailTab::Json;
        let _analytics = DetailTab::Analytics;
    }

    #[test]
    fn all_match_mode_variants_constructible() {
        let _std = MatchMode::Standard;
        let _pfx = MatchMode::Prefix;
    }

    #[test]
    fn all_ranking_mode_variants_constructible() {
        let _rh = RankingMode::RecentHeavy;
        let _bal = RankingMode::Balanced;
        let _rel = RankingMode::RelevanceHeavy;
        let _mq = RankingMode::MatchQualityHeavy;
        let _dn = RankingMode::DateNewest;
        let _do_ = RankingMode::DateOldest;
    }

    #[test]
    fn all_context_window_variants_constructible() {
        let _s = ContextWindow::Small;
        let _m = ContextWindow::Medium;
        let _l = ContextWindow::Large;
        let _xl = ContextWindow::XLarge;
    }

    #[test]
    fn all_density_mode_variants_constructible() {
        let _c = DensityMode::Compact;
        let _co = DensityMode::Cozy;
        let _s = DensityMode::Spacious;
    }

    #[test]
    fn all_focus_region_variants_constructible() {
        let _r = FocusRegion::Results;
        let _d = FocusRegion::Detail;
    }

    #[test]
    fn cass_msg_key_variants_constructible() {
        // Verify a representative sample of message variants compile.
        let _q = CassMsg::QueryChanged("test".into());
        let _s = CassMsg::SearchRequested;
        let _f = CassMsg::FiltersClearAll;
        let _m = CassMsg::SearchModeCycled;
        let _n = CassMsg::SelectionMoved { delta: 1 };
        let _d = CassMsg::DetailOpened;
        let _p = CassMsg::PaletteOpened;
        let _h = CassMsg::HelpToggled;
        let _t = CassMsg::ThemeToggled;
        let _cm = CassMsg::CursorMoved { delta: 1 };
        let _cj = CassMsg::CursorJumped { to_end: true };
        let _tick = CassMsg::Tick;
        let _quit = CassMsg::QuitRequested;
        let _fq = CassMsg::ForceQuit;
    }

    #[test]
    fn event_mapping_ctrl_shift_y_maps_to_copy_query() {
        use crate::ui::ftui_adapter::{Event, KeyCode, KeyEvent, Modifiers};

        let event = Event::Key(
            KeyEvent::new(KeyCode::Char('y')).with_modifiers(Modifiers::CTRL | Modifiers::SHIFT),
        );

        assert!(matches!(CassMsg::from(event), CassMsg::CopyQuery));
    }

    #[test]
    fn event_mapping_ctrl_y_maps_to_copy_path() {
        use crate::ui::ftui_adapter::{Event, KeyCode, KeyEvent, Modifiers};

        let event = Event::Key(KeyEvent::new(KeyCode::Char('y')).with_modifiers(Modifiers::CTRL));

        assert!(matches!(CassMsg::from(event), CassMsg::CopyPath));
    }

    #[test]
    fn event_mapping_ctrl_m_maps_to_detail_opened() {
        use crate::ui::ftui_adapter::{Event, KeyCode, KeyEvent, Modifiers};

        let event = Event::Key(KeyEvent::new(KeyCode::Char('m')).with_modifiers(Modifiers::CTRL));

        assert!(matches!(CassMsg::from(event), CassMsg::DetailOpened));
    }

    #[test]
    fn event_mapping_ctrl_j_maps_to_detail_opened() {
        use crate::ui::ftui_adapter::{Event, KeyCode, KeyEvent, Modifiers};

        let event = Event::Key(KeyEvent::new(KeyCode::Char('j')).with_modifiers(Modifiers::CTRL));

        assert!(matches!(CassMsg::from(event), CassMsg::DetailOpened));
    }

    #[test]
    fn event_mapping_ctrl_s_maps_to_stats_bar_toggled() {
        use crate::ui::ftui_adapter::{Event, KeyCode, KeyEvent, Modifiers};

        let event = Event::Key(KeyEvent::new(KeyCode::Char('s')).with_modifiers(Modifiers::CTRL));

        assert!(matches!(CassMsg::from(event), CassMsg::StatsBarToggled));
    }

    #[test]
    fn event_mapping_ctrl_shift_s_maps_to_sources_entered() {
        use crate::ui::ftui_adapter::{Event, KeyCode, KeyEvent, Modifiers};

        let event = Event::Key(
            KeyEvent::new(KeyCode::Char('s')).with_modifiers(Modifiers::CTRL | Modifiers::SHIFT),
        );

        assert!(matches!(CassMsg::from(event), CassMsg::SourcesEntered));
    }

    #[test]
    fn event_mapping_alt_h_maps_to_help_toggled() {
        use crate::ui::ftui_adapter::{Event, KeyCode, KeyEvent, Modifiers};

        let event = Event::Key(KeyEvent::new(KeyCode::Char('h')).with_modifiers(Modifiers::ALT));

        assert!(matches!(CassMsg::from(event), CassMsg::HelpToggled));
    }

    #[test]
    fn event_mapping_alt_t_maps_to_theme_editor_opened() {
        use crate::ui::ftui_adapter::{Event, KeyCode, KeyEvent, Modifiers};

        let event = Event::Key(KeyEvent::new(KeyCode::Char('t')).with_modifiers(Modifiers::ALT));

        assert!(matches!(CassMsg::from(event), CassMsg::ThemeEditorOpened));
    }

    #[test]
    fn event_mapping_alt_a_maps_to_analytics_entered() {
        use crate::ui::ftui_adapter::{Event, KeyCode, KeyEvent, Modifiers};

        let event = Event::Key(KeyEvent::new(KeyCode::Char('a')).with_modifiers(Modifiers::ALT));

        assert!(matches!(CassMsg::from(event), CassMsg::AnalyticsEntered));
    }

    #[test]
    fn event_mapping_space_maps_to_query_changed_space() {
        use crate::ui::ftui_adapter::{Event, KeyCode, KeyEvent};

        let event = Event::Key(KeyEvent::new(KeyCode::Char(' ')));

        assert!(matches!(
            CassMsg::from(event),
            CassMsg::QueryChanged(q) if q == " "
        ));
    }

    #[test]
    fn event_mapping_ctrl_space_maps_to_peek_toggled() {
        use crate::ui::ftui_adapter::{Event, KeyCode, KeyEvent, Modifiers};

        let event = Event::Key(KeyEvent::new(KeyCode::Char(' ')).with_modifiers(Modifiers::CTRL));

        assert!(matches!(CassMsg::from(event), CassMsg::PeekToggled));
    }

    #[test]
    fn event_mapping_question_mark_maps_to_query_changed() {
        use crate::ui::ftui_adapter::{Event, KeyCode, KeyEvent};

        let event = Event::Key(KeyEvent::new(KeyCode::Char('?')));

        assert!(matches!(
            CassMsg::from(event),
            CassMsg::QueryChanged(q) if q == "?"
        ));
    }

    #[test]
    fn event_mapping_slash_maps_to_query_changed() {
        use crate::ui::ftui_adapter::{Event, KeyCode, KeyEvent};

        let event = Event::Key(KeyEvent::new(KeyCode::Char('/')));

        assert!(matches!(
            CassMsg::from(event),
            CassMsg::QueryChanged(q) if q == "/"
        ));
    }

    #[test]
    fn event_mapping_y_maps_to_query_changed() {
        use crate::ui::ftui_adapter::{Event, KeyCode, KeyEvent};

        let event = Event::Key(KeyEvent::new(KeyCode::Char('y')));

        assert!(matches!(
            CassMsg::from(event),
            CassMsg::QueryChanged(q) if q == "y"
        ));
    }

    #[test]
    fn event_mapping_plus_maps_to_query_changed() {
        use crate::ui::ftui_adapter::{Event, KeyCode, KeyEvent};

        let event = Event::Key(KeyEvent::new(KeyCode::Char('+')));

        assert!(matches!(
            CassMsg::from(event),
            CassMsg::QueryChanged(q) if q == "+"
        ));
    }

    #[test]
    fn event_mapping_alt_slash_maps_to_pane_filter_opened() {
        use crate::ui::ftui_adapter::{Event, KeyCode, KeyEvent, Modifiers};

        let event = Event::Key(KeyEvent::new(KeyCode::Char('/')).with_modifiers(Modifiers::ALT));

        assert!(matches!(CassMsg::from(event), CassMsg::PaneFilterOpened));
    }

    #[test]
    fn event_mapping_alt_y_maps_to_copy_snippet() {
        use crate::ui::ftui_adapter::{Event, KeyCode, KeyEvent, Modifiers};

        let event = Event::Key(KeyEvent::new(KeyCode::Char('y')).with_modifiers(Modifiers::ALT));

        assert!(matches!(CassMsg::from(event), CassMsg::CopySnippet));
    }

    #[test]
    fn event_mapping_alt_plus_maps_to_pane_grew() {
        use crate::ui::ftui_adapter::{Event, KeyCode, KeyEvent, Modifiers};

        let event = Event::Key(KeyEvent::new(KeyCode::Char('+')).with_modifiers(Modifiers::ALT));

        assert!(matches!(CassMsg::from(event), CassMsg::PaneGrew));
    }

    #[test]
    fn event_mapping_alt_equals_maps_to_pane_grew() {
        use crate::ui::ftui_adapter::{Event, KeyCode, KeyEvent, Modifiers};

        let event = Event::Key(KeyEvent::new(KeyCode::Char('=')).with_modifiers(Modifiers::ALT));

        assert!(matches!(CassMsg::from(event), CassMsg::PaneGrew));
    }

    #[test]
    fn event_mapping_key_release_is_ignored() {
        use crate::ui::ftui_adapter::{Event, KeyCode, KeyEvent};

        let event = Event::Key(KeyEvent::new(KeyCode::F(1)).with_kind(ftui::KeyEventKind::Release));
        assert!(matches!(CassMsg::from(event), CassMsg::Tick));
    }

    #[test]
    fn event_mapping_paste_maps_to_query_changed() {
        use crate::ui::ftui_adapter::Event;

        let event = Event::Paste(ftui::PasteEvent::bracketed("auth error"));
        assert!(matches!(
            CassMsg::from(event),
            CassMsg::QueryChanged(q) if q == "auth error"
        ));
    }

    #[test]
    fn event_mapping_focus_maps_to_terminal_focus_changed() {
        use crate::ui::ftui_adapter::Event;

        assert!(matches!(
            CassMsg::from(Event::Focus(true)),
            CassMsg::TerminalFocusChanged(true)
        ));
        assert!(matches!(
            CassMsg::from(Event::Focus(false)),
            CassMsg::TerminalFocusChanged(false)
        ));
    }

    #[test]
    fn persisted_state_constructible() {
        let _state = PersistedState {
            search_mode: SearchMode::Lexical,
            match_mode: MatchMode::Standard,
            ranking_mode: RankingMode::Balanced,
            context_window: ContextWindow::Medium,
            theme_dark: true,
            density_mode: DensityMode::Cozy,
            per_pane_limit: 0,
            query_history: VecDeque::new(),
            saved_views: Vec::new(),
            analytics_since_ms: None,
            analytics_until_ms: None,
            analytics_agents: HashSet::new(),
            analytics_workspaces: HashSet::new(),
            analytics_source_filter: SourceFilter::All,
            fancy_borders: true,
            help_pinned: false,
            has_seen_help: false,
        };
    }

    #[test]
    fn persisted_state_roundtrip_preserves_saved_view_metadata() {
        let tmp = tempfile::TempDir::new().expect("tempdir");
        let state_path = tmp.path().join("tui_state.json");
        let mut query_history = VecDeque::new();
        query_history.push_back("authentication error".to_string());

        let mut agents = HashSet::new();
        agents.insert("codex".to_string());
        let mut workspaces = HashSet::new();
        workspaces.insert("/repo".to_string());

        let state = PersistedState {
            search_mode: SearchMode::Hybrid,
            match_mode: MatchMode::Prefix,
            ranking_mode: RankingMode::DateNewest,
            context_window: ContextWindow::Large,
            theme_dark: false,
            density_mode: DensityMode::Compact,
            per_pane_limit: 22,
            query_history,
            saved_views: vec![SavedView {
                slot: 3,
                label: Some("triage".to_string()),
                agents,
                workspaces,
                created_from: Some(1000),
                created_to: Some(2000),
                ranking: RankingMode::MatchQualityHeavy,
                source_filter: SourceFilter::SourceId("remote-buildbox".to_string()),
            }],
            analytics_since_ms: Some(111),
            analytics_until_ms: Some(222),
            analytics_agents: {
                let mut set = HashSet::new();
                set.insert("claude_code".to_string());
                set
            },
            analytics_workspaces: {
                let mut set = HashSet::new();
                set.insert("/repo".to_string());
                set
            },
            analytics_source_filter: SourceFilter::Remote,
            fancy_borders: false,
            help_pinned: true,
            has_seen_help: true,
        };

        save_persisted_state_to_path(&state_path, &state).expect("save state");
        let loaded = load_persisted_state_from_path(&state_path)
            .expect("load state")
            .expect("state exists");

        assert_eq!(loaded.search_mode, SearchMode::Hybrid);
        assert_eq!(loaded.match_mode, MatchMode::Prefix);
        assert_eq!(loaded.ranking_mode, RankingMode::DateNewest);
        assert_eq!(loaded.context_window, ContextWindow::Large);
        assert!(!loaded.theme_dark);
        assert_eq!(loaded.density_mode, DensityMode::Compact);
        assert_eq!(loaded.per_pane_limit, 22);
        assert_eq!(
            loaded.query_history.front().map(String::as_str),
            Some("authentication error")
        );
        assert_eq!(loaded.saved_views.len(), 1);
        assert_eq!(loaded.saved_views[0].slot, 3);
        assert_eq!(loaded.saved_views[0].label.as_deref(), Some("triage"));
        assert!(matches!(
            loaded.saved_views[0].source_filter,
            SourceFilter::SourceId(ref id) if id == "remote-buildbox"
        ));
        assert_eq!(loaded.analytics_since_ms, Some(111));
        assert_eq!(loaded.analytics_until_ms, Some(222));
        assert!(loaded.analytics_agents.contains("claude_code"));
        assert!(loaded.analytics_workspaces.contains("/repo"));
        assert!(matches!(
            loaded.analytics_source_filter,
            SourceFilter::Remote
        ));
    }

    #[test]
    fn persisted_state_load_accepts_legacy_source_filter_object_and_clamps_limit() {
        let tmp = tempfile::TempDir::new().expect("tempdir");
        let state_path = tmp.path().join("tui_state.json");
        let legacy = serde_json::json!({
            "search_mode": "lexical",
            "match_mode": "standard",
            "ranking_mode": "balanced",
            "context_window": "medium",
            "per_pane_limit": 0,
            "saved_views": [
                {
                    "slot": 2,
                    "label": "legacy",
                    "agents": ["codex"],
                    "workspaces": ["/repo"],
                    "ranking": "balanced",
                    "source_filter": { "source_id": "legacy-source" }
                }
            ]
        });
        std::fs::write(
            &state_path,
            serde_json::to_vec_pretty(&legacy).expect("serialize legacy state"),
        )
        .expect("write legacy fixture");

        let loaded = load_persisted_state_from_path(&state_path)
            .expect("load should succeed")
            .expect("state exists");
        assert_eq!(loaded.per_pane_limit, 0);
        assert_eq!(loaded.saved_views.len(), 1);
        assert!(matches!(
            loaded.saved_views[0].source_filter,
            SourceFilter::SourceId(ref id) if id == "legacy-source"
        ));
    }

    #[test]
    fn state_loaded_uses_persisted_light_theme_when_no_theme_config() {
        let mut app = CassApp::default();
        let mut state = persisted_state_defaults();
        state.theme_dark = false;
        state.has_seen_help = true;

        let _ = app.update(CassMsg::StateLoaded(Box::new(state)));

        assert!(!app.theme_dark);
        assert_eq!(app.theme_preset, UiThemePreset::Light);
        assert!(!app.style_options.dark_mode);
        assert_eq!(app.style_options.preset, UiThemePreset::Light);
    }

    #[test]
    fn refresh_theme_config_respects_light_startup_preset() {
        let mut app = CassApp::default();
        app.style_options.preset = UiThemePreset::Light;
        app.style_options.dark_mode = false;

        app.refresh_theme_config_from_data_dir();

        assert!(!app.theme_dark);
        assert_eq!(app.theme_preset, UiThemePreset::Light);
        assert!(!app.style_options.dark_mode);
        assert_eq!(app.style_options.preset, UiThemePreset::Light);
    }

    #[test]
    fn resolved_style_context_honors_theme_config_light_preset() {
        let mut app = CassApp::default();
        app.theme_dark = true;
        app.theme_preset = UiThemePreset::Dark;
        app.style_options.dark_mode = true;
        app.style_options.preset = UiThemePreset::Dark;
        app.theme_config = Some(style_system::ThemeConfig {
            base_preset: Some(UiThemePreset::Light),
            ..style_system::ThemeConfig::default()
        });

        let styles = app.resolved_style_context();
        assert_eq!(styles.options.preset, UiThemePreset::Light);
        assert!(!styles.options.dark_mode);
    }

    #[test]
    fn state_loaded_prefers_theme_config_preset_over_legacy_dark_flag() {
        let mut app = CassApp::default();
        app.theme_config = Some(style_system::ThemeConfig {
            base_preset: Some(UiThemePreset::Nord),
            ..style_system::ThemeConfig::default()
        });
        let mut state = persisted_state_defaults();
        state.theme_dark = false;
        state.has_seen_help = true;

        let _ = app.update(CassMsg::StateLoaded(Box::new(state)));

        assert_eq!(app.theme_preset, UiThemePreset::Nord);
        assert!(app.theme_dark);
        assert_eq!(app.style_options.preset, UiThemePreset::Nord);
        assert!(app.style_options.dark_mode);
    }

    #[test]
    fn state_loaded_first_run_opens_help_overlay() {
        let mut app = CassApp::default();
        let mut state = persisted_state_defaults();
        state.has_seen_help = false;
        state.help_pinned = false;

        let _ = app.update(CassMsg::StateLoaded(Box::new(state)));

        assert!(app.show_help, "first run should surface help overlay");
        assert!(
            app.has_seen_help,
            "help should be marked as seen once shown"
        );
        assert_eq!(
            app.focus_manager.current(),
            Some(focus_ids::HELP_OVERLAY),
            "help overlay should receive focus on first run"
        );
    }

    #[test]
    fn state_loaded_with_seen_help_keeps_help_closed_when_not_pinned() {
        let mut app = CassApp::default();
        let mut state = persisted_state_defaults();
        state.has_seen_help = true;
        state.help_pinned = false;

        let _ = app.update(CassMsg::StateLoaded(Box::new(state)));

        assert!(!app.show_help);
        assert!(app.has_seen_help);
    }

    #[test]
    fn state_load_requested_dispatches_background_task() {
        let mut app = CassApp::default();
        let cmd = app.update(CassMsg::StateLoadRequested);
        let debug = format!("{cmd:?}");
        assert!(debug.contains("Task"), "expected Cmd::Task, got: {debug}");
    }

    #[test]
    fn state_save_requested_dispatches_background_task() {
        let mut app = CassApp::default();
        app.query = "hello".to_string();
        app.query_history.push_front("hello".to_string());
        let cmd = app.update(CassMsg::StateSaveRequested);
        let debug = format!("{cmd:?}");
        assert!(debug.contains("Task"), "expected Cmd::Task, got: {debug}");
    }

    #[test]
    fn state_reset_requested_clears_state_file() {
        let tmp = tempfile::TempDir::new().expect("tempdir");
        let mut app = CassApp::default();
        app.data_dir = tmp.path().to_path_buf();
        let state_path = app.state_file_path();
        std::fs::write(&state_path, "{}").expect("write state fixture");
        assert!(state_path.exists(), "state fixture should exist");
        let _ = app.update(CassMsg::StateResetRequested);
        assert!(
            !state_path.exists(),
            "state file should be removed by reset handler"
        );
    }

    #[test]
    fn index_refresh_requested_dispatches_task_and_rejects_parallel_refresh() {
        let mut app = CassApp::default();
        let first = app.update(CassMsg::IndexRefreshRequested);
        let debug_first = format!("{first:?}");
        assert!(
            debug_first.contains("Task"),
            "expected first refresh to dispatch Task, got: {debug_first}"
        );
        assert!(app.index_refresh_in_flight, "refresh should mark in-flight");
        assert_eq!(
            app.loading_context,
            Some(LoadingContext::IndexRefresh),
            "index refresh should set loading context while in flight"
        );

        let second = app.update(CassMsg::IndexRefreshRequested);
        let debug_second = format!("{second:?}");
        assert!(
            debug_second.contains("None"),
            "expected second refresh request to no-op, got: {debug_second}"
        );
        assert!(
            app.status.contains("already running"),
            "status should explain duplicate refresh suppression"
        );
    }

    #[test]
    fn index_refresh_terminal_states_clear_loading_context() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::IndexRefreshRequested);
        assert_eq!(app.loading_context, Some(LoadingContext::IndexRefresh));

        let _ = app.update(CassMsg::IndexRefreshCompleted);
        assert!(app.loading_context.is_none());

        let _ = app.update(CassMsg::IndexRefreshRequested);
        assert_eq!(app.loading_context, Some(LoadingContext::IndexRefresh));
        let _ = app.update(CassMsg::IndexRefreshFailed("boom".into()));
        assert!(app.loading_context.is_none());
    }

    #[test]
    fn search_result_constructible() {
        let _result = SearchResult {
            hits: Vec::new(),
            elapsed_ms: 42,
            suggestions: Vec::new(),
            wildcard_fallback: false,
        };
    }

    #[test]
    fn export_result_constructible() {
        let _result = ExportResult {
            output_path: PathBuf::from("/tmp/export.html"),
            file_size: 1024,
            encrypted: false,
            message_count: 10,
        };
    }

    use crate::ui::ftui_adapter::Model;

    /// Extract the inner message from a Cmd::Msg, if present.
    fn extract_msg(cmd: ftui::Cmd<CassMsg>) -> Option<CassMsg> {
        match cmd {
            ftui::Cmd::Msg(m) => Some(m),
            _ => None,
        }
    }

    /// Extract all immediate messages from a command (including one level of batch).
    fn extract_msgs(cmd: ftui::Cmd<CassMsg>) -> Vec<CassMsg> {
        match cmd {
            ftui::Cmd::Msg(m) => vec![m],
            ftui::Cmd::Batch(cmds) => cmds.into_iter().filter_map(extract_msg).collect(),
            _ => Vec::new(),
        }
    }

    /// Drive immediate follow-up messages returned by Cmd::Msg/Batch.
    fn drain_cmd_messages(app: &mut CassApp, cmd: ftui::Cmd<CassMsg>) {
        let mut pending = extract_msgs(cmd);
        while let Some(msg) = pending.pop() {
            let next = app.update(msg);
            pending.extend(extract_msgs(next));
        }
    }

    #[derive(Clone, Copy)]
    struct EnterRoutingFixture {
        input_mode: InputMode,
        focus_id: FocusId,
        selected_hit: bool,
        show_detail_modal: bool,
        detail_tab: DetailTab,
    }

    #[derive(Debug)]
    struct EnterRoutingOutcome {
        cmd_msg: Option<CassMsg>,
        show_detail_modal: bool,
        detail_tab: DetailTab,
        query_history_front: Option<String>,
    }

    #[derive(Clone, Copy, Debug)]
    enum ExpectedEnterRoute {
        QuerySubmit,
        DetailModalOpen,
    }

    fn app_for_enter_routing(fixture: EnterRoutingFixture) -> CassApp {
        let mut app = CassApp::default();
        app.input_mode = fixture.input_mode;
        app.query = "test query".to_string();
        app.show_detail_modal = fixture.show_detail_modal;
        app.detail_tab = fixture.detail_tab;
        if fixture.selected_hit {
            app.panes.push(AgentPane {
                agent: "codex".into(),
                total_count: 1,
                hits: vec![make_test_hit()],
                selected: 0,
            });
            app.active_pane = 0;
        }
        app.focus_manager.focus(fixture.focus_id);
        app
    }

    fn run_enter_routing(fixture: EnterRoutingFixture) -> EnterRoutingOutcome {
        let mut app = app_for_enter_routing(fixture);
        let cmd = app.update(CassMsg::DetailOpened);
        EnterRoutingOutcome {
            cmd_msg: extract_msg(cmd),
            show_detail_modal: app.show_detail_modal,
            detail_tab: app.detail_tab,
            query_history_front: app.query_history.front().cloned(),
        }
    }

    fn assert_enter_route(case: &str, fixture: EnterRoutingFixture, expected: ExpectedEnterRoute) {
        let outcome = run_enter_routing(fixture);
        match expected {
            ExpectedEnterRoute::QuerySubmit => {
                assert!(
                    matches!(outcome.cmd_msg, Some(CassMsg::SearchRequested)),
                    "{case}: expected query-submit route to dispatch SearchRequested; got {:?}",
                    outcome.cmd_msg
                );
            }
            ExpectedEnterRoute::DetailModalOpen => {
                assert!(
                    outcome.show_detail_modal,
                    "{case}: expected detail modal to open"
                );
                assert!(
                    !matches!(outcome.cmd_msg, Some(CassMsg::SearchRequested)),
                    "{case}: expected detail-open route, not query-submit fallback"
                );
            }
        }
    }

    fn sample_update_info() -> UpdateInfo {
        UpdateInfo {
            latest_version: "9.9.9".to_string(),
            tag_name: "v9.9.9".to_string(),
            current_version: "1.0.0".to_string(),
            release_url: "https://example.com/releases/v9.9.9".to_string(),
            is_newer: true,
            is_skipped: false,
        }
    }

    // ==================== Command palette tests ====================

    #[test]
    fn palette_state_initialized_with_default_actions() {
        let app = CassApp::default();
        assert!(
            !app.palette_state.all_actions.is_empty(),
            "palette should be initialized with actions"
        );
        // Should have at least the core 12 base actions + 18 slot actions = 30
        assert!(app.palette_state.all_actions.len() >= 30);
    }

    #[test]
    fn palette_state_not_open_by_default() {
        let app = CassApp::default();
        assert!(!app.command_palette.is_visible());
    }

    #[test]
    fn palette_open_sets_state() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::PaletteOpened);
        assert!(app.command_palette.is_visible());
        assert!(app.palette_state.query.is_empty());
        assert_eq!(app.palette_state.selected, 0);
        assert_eq!(
            app.palette_state.filtered.len(),
            app.palette_state.all_actions.len()
        );
    }

    #[test]
    fn palette_close_clears_open() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::PaletteOpened);
        assert!(app.command_palette.is_visible());
        let _ = app.update(CassMsg::PaletteClosed);
        assert!(!app.command_palette.is_visible());
    }

    #[test]
    fn palette_query_filters_actions() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::PaletteOpened);
        let total = app.palette_state.filtered.len();
        let _ = app.update(CassMsg::PaletteQueryChanged("theme".into()));
        assert!(app.palette_state.filtered.len() < total);
        assert!(
            app.palette_state
                .filtered
                .iter()
                .any(|i| i.label.to_lowercase().contains("theme"))
        );
    }

    #[test]
    fn palette_selection_wraps() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::PaletteOpened);
        let len = app.palette_state.filtered.len();
        // Move past end -> wraps
        let _ = app.update(CassMsg::PaletteSelectionMoved {
            delta: len as i32 + 1,
        });
        assert!(app.palette_state.selected < len);
    }

    #[test]
    fn palette_execute_theme_toggles_dark() {
        let mut app = CassApp::default();
        assert!(app.theme_dark);

        // Open palette and select "Toggle theme".
        let _ = app.update(CassMsg::PaletteOpened);
        let idx = app
            .palette_state
            .filtered
            .iter()
            .position(|i| matches!(i.action, PaletteAction::ToggleTheme))
            .expect("toggle theme action should exist");
        app.palette_state.selected = idx;

        // Execute it - should produce ThemeToggled cmd
        let cmd = app.update(CassMsg::PaletteActionExecuted);
        assert!(
            !app.command_palette.is_visible(),
            "palette should close on execute"
        );
        // The returned Cmd contains CassMsg::ThemeToggled; process it
        if let Some(msg) = extract_msg(cmd) {
            let _ = app.update(msg);
        }
        assert!(!app.theme_dark, "theme should have toggled to light");
    }

    #[test]
    fn palette_action_executed_releases_focus_trap() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::PaletteOpened);
        assert!(app.focus_manager.is_trapped());

        let _ = app.update(CassMsg::PaletteActionExecuted);
        assert!(
            !app.focus_manager.is_trapped(),
            "palette execute should always release the palette trap"
        );
    }

    #[test]
    fn palette_execute_density_cycles() {
        let mut app = CassApp::default();
        assert_eq!(app.density_mode, DensityMode::Cozy);

        let _ = app.update(CassMsg::PaletteOpened);
        // Find density action
        let idx = app
            .palette_state
            .filtered
            .iter()
            .position(|i| matches!(i.action, PaletteAction::ToggleDensity))
            .expect("density action should exist");
        app.palette_state.selected = idx;
        let cmd = app.update(CassMsg::PaletteActionExecuted);
        if let Some(msg) = extract_msg(cmd) {
            let _ = app.update(msg);
        }
        assert_eq!(app.density_mode, DensityMode::Spacious);
    }

    #[test]
    fn palette_execute_reload_index() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::PaletteOpened);
        let idx = app
            .palette_state
            .filtered
            .iter()
            .position(|i| matches!(i.action, PaletteAction::ReloadIndex))
            .expect("reload action should exist");
        app.palette_state.selected = idx;
        let cmd = app.update(CassMsg::PaletteActionExecuted);
        // Should produce IndexRefreshRequested
        assert!(!app.command_palette.is_visible());
        // cmd should contain a message (IndexRefreshRequested)
        assert!(extract_msg(cmd).is_some());
    }

    #[test]
    fn palette_escape_closes_before_quit() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::PaletteOpened);
        assert!(app.command_palette.is_visible());
        // ESC should close palette, not quit
        let _ = app.update(CassMsg::QuitRequested);
        assert!(!app.command_palette.is_visible());
    }

    #[test]
    fn palette_hints_use_shortcut_constants() {
        let app = CassApp::default();
        // The Toggle theme action should have the F2 shortcut as hint
        let theme_action = app
            .palette_state
            .all_actions
            .iter()
            .find(|i| matches!(i.action, PaletteAction::ToggleTheme))
            .expect("theme action should exist");
        assert_eq!(theme_action.hint, "F2");

        // Filter agent should have F3
        let filter_action = app
            .palette_state
            .all_actions
            .iter()
            .find(|i| matches!(i.action, PaletteAction::FilterAgent))
            .expect("filter agent should exist");
        assert_eq!(filter_action.hint, "F3");
    }

    #[test]
    fn palette_save_view_slot_dispatches() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::PaletteOpened);
        // Find SaveViewSlot(1)
        let idx = app
            .palette_state
            .filtered
            .iter()
            .position(|i| matches!(i.action, PaletteAction::SaveViewSlot(1)))
            .expect("save slot 1 should exist");
        app.palette_state.selected = idx;
        let cmd = app.update(CassMsg::PaletteActionExecuted);
        if let Some(msg) = extract_msg(cmd) {
            let _ = app.update(msg);
        }
        assert!(
            app.saved_views.iter().any(|v| v.slot == 1),
            "slot 1 should be saved"
        );
    }

    #[test]
    fn palette_open_saved_views_dispatches() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::PaletteOpened);
        let idx = app
            .palette_state
            .filtered
            .iter()
            .position(|i| matches!(i.action, PaletteAction::OpenSavedViews))
            .expect("open saved views action should exist");
        app.palette_state.selected = idx;

        let cmd = app.update(CassMsg::PaletteActionExecuted);
        assert!(!app.command_palette.is_visible());
        assert!(matches!(extract_msg(cmd), Some(CassMsg::SavedViewsOpened)));
    }

    // -- CommandPalette widget integration tests (1mfw3.1.3) ----------------

    #[test]
    fn palette_open_also_opens_widget() {
        let mut app = CassApp::default();
        assert!(!app.command_palette.is_visible());
        let _ = app.update(CassMsg::PaletteOpened);
        assert!(app.command_palette.is_visible());
    }

    #[test]
    fn palette_close_also_closes_widget() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::PaletteOpened);
        assert!(app.command_palette.is_visible());
        let _ = app.update(CassMsg::PaletteClosed);
        assert!(!app.command_palette.is_visible());
    }

    #[test]
    fn palette_execute_closes_widget() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::PaletteOpened);
        assert!(app.command_palette.is_visible());
        let _ = app.update(CassMsg::PaletteActionExecuted);
        assert!(!app.command_palette.is_visible());
        assert!(!app.command_palette.is_visible());
    }

    #[test]
    fn palette_quit_requested_closes_widget() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::PaletteOpened);
        assert!(app.command_palette.is_visible());
        let _ = app.update(CassMsg::QuitRequested);
        assert!(!app.command_palette.is_visible());
        assert!(!app.command_palette.is_visible());
    }

    #[test]
    fn palette_widget_has_registered_actions() {
        let app = CassApp::default();
        // action_count() returns total registered (not just filtered/visible)
        assert_eq!(
            app.command_palette.action_count(),
            app.palette_state.all_actions.len()
        );
    }

    // -- Evidence ledger tests (1mfw3.1.5) -----------------------------------

    #[test]
    fn palette_evidence_off_by_default() {
        let app = CassApp::default();
        assert!(!app.show_palette_evidence);
    }

    #[test]
    fn palette_evidence_toggle_msg() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::PaletteOpened);
        assert!(!app.show_palette_evidence);
        let _ = app.update(CassMsg::PaletteEvidenceToggled);
        assert!(app.show_palette_evidence);
        let _ = app.update(CassMsg::PaletteEvidenceToggled);
        assert!(!app.show_palette_evidence);
    }

    #[test]
    fn palette_evidence_resets_on_close() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::PaletteOpened);
        let _ = app.update(CassMsg::PaletteEvidenceToggled);
        assert!(app.show_palette_evidence);
        let _ = app.update(CassMsg::PaletteClosed);
        assert!(!app.show_palette_evidence);
    }

    #[test]
    fn palette_evidence_resets_on_execute() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::PaletteOpened);
        let _ = app.update(CassMsg::PaletteEvidenceToggled);
        assert!(app.show_palette_evidence);
        let _ = app.update(CassMsg::PaletteActionExecuted);
        assert!(!app.show_palette_evidence);
    }

    #[test]
    fn palette_evidence_resets_on_esc() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::PaletteOpened);
        let _ = app.update(CassMsg::PaletteEvidenceToggled);
        assert!(app.show_palette_evidence);
        let _ = app.update(CassMsg::QuitRequested);
        assert!(!app.show_palette_evidence);
    }

    #[test]
    fn palette_evidence_tracking_enabled() {
        let app = CassApp::default();
        // Evidence tracking is enabled; scorer stats should be accessible.
        let stats = app.command_palette.scorer_stats();
        // At least one scan may occur during initialization.
        assert!(stats.full_scans <= 1);
    }

    // -- Palette latency tests ------------------------------------------------

    #[test]
    fn palette_latency_stats_record() {
        let mut stats = PaletteLatencyStats::default();
        assert_eq!(stats.last_query_us, 0);
        assert_eq!(stats.query_count, 0);
        stats.record(500);
        assert_eq!(stats.last_query_us, 500);
        assert_eq!(stats.peak_us, 500);
        assert_eq!(stats.query_count, 1);
        stats.record(1200);
        assert_eq!(stats.last_query_us, 1200);
        assert_eq!(stats.peak_us, 1200);
        assert_eq!(stats.query_count, 2);
        stats.record(300);
        assert_eq!(stats.last_query_us, 300);
        assert_eq!(stats.peak_us, 1200); // peak unchanged
        assert_eq!(stats.query_count, 3);
        assert_eq!(stats.avg_us(), (500 + 1200 + 300) / 3);
    }

    #[test]
    fn palette_latency_budget_indicator() {
        let mut stats = PaletteLatencyStats::default();
        stats.record(100);
        assert_eq!(stats.budget_indicator(), "OK");
        stats.record(3_000);
        assert_eq!(stats.budget_indicator(), "WARN");
        stats.record(10_000);
        assert_eq!(stats.budget_indicator(), "SLOW");
    }

    #[test]
    fn palette_latency_reset() {
        let mut stats = PaletteLatencyStats::default();
        stats.record(500);
        stats.record(1200);
        stats.bench_mode = true;
        stats.bench_start = Some(std::time::Instant::now());
        stats.reset();
        assert_eq!(stats.last_query_us, 0);
        assert_eq!(stats.peak_us, 0);
        assert_eq!(stats.query_count, 0);
        assert_eq!(stats.total_us, 0);
    }

    #[test]
    fn palette_bench_toggle_msg() {
        let mut app = CassApp::default();
        assert!(!app.palette_latency.bench_mode);
        let _ = app.update(CassMsg::PaletteBenchToggled);
        assert!(app.palette_latency.bench_mode);
        assert!(app.palette_latency.bench_start.is_some());
        let _ = app.update(CassMsg::PaletteBenchToggled);
        assert!(!app.palette_latency.bench_mode);
        assert!(app.palette_latency.bench_start.is_none());
    }

    #[test]
    fn palette_bench_resets_on_close() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::PaletteOpened);
        let _ = app.update(CassMsg::PaletteBenchToggled);
        assert!(app.palette_latency.bench_mode);
        let _ = app.update(CassMsg::PaletteClosed);
        assert!(!app.palette_latency.bench_mode);
        assert!(app.palette_latency.bench_start.is_none());
    }

    #[test]
    fn palette_bench_resets_on_execute() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::PaletteOpened);
        let _ = app.update(CassMsg::PaletteBenchToggled);
        assert!(app.palette_latency.bench_mode);
        let _ = app.update(CassMsg::PaletteActionExecuted);
        assert!(!app.palette_latency.bench_mode);
    }

    #[test]
    fn palette_latency_avg_zero_when_empty() {
        let stats = PaletteLatencyStats::default();
        assert_eq!(stats.avg_us(), 0);
        assert_eq!(stats.queries_per_sec(), 0.0);
    }

    #[test]
    fn palette_interceptor_consumes_key_events_when_open() {
        use crate::ui::ftui_adapter::{Event, KeyCode, KeyEvent, Modifiers};
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::PaletteOpened);
        stash_raw_event(&Event::Key(KeyEvent {
            code: KeyCode::Down,
            modifiers: Modifiers::NONE,
            kind: ftui::KeyEventKind::Press,
        }));
        let old_sel = app.selected.clone();
        let _ = app.update(CassMsg::SelectionMoved { delta: 1 });
        assert_eq!(app.selected, old_sel);
    }

    #[test]
    fn palette_interceptor_lets_tick_through() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::PaletteOpened);
        let _ = app.update(CassMsg::Tick);
        assert!(app.command_palette.is_visible());
    }

    #[test]
    fn palette_interceptor_lets_force_quit_through() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::PaletteOpened);
        let cmd = app.update(CassMsg::ForceQuit);
        // ForceQuit should produce Cmd::Quit (not be swallowed by interceptor)
        assert!(matches!(cmd, ftui::Cmd::Quit));
    }

    #[test]
    fn palette_open_resets_match_mode() {
        let mut app = CassApp::default();
        // Open palette, cycle match mode, close, reopen — should reset.
        let _ = app.update(CassMsg::PaletteOpened);
        let _ = app.update(CassMsg::PaletteMatchModeCycled);
        assert_ne!(app.palette_match_mode, PaletteMatchMode::All);
        let _ = app.update(CassMsg::PaletteClosed);
        let _ = app.update(CassMsg::PaletteOpened);
        assert_eq!(app.palette_match_mode, PaletteMatchMode::All);
    }

    #[test]
    fn palette_match_mode_cycled_updates_status() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::PaletteOpened);
        let _ = app.update(CassMsg::PaletteMatchModeCycled);
        assert_eq!(app.palette_match_mode, PaletteMatchMode::Exact);
        assert!(app.status.contains("Exact"));
        let _ = app.update(CassMsg::PaletteMatchModeCycled);
        assert_eq!(app.palette_match_mode, PaletteMatchMode::Prefix);
        assert!(app.status.contains("Prefix"));
    }

    // -- 1mfw3.1.6: Palette regression tests ----------------------------------
    #[test]
    fn palette_action_ordering_is_deterministic() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::PaletteOpened);
        let a1: Vec<String> = app
            .palette_state
            .all_actions
            .iter()
            .map(|a| a.label.clone())
            .collect();
        assert!(!a1.is_empty());
        let _ = app.update(CassMsg::PaletteClosed);
        let _ = app.update(CassMsg::PaletteOpened);
        let a2: Vec<String> = app
            .palette_state
            .all_actions
            .iter()
            .map(|a| a.label.clone())
            .collect();
        assert_eq!(a1, a2, "deterministic ordering");
    }
    #[test]
    fn palette_lifecycle_open_query_navigate_execute() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::PaletteOpened);
        assert!(app.command_palette.is_visible());
        let _ = app.update(CassMsg::PaletteQueryChanged("theme".into()));
        assert_eq!(app.palette_state.query, "theme");
        let _ = app.update(CassMsg::PaletteSelectionMoved { delta: 1 });
        let _ = app.update(CassMsg::PaletteActionExecuted);
        assert!(!app.command_palette.is_visible());
        assert!(!app.show_palette_evidence);
        assert!(!app.palette_latency.bench_mode);
    }
    #[test]
    fn palette_lifecycle_filter_navigate_close() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::PaletteOpened);
        for _ in 0..6 {
            let _ = app.update(CassMsg::PaletteMatchModeCycled);
        }
        assert_eq!(app.palette_match_mode, PaletteMatchMode::All);
        let _ = app.update(CassMsg::PaletteSelectionMoved { delta: 2 });
        let _ = app.update(CassMsg::PaletteClosed);
        assert!(!app.command_palette.is_visible());
    }
    #[test]
    fn palette_reopen_after_execute_resets() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::PaletteOpened);
        let _ = app.update(CassMsg::PaletteQueryChanged("x".into()));
        let _ = app.update(CassMsg::PaletteEvidenceToggled);
        let _ = app.update(CassMsg::PaletteBenchToggled);
        let _ = app.update(CassMsg::PaletteMatchModeCycled);
        let _ = app.update(CassMsg::PaletteActionExecuted);
        let _ = app.update(CassMsg::PaletteOpened);
        assert_eq!(app.palette_state.query, "");
        assert_eq!(app.palette_state.selected, 0);
        assert_eq!(app.palette_match_mode, PaletteMatchMode::All);
        assert!(!app.show_palette_evidence);
        assert!(!app.palette_latency.bench_mode);
    }
    #[test]
    fn palette_navigate_boundaries_wrap() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::PaletteOpened);
        let n = app.palette_state.filtered.len();
        assert!(n > 0);
        let _ = app.update(CassMsg::PaletteSelectionMoved { delta: -1 });
        assert_eq!(app.palette_state.selected, n - 1);
        let _ = app.update(CassMsg::PaletteSelectionMoved { delta: 1 });
        assert_eq!(app.palette_state.selected, 0);
    }
    #[test]
    fn palette_result_dispatch_all_variants() {
        let mut app = CassApp::default();
        for r in [
            PaletteResult::ToggleTheme,
            PaletteResult::CycleDensity,
            PaletteResult::ToggleHelpStrip,
            PaletteResult::OpenUpdateBanner,
            PaletteResult::EnterInputMode(InputModeTarget::Agent),
            PaletteResult::EnterInputMode(InputModeTarget::Workspace),
            PaletteResult::EnterInputMode(InputModeTarget::CreatedFrom),
            PaletteResult::SetTimeFilter {
                from: TimeFilterPreset::Today,
            },
            PaletteResult::SetTimeFilter {
                from: TimeFilterPreset::LastWeek,
            },
            PaletteResult::OpenSavedViews,
            PaletteResult::SaveViewSlot(1),
            PaletteResult::LoadViewSlot(1),
            PaletteResult::OpenBulkActions,
            PaletteResult::ReloadIndex,
            PaletteResult::OpenAnalyticsView(AnalyticsTarget::Dashboard),
            PaletteResult::OpenAnalyticsView(AnalyticsTarget::Explorer),
            PaletteResult::OpenAnalyticsView(AnalyticsTarget::Heatmap),
            PaletteResult::OpenAnalyticsView(AnalyticsTarget::Breakdowns),
            PaletteResult::OpenAnalyticsView(AnalyticsTarget::Tools),
            PaletteResult::OpenAnalyticsView(AnalyticsTarget::Plans),
            PaletteResult::OpenAnalyticsView(AnalyticsTarget::Coverage),
            PaletteResult::Screenshot(ScreenshotTarget::Html),
            PaletteResult::Screenshot(ScreenshotTarget::Svg),
            PaletteResult::Screenshot(ScreenshotTarget::Text),
            PaletteResult::ToggleMacroRecording,
            PaletteResult::OpenSources,
            PaletteResult::Noop,
        ] {
            let _ = app.palette_result_to_cmd(r);
        }
    }
    #[test]
    fn palette_filter_mode_round_trip() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::PaletteOpened);
        let init = app.palette_match_mode;
        for exp in [
            PaletteMatchMode::Exact,
            PaletteMatchMode::Prefix,
            PaletteMatchMode::WordStart,
            PaletteMatchMode::Substring,
            PaletteMatchMode::Fuzzy,
            PaletteMatchMode::All,
        ] {
            let _ = app.update(CassMsg::PaletteMatchModeCycled);
            assert_eq!(app.palette_match_mode, exp);
        }
        assert_eq!(app.palette_match_mode, init);
    }
    #[test]
    fn palette_zero_results_safe() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::PaletteOpened);
        let total = app.palette_state.filtered.len();
        assert!(total > 0);
        let _ = app.update(CassMsg::PaletteQueryChanged("zzzzz_no_match".into()));
        assert_eq!(app.palette_state.filtered.len(), 0);
        let _ = app.update(CassMsg::PaletteQueryChanged(String::new()));
        assert_eq!(app.palette_state.filtered.len(), total);
    }
    #[test]
    fn palette_selection_clamps_on_filter() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::PaletteOpened);
        for _ in 0..10 {
            let _ = app.update(CassMsg::PaletteSelectionMoved { delta: 1 });
        }
        assert!(app.palette_state.selected > 0);
        let _ = app.update(CassMsg::PaletteQueryChanged("theme".into()));
        let n = app.palette_state.filtered.len();
        assert!(app.palette_state.selected < n.max(1));
    }
    #[test]
    fn palette_rapid_open_close_stable() {
        let mut app = CassApp::default();
        for _ in 0..10 {
            let _ = app.update(CassMsg::PaletteOpened);
            assert!(app.command_palette.is_visible());
            let _ = app.update(CassMsg::PaletteClosed);
            assert!(!app.command_palette.is_visible());
        }
        assert!(!app.show_palette_evidence);
        assert!(!app.palette_latency.bench_mode);
    }
    #[test]
    fn palette_esc_closes_before_quit() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::PaletteOpened);
        let _ = app.update(CassMsg::PaletteClosed);
        assert!(!app.command_palette.is_visible());
        assert!(!app.show_palette_evidence);
    }
    #[test]
    fn palette_actions_have_valid_labels() {
        let app = CassApp::default();
        for a in &app.palette_state.all_actions {
            assert!(!a.label.is_empty(), "empty label for action={:?}", a.action);
        }
    }
    // -- end 1mfw3.1.6 -------------------------------------------------------

    #[test]
    fn saved_views_modal_open_move_and_close() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::ViewSaved(2));
        let _ = app.update(CassMsg::ViewSaved(1));

        let _ = app.update(CassMsg::SavedViewsOpened);
        assert!(app.show_saved_views_modal);
        assert_eq!(app.selected_saved_view_slot(), Some(1));

        let _ = app.update(CassMsg::SavedViewsSelectionMoved { delta: 1 });
        assert_eq!(app.selected_saved_view_slot(), Some(2));

        let _ = app.update(CassMsg::SavedViewsClosed);
        assert!(!app.show_saved_views_modal);
    }

    #[test]
    fn saved_views_selection_move_handles_extreme_delta() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::ViewSaved(1));
        let _ = app.update(CassMsg::ViewSaved(2));
        let _ = app.update(CassMsg::ViewSaved(3));
        let _ = app.update(CassMsg::SavedViewsOpened);

        assert_eq!(app.selected_saved_view_slot(), Some(3));
        let _ = app.update(CassMsg::SavedViewsSelectionMoved { delta: i32::MIN });
        assert_eq!(app.selected_saved_view_slot(), Some(1));
    }

    #[test]
    fn saved_view_rename_commit_sets_label() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::ViewSaved(1));
        let _ = app.update(CassMsg::SavedViewsOpened);

        let _ = app.update(CassMsg::SavedViewRenameStarted);
        assert!(app.saved_view_rename_mode);

        let _ = app.update(CassMsg::QueryChanged("Primary".to_string()));
        let _ = app.update(CassMsg::SavedViewRenameCommitted);

        assert!(!app.saved_view_rename_mode);
        assert_eq!(
            app.saved_views.first().and_then(|v| v.label.as_deref()),
            Some("Primary")
        );
    }

    #[test]
    fn saved_view_delete_then_clear_all() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::ViewSaved(1));
        let _ = app.update(CassMsg::ViewSaved(2));
        let _ = app.update(CassMsg::SavedViewsOpened);

        assert_eq!(app.selected_saved_view_slot(), Some(2));
        let _ = app.update(CassMsg::SavedViewDeletedSelected);
        assert_eq!(app.saved_views.len(), 1);
        assert_eq!(app.saved_views[0].slot, 1);

        let _ = app.update(CassMsg::SavedViewsCleared);
        assert!(app.saved_views.is_empty());
    }

    #[test]
    fn saved_view_load_selected_dispatches_view_loaded_for_selected_slot() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::ViewSaved(3));
        let _ = app.update(CassMsg::SavedViewsOpened);
        assert!(app.focus_manager.is_trapped());

        let cmd = app.update(CassMsg::SavedViewLoadedSelected);
        assert!(!app.show_saved_views_modal);
        assert!(
            !app.focus_manager.is_trapped(),
            "loading a saved view from modal should release focus trap"
        );
        assert!(matches!(extract_msg(cmd), Some(CassMsg::ViewLoaded(3))));
    }

    #[test]
    fn saving_existing_slot_preserves_label() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::ViewSaved(1));
        let _ = app.update(CassMsg::SavedViewsOpened);
        let _ = app.update(CassMsg::SavedViewRenameStarted);
        let _ = app.update(CassMsg::QueryChanged("Pinned".to_string()));
        let _ = app.update(CassMsg::SavedViewRenameCommitted);

        app.filters.agents.insert("codex".to_string());
        let _ = app.update(CassMsg::ViewSaved(1));

        let label = app
            .saved_views
            .iter()
            .find(|v| v.slot == 1)
            .and_then(|v| v.label.as_deref());
        assert_eq!(label, Some("Pinned"));
    }

    #[test]
    fn saved_views_quit_requests_close_modal_before_app_quit() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::ViewSaved(1));
        let _ = app.update(CassMsg::SavedViewsOpened);
        assert!(app.show_saved_views_modal);

        let cmd = app.update(CassMsg::QuitRequested);
        if let Some(msg) = extract_msg(cmd) {
            let _ = app.update(msg);
        }

        assert!(!app.show_saved_views_modal);
    }

    #[test]
    fn saved_view_rename_quit_cancels_rename_but_keeps_modal_open() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::ViewSaved(1));
        let _ = app.update(CassMsg::SavedViewsOpened);
        let _ = app.update(CassMsg::SavedViewRenameStarted);
        let _ = app.update(CassMsg::QueryChanged("Temp Label".to_string()));
        assert!(app.saved_view_rename_mode);
        assert!(!app.saved_view_rename_buffer.is_empty());

        let cmd = app.update(CassMsg::QuitRequested);
        assert!(matches!(cmd, ftui::Cmd::None));
        assert!(app.show_saved_views_modal);
        assert!(!app.saved_view_rename_mode);
        assert!(app.saved_view_rename_buffer.is_empty());
    }

    #[test]
    fn load_empty_saved_view_slot_sets_warning_status() {
        let mut app = CassApp::default();
        let cmd = app.update(CassMsg::ViewLoaded(9));
        assert!(matches!(cmd, ftui::Cmd::None));
        assert!(app.status.contains("No saved view in slot 9"));
    }

    #[test]
    fn view_loaded_releases_saved_views_focus_trap_when_modal_was_open() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::ViewSaved(2));
        let _ = app.update(CassMsg::SavedViewsOpened);
        assert!(app.focus_manager.is_trapped());

        let _ = app.update(CassMsg::ViewLoaded(2));
        assert!(
            !app.focus_manager.is_trapped(),
            "direct ViewLoaded should release trap when modal was open"
        );
        assert!(!app.show_saved_views_modal);
    }

    // ==================== Search bar UX tests (2noh9.3.2) ====================

    #[test]
    fn query_changed_appends_characters() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::QueryChanged("h".into()));
        let _ = app.update(CassMsg::QueryChanged("e".into()));
        let _ = app.update(CassMsg::QueryChanged("l".into()));
        assert_eq!(app.query, "hel");
        assert_eq!(app.cursor_pos, 3);
    }

    #[test]
    fn query_changed_backspace_removes_char() {
        let mut app = CassApp::default();
        app.query = "hello".to_string();
        app.cursor_pos = 5;
        let _ = app.update(CassMsg::QueryChanged(String::new())); // backspace
        assert_eq!(app.query, "hell");
        assert_eq!(app.cursor_pos, 4);
    }

    #[test]
    fn non_query_input_mode_routes_typing_to_input_buffer() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::InputModeEntered(InputMode::Agent));
        assert_eq!(app.input_mode, InputMode::Agent);

        let _ = app.update(CassMsg::QueryChanged("c".into()));
        let _ = app.update(CassMsg::QueryChanged("o".into()));
        let _ = app.update(CassMsg::QueryChanged("d".into()));
        assert_eq!(app.input_buffer, "cod");
        assert!(
            app.query.is_empty(),
            "query should not change while editing non-query input mode"
        );

        let _ = app.update(CassMsg::QueryChanged(String::new())); // backspace
        assert_eq!(app.input_buffer, "co");

        let cmd = app.update(CassMsg::DetailOpened); // Enter applies mode
        if let Some(msg) = extract_msg(cmd) {
            let _ = app.update(msg);
        }
        assert_eq!(app.input_mode, InputMode::Query);
        assert!(app.input_buffer.is_empty());
        assert!(app.filters.agents.contains("co"));
    }

    #[test]
    fn input_auto_completed_fills_agent_from_candidates() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::InputModeEntered(InputMode::Agent));
        app.input_buffer = "co".to_string();

        let mut codex_hit = make_hit(1, "/a");
        codex_hit.agent = "codex".to_string();
        let mut cursor_hit = make_hit(2, "/b");
        cursor_hit.agent = "cursor".to_string();
        app.results = vec![cursor_hit, codex_hit];

        let _ = app.update(CassMsg::InputAutoCompleted);
        assert_eq!(app.input_buffer, "codex");
    }

    #[test]
    fn input_auto_completed_uses_workspace_suffix_for_csv_input() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::InputModeEntered(InputMode::Workspace));
        app.known_workspaces = Some(vec![
            "/work/project-alpha".to_string(),
            "/workspace-beta".to_string(),
        ]);
        app.input_buffer = "foo, /wo".to_string();

        let _ = app.update(CassMsg::InputAutoCompleted);
        assert_eq!(app.input_buffer, "foo, /work/project-alpha");
    }

    #[test]
    fn focus_toggled_in_input_mode_autocompletes_without_changing_focus() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::InputModeEntered(InputMode::Agent));
        app.focus_manager.focus(focus_ids::SEARCH_BAR);
        app.input_buffer = "ge".to_string();
        let focus_before = app.focus_manager.current();

        let _ = app.update(CassMsg::FocusToggled);
        assert_eq!(app.input_buffer, "gemini");
        assert_eq!(app.focus_manager.current(), focus_before);
    }

    #[test]
    fn pane_filter_mode_typing_updates_pane_filter_and_esc_cancels() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::PaneFilterOpened);
        assert_eq!(app.input_mode, InputMode::PaneFilter);

        let _ = app.update(CassMsg::QueryChanged("e".into()));
        let _ = app.update(CassMsg::QueryChanged("r".into()));
        let _ = app.update(CassMsg::QueryChanged("r".into()));
        assert_eq!(app.input_buffer, "err");
        assert_eq!(app.pane_filter.as_deref(), Some("err"));

        let _ = app.update(CassMsg::QuitRequested); // Esc cancels pane filter
        assert_eq!(app.input_mode, InputMode::Query);
        assert!(app.input_buffer.is_empty());
        assert!(app.pane_filter.is_none());
    }

    #[test]
    fn query_changed_sets_search_dirty() {
        let mut app = CassApp::default();
        assert!(app.search_dirty_since.is_none());
        let _ = app.update(CassMsg::QueryChanged("a".into()));
        assert!(app.search_dirty_since.is_some());
    }

    #[test]
    fn query_cleared_empties_and_marks_dirty() {
        let mut app = CassApp::default();
        app.query = "hello world".to_string();
        let _ = app.update(CassMsg::QueryCleared);
        assert!(app.query.is_empty());
        assert!(app.search_dirty_since.is_some());
    }

    #[test]
    fn query_word_deleted_removes_last_word() {
        let mut app = CassApp::default();
        app.query = "hello world".to_string();
        app.cursor_pos = 11;
        let _ = app.update(CassMsg::QueryWordDeleted);
        assert_eq!(app.query, "hello ");
        assert_eq!(app.cursor_pos, 6);
    }

    #[test]
    fn query_word_deleted_single_word_clears() {
        let mut app = CassApp::default();
        app.query = "hello".to_string();
        app.cursor_pos = 5;
        let _ = app.update(CassMsg::QueryWordDeleted);
        assert!(app.query.is_empty());
        assert_eq!(app.cursor_pos, 0);
    }

    #[test]
    fn query_submitted_pushes_to_history() {
        let mut app = CassApp::default();
        app.query = "authentication error".to_string();
        let cmd = app.update(CassMsg::QuerySubmitted);
        assert_eq!(app.query_history.front().unwrap(), "authentication error");
        // Should produce SearchRequested
        assert!(matches!(extract_msg(cmd), Some(CassMsg::SearchRequested)));
    }

    #[test]
    fn query_submitted_deduplicates_history() {
        let mut app = CassApp::default();
        app.query = "auth".to_string();
        let _ = app.update(CassMsg::QuerySubmitted);
        app.query = "db error".to_string();
        let _ = app.update(CassMsg::QuerySubmitted);
        app.query = "auth".to_string();
        let _ = app.update(CassMsg::QuerySubmitted);
        // "auth" should appear only once, at the front
        assert_eq!(app.query_history.len(), 2);
        assert_eq!(app.query_history[0], "auth");
        assert_eq!(app.query_history[1], "db error");
    }

    #[test]
    fn query_submitted_empty_loads_recent_history() {
        let mut app = CassApp::default();
        app.query_history.push_front("previous query".to_string());
        app.query.clear();
        let _ = app.update(CassMsg::QuerySubmitted);
        assert_eq!(app.query, "previous query");
    }

    #[test]
    fn search_completed_groups_into_panes() {
        let mut app = CassApp::default();
        let hits = vec![
            SearchHit {
                agent: "claude_code".into(),
                title: "Session 1".into(),
                snippet: "test".into(),
                content: "test content".into(),
                content_hash: 0,
                score: 1.0,
                source_path: "/a".into(),
                workspace: "/w".into(),
                workspace_original: None,
                created_at: Some(1000),
                line_number: Some(1),
                match_type: Default::default(),
                source_id: "local".into(),
                origin_kind: "local".into(),
                origin_host: None,
            },
            SearchHit {
                agent: "codex".into(),
                title: "Session 2".into(),
                snippet: "test".into(),
                content: "test content 2".into(),
                content_hash: 1,
                score: 0.9,
                source_path: "/b".into(),
                workspace: "/w".into(),
                workspace_original: None,
                created_at: Some(2000),
                line_number: Some(5),
                match_type: Default::default(),
                source_id: "local".into(),
                origin_kind: "local".into(),
                origin_host: None,
            },
            SearchHit {
                agent: "claude_code".into(),
                title: "Session 3".into(),
                snippet: "test".into(),
                content: "test content 3".into(),
                content_hash: 2,
                score: 0.8,
                source_path: "/c".into(),
                workspace: "/w".into(),
                workspace_original: None,
                created_at: Some(3000),
                line_number: Some(10),
                match_type: Default::default(),
                source_id: "local".into(),
                origin_kind: "local".into(),
                origin_host: None,
            },
        ];
        let _ = app.update(CassMsg::SearchCompleted {
            generation: app.search_generation,
            hits,
            elapsed_ms: 42,
            suggestions: vec![],
            wildcard_fallback: false,
            append: false,
        });
        assert_eq!(app.panes.len(), 2, "should have 2 agent panes");
        // BTreeMap ordering: claude_code before codex
        assert_eq!(app.panes[0].agent, "claude_code");
        assert_eq!(app.panes[0].hits.len(), 2);
        assert_eq!(app.panes[1].agent, "codex");
        assert_eq!(app.panes[1].hits.len(), 1);
        assert_eq!(app.results.len(), 3);
        assert_eq!(app.last_search_ms, Some(42));
        assert!(app.status.contains("3 results"));
    }

    #[test]
    fn search_requested_clears_dirty_state() {
        let mut app = CassApp::default();
        app.search_dirty_since = Some(Instant::now());
        let _ = app.update(CassMsg::SearchRequested);
        assert!(app.search_dirty_since.is_none());
    }

    #[test]
    fn history_navigation_traverses_entries() {
        let mut app = CassApp::default();
        app.query_history.push_front("third".to_string());
        app.query_history.push_front("second".to_string());
        app.query_history.push_front("first".to_string());
        // Navigate forward through history (Ctrl+N)
        let _ = app.update(CassMsg::HistoryNavigated { forward: true });
        assert_eq!(app.query, "second");
        let _ = app.update(CassMsg::HistoryNavigated { forward: true });
        assert_eq!(app.query, "third");
        // Navigate back (Ctrl+P)
        let _ = app.update(CassMsg::HistoryNavigated { forward: false });
        assert_eq!(app.query, "second");
    }

    #[test]
    fn enter_in_query_mode_submits_search() {
        let fixture = EnterRoutingFixture {
            input_mode: InputMode::Query,
            focus_id: focus_ids::SEARCH_BAR,
            selected_hit: false,
            show_detail_modal: false,
            detail_tab: DetailTab::Raw,
        };
        let outcome = run_enter_routing(fixture);
        assert_eq!(
            outcome.query_history_front.as_deref(),
            Some("test query"),
            "query-submit fallback should record query in history"
        );
        assert!(
            matches!(outcome.cmd_msg, Some(CassMsg::SearchRequested)),
            "fallback should dispatch SearchRequested; got {:?}",
            outcome.cmd_msg
        );
    }

    #[test]
    fn enter_on_selected_result_opens_detail_modal() {
        let fixture = EnterRoutingFixture {
            input_mode: InputMode::Query,
            focus_id: focus_ids::RESULTS_LIST,
            selected_hit: true,
            show_detail_modal: false,
            detail_tab: DetailTab::Raw,
        };
        let outcome = run_enter_routing(fixture);

        assert!(
            outcome.show_detail_modal,
            "Enter on a selected result should open modal"
        );
    }

    #[test]
    fn enter_on_selected_result_opens_modal_even_when_search_bar_focused() {
        let fixture = EnterRoutingFixture {
            input_mode: InputMode::Query,
            focus_id: focus_ids::SEARCH_BAR,
            selected_hit: true,
            show_detail_modal: false,
            detail_tab: DetailTab::Raw,
        };
        let outcome = run_enter_routing(fixture);

        assert!(
            outcome.show_detail_modal,
            "Enter with selected hit should open modal even if search bar still has focus"
        );
        assert_eq!(
            outcome.detail_tab,
            DetailTab::Messages,
            "Enter-open should land on contextual messages tab for markdown rendering"
        );
    }

    #[test]
    fn enter_routing_diagnostics_emit_query_submit_fallback_marker() {
        let mut app = CassApp::default();
        app.input_mode = InputMode::Query;
        app.focus_manager.focus(focus_ids::SEARCH_BAR);

        let logs = capture_trace_output(|| {
            let _ = app.update(CassMsg::DetailOpened);
        });

        assert!(
            logs.contains("route=\"query_submit_fallback\""),
            "expected query-submit fallback diagnostic marker, logs={logs}"
        );
        assert!(
            logs.contains("reason=\"no_selected_hit\""),
            "expected fallback reason marker, logs={logs}"
        );
    }

    #[test]
    fn enter_routing_diagnostics_emit_detail_modal_open_marker() {
        let mut app = CassApp::default();
        app.input_mode = InputMode::Query;
        app.panes.push(AgentPane {
            agent: "codex".into(),
            total_count: 1,
            hits: vec![make_test_hit()],
            selected: 0,
        });
        app.active_pane = 0;
        app.focus_manager.focus(focus_ids::RESULTS_LIST);

        let logs = capture_trace_output(|| {
            let _ = app.update(CassMsg::DetailOpened);
        });

        assert!(
            logs.contains("route=\"detail_modal_open\""),
            "expected modal-open diagnostic marker, logs={logs}"
        );
        assert!(
            logs.contains("reason=\"selected_hit\""),
            "expected selected-hit reason marker, logs={logs}"
        );
    }

    #[test]
    fn enter_with_detail_modal_opens_detail() {
        let fixture = EnterRoutingFixture {
            input_mode: InputMode::Query,
            focus_id: focus_ids::SEARCH_BAR,
            selected_hit: false,
            show_detail_modal: true,
            detail_tab: DetailTab::Messages,
        };
        let outcome = run_enter_routing(fixture);
        assert!(
            outcome.show_detail_modal,
            "should remain in detail modal (no query-submit fallback)"
        );
    }

    #[test]
    fn enter_routing_helper_matrix_smoke() {
        let cases = [
            (
                "query-focus no selection",
                EnterRoutingFixture {
                    input_mode: InputMode::Query,
                    focus_id: focus_ids::SEARCH_BAR,
                    selected_hit: false,
                    show_detail_modal: false,
                    detail_tab: DetailTab::Raw,
                },
                ExpectedEnterRoute::QuerySubmit,
                None,
            ),
            (
                "results-focus no selection",
                EnterRoutingFixture {
                    input_mode: InputMode::Query,
                    focus_id: focus_ids::RESULTS_LIST,
                    selected_hit: false,
                    show_detail_modal: false,
                    detail_tab: DetailTab::Raw,
                },
                ExpectedEnterRoute::QuerySubmit,
                None,
            ),
            (
                "results-focus selected hit",
                EnterRoutingFixture {
                    input_mode: InputMode::Query,
                    focus_id: focus_ids::RESULTS_LIST,
                    selected_hit: true,
                    show_detail_modal: false,
                    detail_tab: DetailTab::Raw,
                },
                ExpectedEnterRoute::DetailModalOpen,
                Some(DetailTab::Messages),
            ),
            (
                "search-focus selected hit",
                EnterRoutingFixture {
                    input_mode: InputMode::Query,
                    focus_id: focus_ids::SEARCH_BAR,
                    selected_hit: true,
                    show_detail_modal: false,
                    detail_tab: DetailTab::Raw,
                },
                ExpectedEnterRoute::DetailModalOpen,
                Some(DetailTab::Messages),
            ),
            (
                "modal already open with selected hit",
                EnterRoutingFixture {
                    input_mode: InputMode::Query,
                    focus_id: focus_ids::DETAIL_MODAL,
                    selected_hit: true,
                    show_detail_modal: true,
                    detail_tab: DetailTab::Raw,
                },
                ExpectedEnterRoute::DetailModalOpen,
                Some(DetailTab::Raw),
            ),
        ];

        for (label, fixture, expected, expected_tab) in cases {
            assert_enter_route(label, fixture, expected);
            if let Some(tab) = expected_tab {
                let outcome = run_enter_routing(fixture);
                assert_eq!(
                    outcome.detail_tab, tab,
                    "{label}: unexpected tab after enter-routing"
                );
            }
        }
    }

    #[test]
    fn enter_matrix_non_query_modes_apply_input_without_opening_modal() {
        let cases = [
            (InputMode::PaneFilter, "auth"),
            (InputMode::Agent, "claude_code"),
            (InputMode::Workspace, "/projects/test"),
        ];

        for (mode, seed) in cases {
            let mut app = CassApp::default();
            app.input_mode = mode;
            app.input_buffer = seed.to_string();
            if mode == InputMode::PaneFilter {
                app.pane_filter = Some(seed.to_string());
            }
            app.focus_manager.focus(focus_ids::SEARCH_BAR);

            let cmd = app.update(CassMsg::DetailOpened);
            drain_cmd_messages(&mut app, cmd);

            assert!(
                !app.show_detail_modal,
                "{mode:?}: Enter should apply input mode, not open detail"
            );
            assert_eq!(
                app.input_mode,
                InputMode::Query,
                "{mode:?}: input mode should return to Query after apply"
            );
            match mode {
                InputMode::PaneFilter => assert_eq!(
                    app.pane_filter.as_deref(),
                    Some(seed),
                    "pane filter should be applied"
                ),
                InputMode::Agent => assert!(
                    app.filters.agents.contains(seed),
                    "agent filter should include applied value"
                ),
                InputMode::Workspace => assert!(
                    app.filters.workspaces.contains(seed),
                    "workspace filter should include applied value"
                ),
                _ => unreachable!("only non-query filter modes are covered"),
            }
        }
    }

    #[test]
    fn debounce_fires_search_after_elapsed() {
        let mut app = CassApp::default();
        // Set search_dirty_since to well past the debounce threshold
        app.search_dirty_since = Some(Instant::now() - std::time::Duration::from_millis(100));
        let cmd = app.update(CassMsg::Tick);
        // Should have fired SearchRequested via batch
        // After tick, search_dirty_since should be cleared by SearchRequested
        // The batch contains SearchRequested + ToastTick
        assert!(
            matches!(cmd, ftui::Cmd::Batch(_)),
            "tick should return batch with SearchRequested when debounce elapsed"
        );
    }

    #[test]
    fn debounce_does_not_fire_before_threshold() {
        let mut app = CassApp::default();
        // Set search_dirty_since to just now (within debounce window)
        app.search_dirty_since = Some(Instant::now());
        let cmd = app.update(CassMsg::Tick);
        // Should NOT have fired SearchRequested - just ToastTick
        assert!(
            matches!(cmd, ftui::Cmd::Msg(_)),
            "tick should return single Msg (ToastTick) when debounce not elapsed"
        );
    }

    #[test]
    fn query_changed_resets_history_cursor() {
        let mut app = CassApp::default();
        app.history_cursor = Some(2);
        let _ = app.update(CassMsg::QueryChanged("x".into()));
        assert!(app.history_cursor.is_none());
    }

    #[test]
    fn query_changed_returns_tick_cmd() {
        let mut app = CassApp::default();
        let cmd = app.update(CassMsg::QueryChanged("a".into()));
        assert!(
            matches!(cmd, ftui::Cmd::Tick(_)),
            "QueryChanged should return Cmd::Tick for debounce"
        );
    }

    #[test]
    fn query_cleared_returns_tick_and_resets_cursor() {
        let mut app = CassApp::default();
        app.query = "foo".to_string();
        app.cursor_pos = 3;
        let cmd = app.update(CassMsg::QueryCleared);
        assert!(
            matches!(cmd, ftui::Cmd::Tick(_)),
            "QueryCleared should return Cmd::Tick"
        );
        assert_eq!(app.cursor_pos, 0);
    }

    #[test]
    fn query_word_deleted_returns_tick_cmd() {
        let mut app = CassApp::default();
        app.query = "hello world".to_string();
        app.cursor_pos = 11;
        let cmd = app.update(CassMsg::QueryWordDeleted);
        assert!(
            matches!(cmd, ftui::Cmd::Tick(_)),
            "QueryWordDeleted should return Cmd::Tick when text was deleted"
        );
    }

    #[test]
    fn query_word_deleted_noop_at_start() {
        let mut app = CassApp::default();
        app.query = "hello".to_string();
        app.cursor_pos = 0;
        let cmd = app.update(CassMsg::QueryWordDeleted);
        assert_eq!(
            app.query, "hello",
            "should not change query when cursor at 0"
        );
        assert!(matches!(cmd, ftui::Cmd::None));
    }

    #[test]
    fn cursor_moved_bounds_checking() {
        let mut app = CassApp::default();
        app.query = "abc".to_string();
        app.cursor_pos = 1;
        app.focus_manager.focus(focus_ids::SEARCH_BAR);
        let _ = app.update(CassMsg::CursorMoved { delta: -1 });
        assert_eq!(app.cursor_pos, 0);
        let _ = app.update(CassMsg::CursorMoved { delta: -1 });
        assert_eq!(app.cursor_pos, 0, "should clamp at 0");
        let _ = app.update(CassMsg::CursorMoved { delta: 1 });
        assert_eq!(app.cursor_pos, 1);
        let _ = app.update(CassMsg::CursorMoved { delta: 10 });
        assert_eq!(app.cursor_pos, 3, "should clamp at query length");
    }

    #[test]
    fn cursor_moved_in_results_focus_switches_active_pane() {
        let mut app = CassApp::default();
        app.panes = vec![
            AgentPane {
                agent: "claude_code".into(),
                total_count: 1,
                hits: vec![make_test_hit()],
                selected: 0,
            },
            AgentPane {
                agent: "codex".into(),
                total_count: 1,
                hits: vec![make_test_hit()],
                selected: 0,
            },
        ];
        app.active_pane = 0;
        app.focus_manager.focus(focus_ids::RESULTS_LIST);

        let _ = app.update(CassMsg::CursorMoved { delta: 1 });
        assert_eq!(app.active_pane, 1, "Right arrow should advance pane");

        let _ = app.update(CassMsg::CursorMoved { delta: -1 });
        assert_eq!(app.active_pane, 0, "Left arrow should move back one pane");
    }

    #[test]
    fn cursor_moved_right_at_last_pane_focuses_detail() {
        let mut app = CassApp::default();
        app.panes = vec![AgentPane {
            agent: "codex".into(),
            total_count: 1,
            hits: vec![make_test_hit()],
            selected: 0,
        }];
        app.active_pane = 0;
        app.focus_manager.focus(focus_ids::RESULTS_LIST);

        let _ = app.update(CassMsg::CursorMoved { delta: 1 });
        assert_eq!(
            app.focus_manager.current(),
            Some(focus_ids::DETAIL_PANE),
            "Right arrow at last pane should focus detail pane"
        );

        let _ = app.update(CassMsg::CursorMoved { delta: -1 });
        assert_eq!(
            app.focus_manager.current(),
            Some(focus_ids::RESULTS_LIST),
            "Left arrow from detail should return focus to results"
        );
    }

    #[test]
    fn cursor_jumped_to_start_and_end() {
        let mut app = CassApp::default();
        app.query = "hello world".to_string();
        app.cursor_pos = 5;
        let _ = app.update(CassMsg::CursorJumped { to_end: true });
        assert_eq!(app.cursor_pos, 11);
        let _ = app.update(CassMsg::CursorJumped { to_end: false });
        assert_eq!(app.cursor_pos, 0);
    }

    #[test]
    fn insert_at_cursor_middle() {
        let mut app = CassApp::default();
        app.query = "hllo".to_string();
        app.cursor_pos = 1;
        let _ = app.update(CassMsg::QueryChanged("e".into()));
        assert_eq!(app.query, "hello");
        assert_eq!(app.cursor_pos, 2);
    }

    #[test]
    fn backspace_at_cursor_middle() {
        let mut app = CassApp::default();
        app.query = "heello".to_string();
        app.cursor_pos = 3;
        let _ = app.update(CassMsg::QueryChanged(String::new()));
        assert_eq!(app.query, "hello");
        assert_eq!(app.cursor_pos, 2);
    }

    #[test]
    fn history_navigation_sets_cursor_to_end() {
        let mut app = CassApp::default();
        app.query_history.push_front("long query text".to_string());
        app.cursor_pos = 0;
        let _ = app.update(CassMsg::HistoryNavigated { forward: true });
        assert_eq!(app.cursor_pos, 15);
    }

    // ==================== Update assistant tests ====================

    #[test]
    fn update_check_completed_sets_banner_state() {
        let mut app = CassApp::default();
        assert!(!app.update_banner_visible());
        let _ = app.update(CassMsg::UpdateCheckCompleted(sample_update_info()));
        assert!(app.update_banner_visible());
        assert!(!app.update_dismissed);
        assert!(!app.update_upgrade_armed);
        assert!(app.status.contains("Update available"));
    }

    #[test]
    fn update_dismiss_hides_banner() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::UpdateCheckCompleted(sample_update_info()));
        assert!(app.update_banner_visible());
        let _ = app.update(CassMsg::UpdateDismissed);
        assert!(!app.update_banner_visible());
        assert!(app.update_dismissed);
        assert!(!app.update_upgrade_armed);
    }

    #[test]
    fn update_upgrade_requires_double_confirm() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::UpdateCheckCompleted(sample_update_info()));

        let _ = app.update(CassMsg::UpdateUpgradeRequested);
        assert!(app.update_upgrade_armed);
        assert!(app.status.contains("Confirm upgrade"));

        let _ = app.update(CassMsg::UpdateUpgradeRequested);
        assert!(!app.update_upgrade_armed);
        assert!(app.status.contains("TEST mode: would launch self-update"));
    }

    #[test]
    fn tick_polls_update_channel_and_dispatches_completion() {
        let mut app = CassApp::default();
        let (tx, rx) = std::sync::mpsc::channel();
        tx.send(Some(sample_update_info()))
            .expect("send update info to test channel");
        app.update_check_rx = Some(rx);

        let msgs = extract_msgs(app.update(CassMsg::Tick));
        let mut completed_info: Option<UpdateInfo> = None;
        for msg in msgs {
            match msg {
                CassMsg::UpdateCheckCompleted(info) => completed_info = Some(info),
                CassMsg::ToastTick => {}
                _ => {}
            }
        }

        assert!(
            completed_info.is_some(),
            "tick should dispatch update completion"
        );
        assert!(app.update_check_rx.is_none(), "receiver should be consumed");

        if let Some(info) = completed_info {
            let _ = app.update(CassMsg::UpdateCheckCompleted(info));
        }
        assert!(app.update_banner_visible());
    }

    #[test]
    fn update_shortcuts_intercept_shifted_query_when_banner_visible() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::UpdateCheckCompleted(sample_update_info()));

        let _ = app.update(CassMsg::QueryChanged("U".to_string()));
        assert!(app.update_upgrade_armed);
        assert!(app.query.is_empty(), "shortcut should not edit query text");

        let _ = app.update(CassMsg::QueryChanged("S".to_string()));
        assert!(
            app.update_dismissed,
            "skip should dismiss banner in test mode"
        );
        assert!(!app.update_upgrade_armed);
    }

    #[test]
    fn update_banner_does_not_hijack_lowercase_query_input() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::UpdateCheckCompleted(sample_update_info()));

        let _ = app.update(CassMsg::QueryChanged("u".to_string()));
        assert_eq!(app.query, "u");
        assert!(
            !app.update_upgrade_armed,
            "lowercase query text should not trigger update action"
        );
    }

    // ==================== Wildcard fallback toggle tests ====================

    #[test]
    fn wildcard_fallback_toggle_flips_state() {
        let mut app = CassApp::default();
        assert!(!app.wildcard_fallback);
        let _ = app.update(CassMsg::WildcardFallbackToggled);
        assert!(app.wildcard_fallback);
        let _ = app.update(CassMsg::WildcardFallbackToggled);
        assert!(!app.wildcard_fallback);
    }

    // ==================== Search dispatch tests ====================

    #[test]
    fn search_requested_skips_empty_query() {
        let mut app = CassApp::default();
        app.query = "   ".to_string();
        app.search_dirty_since = Some(Instant::now());
        let _ = app.update(CassMsg::SearchRequested);
        assert!(app.search_dirty_since.is_none(), "dirty state should clear");
        // No search dispatched (no service, query is empty whitespace)
        assert!(app.status.is_empty());
        assert!(app.loading_context.is_none());
    }

    #[test]
    fn search_requested_dispatches_with_service() {
        use std::sync::atomic::{AtomicBool, Ordering};

        struct FixtureSearch {
            called: AtomicBool,
        }
        impl SearchService for FixtureSearch {
            fn execute(&self, _params: &SearchParams) -> Result<SearchResult, String> {
                self.called.store(true, Ordering::SeqCst);
                Ok(SearchResult {
                    hits: vec![],
                    elapsed_ms: 5,
                    suggestions: vec![],
                    wildcard_fallback: false,
                })
            }
        }

        let fixture = Arc::new(FixtureSearch {
            called: AtomicBool::new(false),
        });
        let mut app = CassApp::default();
        app.query = "test query".to_string();
        app.search_service = Some(fixture.clone());
        let cmd = app.update(CassMsg::SearchRequested);
        assert!(app.status.contains("Searching"));
        assert_eq!(
            app.loading_context,
            Some(LoadingContext::Search),
            "search request should raise loading context"
        );
        // Cmd should be a Task variant (non-none).
        // Verify by extracting the task closure via format debug.
        let debug = format!("{cmd:?}");
        assert!(debug.contains("Task"), "expected Cmd::Task, got: {debug}");
    }

    #[test]
    fn search_requested_noop_without_service() {
        let mut app = CassApp::default();
        app.query = "test query".to_string();
        app.search_service = None;
        let cmd = app.update(CassMsg::SearchRequested);
        let debug = format!("{cmd:?}");
        assert!(
            debug.contains("None"),
            "expected Cmd::None without service, got: {debug}"
        );
        assert!(app.loading_context.is_none());
    }

    #[test]
    fn search_terminal_states_clear_loading_context() {
        let mut app = CassApp::default();
        app.loading_context = Some(LoadingContext::Search);

        let _ = app.update(CassMsg::SearchCompleted {
            generation: app.search_generation,
            hits: vec![],
            elapsed_ms: 1,
            suggestions: vec![],
            wildcard_fallback: false,
            append: false,
        });
        assert!(app.loading_context.is_none());

        app.loading_context = Some(LoadingContext::Search);
        let _ = app.update(CassMsg::SearchFailed {
            generation: app.search_generation,
            error: "boom".into(),
        });
        assert!(app.loading_context.is_none());
    }

    // ==================== VirtualizedList integration tests ====================

    #[test]
    fn result_item_render_item_height_matches_density() {
        let hit = SearchHit {
            title: "Test".into(),
            snippet: "snippet".into(),
            content: "content".into(),
            content_hash: 0,
            score: 0.9,
            agent: "claude_code".into(),
            source_path: "/a".into(),
            workspace: "/w".into(),
            workspace_original: None,
            created_at: None,
            line_number: None,
            match_type: Default::default(),
            source_id: "local".into(),
            origin_kind: "local".into(),
            origin_host: None,
        };
        for mode in [
            DensityMode::Compact,
            DensityMode::Cozy,
            DensityMode::Spacious,
        ] {
            let density_h = mode.row_height();
            let item = ResultItem {
                index: 1,
                hit: hit.clone(),
                row_height: density_h,
                even: true,
                max_width: 80,
                queued: false,
                stripe_style: ftui::Style::default(),
                selected_style: ftui::Style::default(),
                agent_accent_style: ftui::Style::default(),
                score_style: ftui::Style::default(),
                text_primary_style: ftui::Style::default(),
                text_muted_style: ftui::Style::default(),
                text_subtle_style: ftui::Style::default(),
                success_style: ftui::Style::default(),
                source_local_style: ftui::Style::default(),
                source_remote_style: ftui::Style::default(),
                location_style: ftui::Style::default(),
                mini_analytics: None,
                reveal_progress: 1.0,
                focus_flash_intensity: 0.0,
                query_terms: vec![],
                query_highlight_style: ftui::Style::new(),
                hovered: false,
            };
            assert_eq!(item.height(), density_h, "density {mode:?}");
        }
    }

    #[test]
    fn selection_moved_syncs_virtualized_state() {
        let mut app = CassApp::default();
        app.panes.push(AgentPane {
            agent: "claude_code".into(),
            hits: vec![
                SearchHit {
                    title: "A".into(),
                    snippet: "".into(),
                    content: "".into(),
                    content_hash: 0,
                    score: 1.0,
                    agent: "claude_code".into(),
                    source_path: "/a".into(),
                    workspace: "/w".into(),
                    workspace_original: None,
                    created_at: None,
                    line_number: None,
                    match_type: Default::default(),
                    source_id: "local".into(),
                    origin_kind: "local".into(),
                    origin_host: None,
                },
                SearchHit {
                    title: "B".into(),
                    snippet: "".into(),
                    content: "".into(),
                    content_hash: 1,
                    score: 0.9,
                    agent: "claude_code".into(),
                    source_path: "/b".into(),
                    workspace: "/w".into(),
                    workspace_original: None,
                    created_at: None,
                    line_number: None,
                    match_type: Default::default(),
                    source_id: "local".into(),
                    origin_kind: "local".into(),
                    origin_host: None,
                },
                SearchHit {
                    title: "C".into(),
                    snippet: "".into(),
                    content: "".into(),
                    content_hash: 2,
                    score: 0.8,
                    agent: "claude_code".into(),
                    source_path: "/c".into(),
                    workspace: "/w".into(),
                    workspace_original: None,
                    created_at: None,
                    line_number: None,
                    match_type: Default::default(),
                    source_id: "local".into(),
                    origin_kind: "local".into(),
                    origin_host: None,
                },
            ],
            selected: 0,
            total_count: 3,
        });
        app.active_pane = 0;

        // Move down twice
        let _ = app.update(CassMsg::SelectionMoved { delta: 1 });
        assert_eq!(app.panes[0].selected, 1);
        let _ = app.update(CassMsg::SelectionMoved { delta: 1 });
        assert_eq!(app.panes[0].selected, 2);

        // Move up once
        let _ = app.update(CassMsg::SelectionMoved { delta: -1 });
        assert_eq!(app.panes[0].selected, 1);

        // Jump to end
        let _ = app.update(CassMsg::SelectionJumped { to_end: true });
        assert_eq!(app.panes[0].selected, 2);

        // Jump to start
        let _ = app.update(CassMsg::SelectionJumped { to_end: false });
        assert_eq!(app.panes[0].selected, 0);

        // VirtualizedListState should be in sync
        let state = app.results_list_state.borrow();
        assert_eq!(state.selected, Some(0));
    }

    #[test]
    fn search_completed_resets_scroll_state() {
        let mut app = CassApp::default();
        // Set up some scroll state
        {
            let mut state = app.results_list_state.borrow_mut();
            state.select(Some(5));
        }
        let hits = vec![SearchHit {
            title: "New".into(),
            snippet: "".into(),
            content: "".into(),
            content_hash: 0,
            score: 1.0,
            agent: "claude_code".into(),
            source_path: "/a".into(),
            workspace: "/w".into(),
            workspace_original: None,
            created_at: None,
            line_number: None,
            match_type: Default::default(),
            source_id: "local".into(),
            origin_kind: "local".into(),
            origin_host: None,
        }];
        let _ = app.update(CassMsg::SearchCompleted {
            generation: app.search_generation,
            hits,
            elapsed_ms: 10,
            suggestions: vec![],
            wildcard_fallback: false,
            append: false,
        });
        let state = app.results_list_state.borrow();
        assert_eq!(state.selected, Some(0), "should reset to first item");
        assert_eq!(state.scroll_offset(), 0, "should scroll to top");
    }

    #[test]
    fn queued_items_render_with_checkmark() {
        let hit = SearchHit {
            title: "Test".into(),
            snippet: "".into(),
            content: "".into(),
            content_hash: 0,
            score: 0.9,
            agent: "claude_code".into(),
            source_path: "/a".into(),
            workspace: "/w".into(),
            workspace_original: None,
            created_at: None,
            line_number: None,
            match_type: Default::default(),
            source_id: "local".into(),
            origin_kind: "local".into(),
            origin_host: None,
        };
        let queued_item = ResultItem {
            index: 1,
            hit: hit.clone(),
            row_height: 1,
            even: true,
            max_width: 80,
            queued: true,
            stripe_style: ftui::Style::default(),
            selected_style: ftui::Style::default(),
            agent_accent_style: ftui::Style::default(),
            score_style: ftui::Style::default(),
            text_primary_style: ftui::Style::default(),
            text_muted_style: ftui::Style::default(),
            text_subtle_style: ftui::Style::default(),
            success_style: ftui::Style::default(),
            source_local_style: ftui::Style::default(),
            source_remote_style: ftui::Style::default(),
            location_style: ftui::Style::default(),
            mini_analytics: None,
            reveal_progress: 1.0,
            focus_flash_intensity: 0.0,
            query_terms: vec![],
            query_highlight_style: ftui::Style::new(),
            hovered: false,
        };
        let not_queued = ResultItem {
            index: 1,
            hit,
            row_height: 1,
            even: true,
            max_width: 80,
            queued: false,
            stripe_style: ftui::Style::default(),
            selected_style: ftui::Style::default(),
            agent_accent_style: ftui::Style::default(),
            score_style: ftui::Style::default(),
            text_primary_style: ftui::Style::default(),
            text_muted_style: ftui::Style::default(),
            text_subtle_style: ftui::Style::default(),
            success_style: ftui::Style::default(),
            source_local_style: ftui::Style::default(),
            source_remote_style: ftui::Style::default(),
            location_style: ftui::Style::default(),
            mini_analytics: None,
            reveal_progress: 1.0,
            focus_flash_intensity: 0.0,
            query_terms: vec![],
            query_highlight_style: ftui::Style::new(),
            hovered: false,
        };
        assert!(queued_item.queued);
        assert!(!not_queued.queued);
    }

    #[test]
    fn result_item_source_badge_reflects_local_and_remote_provenance() {
        let mut local_hit = make_test_hit();
        local_hit.source_id = "local".to_string();
        local_hit.origin_kind = "local".to_string();
        local_hit.origin_host = None;
        let local_item = ResultItem {
            index: 1,
            hit: local_hit,
            row_height: 1,
            even: true,
            max_width: 80,
            queued: false,
            stripe_style: ftui::Style::default(),
            selected_style: ftui::Style::default(),
            agent_accent_style: ftui::Style::default(),
            score_style: ftui::Style::default(),
            text_primary_style: ftui::Style::default(),
            text_muted_style: ftui::Style::default(),
            text_subtle_style: ftui::Style::default(),
            success_style: ftui::Style::default(),
            source_local_style: ftui::Style::default(),
            source_remote_style: ftui::Style::default(),
            location_style: ftui::Style::default(),
            mini_analytics: None,
            reveal_progress: 1.0,
            focus_flash_intensity: 0.0,
            query_terms: vec![],
            query_highlight_style: ftui::Style::new(),
            hovered: false,
        };
        assert_eq!(local_item.source_badge(), "[local]");

        let mut remote_hit = make_test_hit();
        remote_hit.source_id = "work-laptop".to_string();
        remote_hit.origin_kind = "ssh".to_string();
        remote_hit.origin_host = Some("laptop".to_string());
        let remote_item = ResultItem {
            index: 2,
            hit: remote_hit,
            row_height: 1,
            even: false,
            max_width: 80,
            queued: false,
            stripe_style: ftui::Style::default(),
            selected_style: ftui::Style::default(),
            agent_accent_style: ftui::Style::default(),
            score_style: ftui::Style::default(),
            text_primary_style: ftui::Style::default(),
            text_muted_style: ftui::Style::default(),
            text_subtle_style: ftui::Style::default(),
            success_style: ftui::Style::default(),
            source_local_style: ftui::Style::default(),
            source_remote_style: ftui::Style::default(),
            location_style: ftui::Style::default(),
            mini_analytics: None,
            reveal_progress: 1.0,
            focus_flash_intensity: 0.0,
            query_terms: vec![],
            query_highlight_style: ftui::Style::new(),
            hovered: false,
        };
        assert_eq!(remote_item.source_badge(), "[laptop]");
    }

    #[test]
    fn result_item_mini_analytics_hidden_on_narrow() {
        let mut item = make_result_item(make_test_hit(), DensityMode::Cozy.row_height());
        item.max_width = 72; // Narrow breakpoint
        item.mini_analytics = Some(RowMiniAnalytics {
            matched_messages: 5,
        });

        let text: String = item
            .mini_analytics_spans()
            .iter()
            .map(|span| span.content.as_ref().to_string())
            .collect();
        assert!(text.is_empty(), "narrow rows should hide analytics badges");
    }

    #[test]
    fn result_item_mini_analytics_medium_narrow_shows_message_only() {
        let mut item = make_result_item(make_test_hit(), DensityMode::Cozy.row_height());
        item.max_width = 100; // MediumNarrow breakpoint
        item.mini_analytics = Some(RowMiniAnalytics {
            matched_messages: 5,
        });

        let text: String = item
            .mini_analytics_spans()
            .iter()
            .map(|span| span.content.as_ref().to_string())
            .collect();
        assert!(text.contains("msgs"), "expected message badge, got: {text}");
        assert!(
            !text.contains('$'),
            "should not show cost badge, got: {text}"
        );
    }

    #[test]
    fn result_item_mini_analytics_medium_shows_messages_only() {
        let mut item = make_result_item(make_test_hit(), DensityMode::Cozy.row_height());
        item.max_width = 140; // Medium breakpoint
        item.mini_analytics = Some(RowMiniAnalytics {
            matched_messages: 5,
        });

        let text: String = item
            .mini_analytics_spans()
            .iter()
            .map(|span| span.content.as_ref().to_string())
            .collect();
        assert!(text.contains("msgs"), "expected message badge, got: {text}");
        assert!(
            !text.contains('$'),
            "should not show cost badge, got: {text}"
        );
    }

    #[test]
    fn highlight_query_spans_marks_matching_terms() {
        let base = ftui::Style::new();
        let hl = ftui::Style::new().bold();
        let spans = highlight_query_spans("Fix the login bug quickly", &["login".into()], base, hl);
        assert_eq!(spans.len(), 3, "expect before/match/after");
        assert_eq!(spans[0].content, "Fix the ");
        assert_eq!(spans[1].content, "login");
        assert_eq!(spans[2].content, " bug quickly");
    }

    #[test]
    fn highlight_query_spans_case_insensitive() {
        let base = ftui::Style::new();
        let hl = ftui::Style::new().bold();
        let spans = highlight_query_spans("Hello WORLD hello", &["hello".into()], base, hl);
        assert_eq!(spans.len(), 3, "two matches + one gap between them");
        assert_eq!(spans[0].content, "Hello");
        assert_eq!(spans[1].content, " WORLD ");
        assert_eq!(spans[2].content, "hello");
    }

    #[test]
    fn highlight_query_spans_no_match_returns_single_span() {
        let base = ftui::Style::new();
        let hl = ftui::Style::new().bold();
        let spans = highlight_query_spans("no matches here", &["xyz".into()], base, hl);
        assert_eq!(spans.len(), 1);
        assert_eq!(spans[0].content, "no matches here");
    }

    #[test]
    fn highlight_query_spans_empty_terms_returns_single_span() {
        let base = ftui::Style::new();
        let hl = ftui::Style::new().bold();
        let spans = highlight_query_spans("some text", &[], base, hl);
        assert_eq!(spans.len(), 1);
    }

    #[test]
    fn highlight_query_spans_overlapping_terms_merge() {
        let base = ftui::Style::new();
        let hl = ftui::Style::new().bold();
        // "log" and "login" overlap — should merge into single highlight for "login"
        let spans = highlight_query_spans("fix login", &["log".into(), "login".into()], base, hl);
        // "fix " + "login" = 2 spans
        assert_eq!(spans.len(), 2);
        assert_eq!(spans[0].content, "fix ");
        assert_eq!(spans[1].content, "login");
    }

    #[test]
    fn extract_query_terms_filters_short_words() {
        let terms = extract_query_terms("a the login fix");
        assert_eq!(terms, vec!["the", "login", "fix"]);
    }

    #[test]
    fn extract_query_terms_empty_query() {
        let terms = extract_query_terms("");
        assert!(terms.is_empty());
    }

    #[test]
    fn result_item_snippet_fallback_chain_prefers_snippet_then_content_then_title() {
        let mut hit = make_test_hit();
        hit.title = "Title fallback sentinel".to_string();
        hit.snippet = "snippet sentinel primary".to_string();
        hit.content = "content sentinel secondary".to_string();
        let mut item = make_result_item(hit.clone(), DensityMode::Cozy.row_height());

        assert_eq!(
            item.snippet_lines(64, 1),
            vec!["snippet sentinel primary".to_string()]
        );

        hit.snippet.clear();
        item.hit = hit.clone();
        assert_eq!(
            item.snippet_lines(64, 1),
            vec!["content sentinel secondary".to_string()]
        );

        hit.content.clear();
        item.hit = hit;
        assert_eq!(
            item.snippet_lines(64, 1),
            vec!["Title fallback sentinel".to_string()]
        );
    }

    #[test]
    fn result_item_snippet_wrapping_respects_narrow_width_without_empty_artifacts() {
        let mut hit = make_test_hit();
        hit.snippet =
            "supercalifragilisticexpialidocious-token wraps-without-overflow and keeps context"
                .to_string();
        let item = make_result_item(hit, DensityMode::Spacious.row_height());
        let lines = item.snippet_lines(14, 3);

        assert_eq!(
            lines.len(),
            3,
            "spacious budget should allow 3 snippet lines"
        );
        assert!(lines.iter().all(|line| !line.trim().is_empty()));
        assert!(lines.iter().all(|line| line.chars().count() <= 14));
    }

    #[test]
    fn compact_density_results_row_includes_inline_snippet_preview() {
        use ftui::render::budget::DegradationLevel;
        use ftui_harness::buffer_to_text;

        let mut app = CassApp::default();
        let mut hit = make_test_hit();
        hit.title = "Compact row title".to_string();
        hit.snippet = "inline-preview-sentinel compact snippet payload".to_string();
        hit.content = String::new();
        app.panes.push(AgentPane {
            agent: hit.agent.clone(),
            total_count: 1,
            hits: vec![hit],
            selected: 0,
        });
        app.active_pane = 0;
        app.density_mode = DensityMode::Compact;

        let text = buffer_to_text(&render_at_degradation(
            &app,
            120,
            24,
            DegradationLevel::Full,
        ));
        assert!(
            text.contains("inline-preview-sentinel"),
            "compact rows should surface inline snippet context"
        );
    }

    #[test]
    fn spacious_density_allocates_three_snippet_lines_when_width_allows() {
        let mut hit = make_test_hit();
        hit.snippet = "alpha beta gamma delta epsilon zeta eta theta iota kappa lambda mu nu xi omicron pi rho".to_string();
        let item = make_result_item(hit, DensityMode::Spacious.row_height());
        let budget = item.snippet_line_budget(72);
        let lines = item.snippet_lines(24, budget);

        assert_eq!(
            budget, 3,
            "spacious rows should reserve three snippet lines"
        );
        assert_eq!(lines.len(), 3);
    }

    // =====================================================================
    // 2dccg.9.6 — Density mode retuning tests
    // =====================================================================

    #[test]
    fn density_row_heights_match_spec() {
        // Spec: Compact=2, Cozy=5 (title + meta + location + snippet×2), Spacious=6
        assert_eq!(DensityMode::Compact.row_height(), 2);
        assert_eq!(DensityMode::Cozy.row_height(), 5);
        assert_eq!(DensityMode::Spacious.row_height(), 6);
    }

    #[test]
    fn density_snippet_lines_match_spec() {
        // Spec: Compact=0 (inline only), Cozy=2, Spacious=3
        assert_eq!(DensityMode::Compact.snippet_lines(), 0);
        assert_eq!(DensityMode::Cozy.snippet_lines(), 2);
        assert_eq!(DensityMode::Spacious.snippet_lines(), 3);
    }

    #[test]
    fn density_effective_falls_back_to_compact_when_narrow() {
        // Spec: "auto-fallback to Compact if cols < 90"
        assert_eq!(DensityMode::Cozy.effective(89), DensityMode::Compact);
        assert_eq!(DensityMode::Spacious.effective(89), DensityMode::Compact);
        assert_eq!(DensityMode::Compact.effective(89), DensityMode::Compact);
        // At 90 cols, no fallback
        assert_eq!(DensityMode::Cozy.effective(90), DensityMode::Cozy);
        assert_eq!(DensityMode::Spacious.effective(90), DensityMode::Spacious);
        // Wide terminals preserve mode
        assert_eq!(DensityMode::Cozy.effective(200), DensityMode::Cozy);
        assert_eq!(DensityMode::Spacious.effective(200), DensityMode::Spacious);
    }

    #[test]
    fn density_effective_boundary_values() {
        // Boundary: 0 width should fallback
        assert_eq!(DensityMode::Cozy.effective(0), DensityMode::Compact);
        // Boundary: 1 below threshold
        assert_eq!(DensityMode::Cozy.effective(89), DensityMode::Compact);
        // Boundary: exactly at threshold
        assert_eq!(DensityMode::Cozy.effective(90), DensityMode::Cozy);
        // Boundary: 1 above threshold
        assert_eq!(DensityMode::Cozy.effective(91), DensityMode::Cozy);
    }

    #[test]
    fn cozy_density_allocates_two_snippet_lines() {
        let mut hit = make_test_hit();
        hit.snippet = "alpha beta gamma delta epsilon zeta eta theta iota kappa lambda mu nu xi omicron pi rho".to_string();
        let item = make_result_item(hit, DensityMode::Cozy.row_height());
        let budget = item.snippet_line_budget(120);

        assert_eq!(
            budget, 2,
            "cozy rows should reserve two snippet lines (row_height=5, budget=5-3=2)"
        );
    }

    #[test]
    fn density_cycling_covers_all_three_modes() {
        let mut app = CassApp::default();
        assert_eq!(app.density_mode, DensityMode::Cozy, "default is Cozy");

        // Cycle: Cozy → Spacious
        let _ = app.update(CassMsg::DensityModeCycled);
        assert_eq!(app.density_mode, DensityMode::Spacious);

        // Cycle: Spacious → Compact
        let _ = app.update(CassMsg::DensityModeCycled);
        assert_eq!(app.density_mode, DensityMode::Compact);

        // Cycle: Compact → Cozy
        let _ = app.update(CassMsg::DensityModeCycled);
        assert_eq!(app.density_mode, DensityMode::Cozy);
    }

    #[test]
    fn density_effective_wired_in_view_rendering() {
        use ftui::render::budget::DegradationLevel;
        use ftui_harness::buffer_to_text;

        let mut app = CassApp::default();
        let mut hit = make_test_hit();
        hit.snippet = "density-effective-test-sentinel".to_string();
        app.panes.push(AgentPane {
            agent: hit.agent.clone(),
            total_count: 1,
            hits: vec![hit],
            selected: 0,
        });
        app.active_pane = 0;

        // At 120 cols with Cozy: should render normally (Cozy effective)
        app.density_mode = DensityMode::Cozy;
        let text_wide = buffer_to_text(&render_at_degradation(
            &app,
            120,
            24,
            DegradationLevel::Full,
        ));

        // At 60 cols with Cozy: effective density is Compact (< 90 threshold)
        let text_narrow =
            buffer_to_text(&render_at_degradation(&app, 60, 24, DegradationLevel::Full));

        // Wide render (120 cols, Cozy effective) shows snippet in dedicated lines
        assert!(
            text_wide.contains("density-effective-test-sentinel"),
            "wide render should show snippet"
        );
        // Narrow render (60 cols, effective=Compact, row_height=2) omits snippet
        // lines — only title + metadata fit. Verify the agent name appears and
        // the sentinel does NOT appear (compact mode has 0 snippet_lines).
        assert!(
            text_narrow.contains("claude_code"),
            "narrow render should show agent name"
        );
        assert!(
            !text_narrow.contains("density-effective-test-sentinel"),
            "narrow render (effective=Compact) should omit snippet lines"
        );
    }

    // =====================================================================
    // 2dccg.9.5 — Results-surface regression suite
    // =====================================================================

    #[test]
    fn results_surface_density_theme_matrix_preserves_core_cues() {
        use crate::ui::style_system::UiThemePreset;
        use ftui::render::budget::DegradationLevel;
        use ftui_harness::buffer_to_text;

        for preset in [UiThemePreset::Dark, UiThemePreset::Light] {
            for density in [
                DensityMode::Compact,
                DensityMode::Cozy,
                DensityMode::Spacious,
            ] {
                let mut app = app_with_hits(6);
                app.density_mode = density;
                app.theme_preset = preset;
                app.theme_dark = !matches!(preset, UiThemePreset::Light);
                app.style_options.preset = preset;
                app.style_options.dark_mode = app.theme_dark;

                let text = buffer_to_text(&render_at_degradation(
                    &app,
                    140,
                    24,
                    DegradationLevel::Full,
                ));
                assert!(
                    text.contains("Results"),
                    "test_id=9.5.matrix.{:?}.{:?} component=results-pane expected=title actual=missing",
                    preset,
                    density
                );
                assert!(
                    text.contains("Hit 0"),
                    "test_id=9.5.matrix.{:?}.{:?} component=results-pane expected=first-row-title actual=missing",
                    preset,
                    density
                );
                assert!(
                    text.contains("[local]"),
                    "test_id=9.5.matrix.{:?}.{:?} component=source-badge expected=local-badge actual=missing",
                    preset,
                    density
                );
            }
        }
    }

    #[test]
    fn density_mode_switch_preserves_selection_and_scroll_state() {
        let mut app = app_with_hits(120);

        let _ = app.update(CassMsg::SelectionMoved { delta: 28 });
        let _ = app.update(CassMsg::PageScrolled { delta: 1 });

        let before_selected = app.panes[0].selected;
        let before_scroll = app.results_list_state.borrow().scroll_offset();

        let _ = app.update(CassMsg::DensityModeCycled);
        let _ = app.update(CassMsg::DensityModeCycled);
        let _ = app.update(CassMsg::DensityModeCycled);

        let after_selected = app.panes[0].selected;
        let after_scroll = app.results_list_state.borrow().scroll_offset();

        assert_eq!(
            after_selected, before_selected,
            "test_id=9.5.interaction.density_cycle component=selection expected=preserved actual_before={} actual_after={}",
            before_selected, after_selected
        );
        assert_eq!(
            after_scroll, before_scroll,
            "test_id=9.5.interaction.density_cycle component=scroll expected=preserved actual_before={} actual_after={}",
            before_scroll, after_scroll
        );
    }

    #[test]
    fn terminal_focus_changed_tracks_state() {
        let mut app = CassApp::default();
        assert!(app.terminal_focused, "should start focused");

        let _ = app.update(CassMsg::TerminalFocusChanged(false));
        assert!(!app.terminal_focused, "should be unfocused after FocusLost");

        let _ = app.update(CassMsg::TerminalFocusChanged(true));
        assert!(app.terminal_focused, "should be focused after FocusGained");
    }

    #[test]
    fn lerp_u8_blends_correctly() {
        assert_eq!(super::lerp_u8(0, 255, 0.0), 0);
        assert_eq!(super::lerp_u8(0, 255, 1.0), 255);
        assert_eq!(super::lerp_u8(0, 255, 0.5), 128);
        assert_eq!(super::lerp_u8(100, 200, 0.25), 125);
        // Clamp out-of-range t values
        assert_eq!(super::lerp_u8(0, 100, -1.0), 0);
        assert_eq!(super::lerp_u8(0, 100, 2.0), 100);
    }

    #[test]
    fn modal_open_spring_driven_by_tick() {
        let mut app = CassApp::default();
        // Spring starts at 0 (no modal open)
        assert!(
            app.anim.modal_open.position() < 0.1,
            "modal spring should start near 0"
        );

        // Open a modal flag, then tick to drive spring
        app.show_help = true;
        let _ = app.update(CassMsg::Tick);
        // After one tick, the spring target should be 1.0
        // (it may not have reached 1.0 yet, but target is set)
        assert!(
            app.anim.modal_open.position() > 0.0 || app.anim.modal_open.position() == 0.0, // first tick may not move it yet
            "modal spring should have been targeted"
        );

        // Close modal and tick
        app.show_help = false;
        for _ in 0..60 {
            let _ = app.update(CassMsg::Tick);
        }
        assert!(
            app.anim.modal_open.position() < 0.5,
            "modal spring should settle toward 0 after closing"
        );
    }

    #[test]
    fn detail_modal_participates_in_modal_open_spring() {
        let mut app = CassApp::default();
        app.panes.push(AgentPane {
            agent: "claude_code".into(),
            total_count: 1,
            hits: vec![make_test_hit()],
            selected: 0,
        });
        app.active_pane = 0;

        let _ = app.update(CassMsg::DetailOpened);
        assert!(
            app.show_detail_modal,
            "detail modal should open before driving spring"
        );

        for _ in 0..16 {
            app.last_tick = Instant::now() - Duration::from_millis(16);
            let _ = app.update(CassMsg::Tick);
        }
        let open_pos = app.anim.modal_open.position();
        assert!(
            open_pos > 0.05,
            "detail modal should drive modal spring open (pos={open_pos:.3})"
        );

        let _ = app.update(CassMsg::DetailClosed);
        assert!(!app.show_detail_modal);
        for _ in 0..24 {
            app.last_tick = Instant::now() - Duration::from_millis(16);
            let _ = app.update(CassMsg::Tick);
        }
        let closed_pos = app.anim.modal_open.position();
        assert!(
            closed_pos < open_pos,
            "closing detail modal should reduce modal spring position (open={open_pos:.3}, closed={closed_pos:.3})"
        );
    }

    #[test]
    fn search_focus_style_token_exists() {
        use super::style_system::{self, StyleContext, StyleOptions};
        let ctx = StyleContext::from_options(StyleOptions::default());
        let focus_style = ctx.style(style_system::STYLE_SEARCH_FOCUS);
        assert!(focus_style.bg.is_some(), "search focus should have a bg");
        assert!(focus_style.fg.is_some(), "search focus should have an fg");
    }

    #[test]
    fn modal_backdrop_style_token_exists() {
        use super::style_system::{self, StyleContext, StyleOptions};
        let ctx = StyleContext::from_options(StyleOptions::default());
        let backdrop = ctx.style(style_system::STYLE_MODAL_BACKDROP);
        assert!(backdrop.bg.is_some(), "modal backdrop should have a bg");
    }

    #[test]
    fn hover_result_tracks_mouse_move() {
        let mut app = CassApp::default();
        assert!(app.hovered_result.is_none(), "starts with no hover");

        // Simulate hover state changes directly (hit testing requires
        // rendered layout rects which aren't available in unit tests).
        app.hovered_result = Some(1);
        assert_eq!(app.hovered_result, Some(1));

        // Clear on move outside results
        app.hovered_result = None;
        assert!(app.hovered_result.is_none());
    }

    #[test]
    fn mouse_event_moved_variant_exists() {
        // Verify Moved variant is a valid MouseEventKind
        let kind = MouseEventKind::Moved;
        assert!(
            matches!(kind, MouseEventKind::Moved),
            "Moved variant should exist"
        );
    }

    #[test]
    fn density_cycle_sets_status_message() {
        let mut app = CassApp::default();
        assert_eq!(app.density_mode, DensityMode::Cozy);
        let _ = app.update(CassMsg::DensityModeCycled);
        assert_eq!(app.density_mode, DensityMode::Spacious);
        assert!(
            app.status.contains("Spacious"),
            "status should report new density mode, got: {}",
            app.status
        );
    }

    #[test]
    fn theme_toggle_sets_status_message() {
        let mut app = CassApp::default();
        assert!(app.theme_dark, "should start dark");
        let _ = app.update(CassMsg::ThemeToggled);
        assert!(!app.theme_dark, "should be light after toggle");
        assert!(
            app.status.contains("Light"),
            "status should report Light theme, got: {}",
            app.status
        );
    }

    #[test]
    fn snippet_budget_exhaustion_uses_ellipsis_on_last_line() {
        let mut hit = make_test_hit();
        hit.snippet = "abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ".to_string();
        let item = make_result_item(hit, DensityMode::Cozy.row_height());
        let lines = item.snippet_lines(16, 2);

        assert_eq!(
            lines.len(),
            2,
            "test_id=9.5.snippet.ellipsis expected=2-lines actual={}",
            lines.len()
        );
        assert!(
            lines[1].ends_with("..."),
            "test_id=9.5.snippet.ellipsis expected=trailing-ellipsis actual='{}'",
            lines[1]
        );
        assert!(
            lines[1].chars().count() <= 16,
            "test_id=9.5.snippet.ellipsis expected=max-width actual_len={}",
            lines[1].chars().count()
        );
    }

    #[test]
    fn results_navigation_page_scroll_and_home_end_are_stable() {
        use ftui::render::budget::DegradationLevel;

        let mut app = app_with_hits(120);
        // Virtualized page movement relies on a rendered viewport row count.
        render_at_degradation(&app, 140, 24, DegradationLevel::Full);
        let page_size = app.results_list_state.borrow().visible_count().max(1);
        assert_eq!(app.panes[0].selected, 0);

        let _ = app.update(CassMsg::PageScrolled { delta: 1 });
        let after_page_down = app.panes[0].selected;
        assert!(
            after_page_down >= page_size.min(app.panes[0].hits.len().saturating_sub(1)),
            "test_id=9.5.interaction.page component=selection expected=page-advance actual={after_page_down} page_size={page_size}"
        );

        let _ = app.update(CassMsg::PageScrolled { delta: -1 });
        let after_page_up = app.panes[0].selected;
        assert!(
            after_page_up <= after_page_down,
            "test_id=9.5.interaction.page component=selection expected=non-increase actual_down={} actual_up={}",
            after_page_down,
            after_page_up
        );

        let _ = app.update(CassMsg::SelectionJumped { to_end: true });
        assert_eq!(
            app.panes[0].selected,
            app.panes[0].hits.len().saturating_sub(1),
            "test_id=9.5.interaction.home-end component=end-jump expected=last-row"
        );

        let _ = app.update(CassMsg::SelectionJumped { to_end: false });
        assert_eq!(
            app.panes[0].selected, 0,
            "test_id=9.5.interaction.home-end component=home-jump expected=first-row"
        );
    }

    #[test]
    fn repeated_page_scroll_clamps_at_bounds() {
        use ftui::render::budget::DegradationLevel;

        let mut app = app_with_hits(120);
        render_at_degradation(&app, 140, 24, DegradationLevel::Full);

        let last = app.panes[0].hits.len().saturating_sub(1);
        for _ in 0..100 {
            let _ = app.update(CassMsg::PageScrolled { delta: 1 });
        }
        assert_eq!(
            app.panes[0].selected, last,
            "test_id=9.5.interaction.page-bounds component=selection expected=clamp-end"
        );

        for _ in 0..100 {
            let _ = app.update(CassMsg::PageScrolled { delta: -1 });
        }
        assert_eq!(
            app.panes[0].selected, 0,
            "test_id=9.5.interaction.page-bounds component=selection expected=clamp-start"
        );
    }

    #[test]
    fn detail_page_scroll_does_not_mutate_result_selection() {
        let mut app = app_with_hits(120);
        let _ = app.update(CassMsg::FocusToggled);
        assert_eq!(
            app.focused_region(),
            FocusRegion::Detail,
            "precondition: focus should be detail"
        );

        let selected_before = app.panes[0].selected;
        // Provide enough content lines so scroll is not clamped to 0
        app.detail_content_lines.set(200);
        app.detail_visible_height.set(20);
        app.detail_scroll = 10;
        let _ = app.update(CassMsg::PageScrolled { delta: 1 });
        assert_eq!(
            app.panes[0].selected, selected_before,
            "test_id=9.5.interaction.detail-page component=selection expected=unchanged"
        );
        assert_eq!(
            app.detail_scroll, 30,
            "test_id=9.5.interaction.detail-page component=detail-scroll expected=increment"
        );

        let _ = app.update(CassMsg::PageScrolled { delta: -1 });
        assert_eq!(
            app.panes[0].selected, selected_before,
            "test_id=9.5.interaction.detail-page component=selection expected=unchanged-after-pageup"
        );
        assert_eq!(
            app.detail_scroll, 10,
            "test_id=9.5.interaction.detail-page component=detail-scroll expected=decrement"
        );
    }

    #[test]
    fn results_focus_persists_through_theme_and_filter_changes() {
        let mut app = app_with_hits(10);
        let _ = app.update(CassMsg::FocusToggled);
        assert_eq!(
            app.focused_region(),
            FocusRegion::Detail,
            "precondition: focus should be detail"
        );

        let _ = app.update(CassMsg::ThemeToggled);
        let mut agents = std::collections::HashSet::new();
        agents.insert("codex".to_string());
        let _ = app.update(CassMsg::FilterAgentSet(agents));

        assert_eq!(
            app.focused_region(),
            FocusRegion::Detail,
            "test_id=9.5.interaction.focus component=theme+filter expected=detail-focus-preserved"
        );
    }

    // =====================================================================
    // 2dccg.9.5 — Results-surface regression suite (additional)
    // =====================================================================

    fn style_ctx_for_preset(
        preset: crate::ui::style_system::UiThemePreset,
    ) -> crate::ui::style_system::StyleContext {
        use crate::ui::style_system::{StyleContext, StyleOptions};
        use ftui::ColorProfile;
        StyleContext::from_options(StyleOptions {
            preset,
            dark_mode: !matches!(preset, crate::ui::style_system::UiThemePreset::Light),
            color_profile: ColorProfile::TrueColor,
            no_color: false,
            no_icons: false,
            no_gradient: false,
            a11y: false,
        })
    }

    #[test]
    fn score_style_routes_to_correct_tier() {
        use crate::ui::style_system::{
            STYLE_SCORE_HIGH, STYLE_SCORE_LOW, STYLE_SCORE_MID, UiThemePreset,
        };
        let ctx = style_ctx_for_preset(UiThemePreset::Dark);

        // score_style(score) routes based on thresholds: >=8.0 → HIGH, >=5.0 → MID, <5.0 → LOW
        let high = ctx.score_style(9.5);
        let mid = ctx.score_style(6.0);
        let low = ctx.score_style(3.0);

        assert_eq!(
            high,
            ctx.style(STYLE_SCORE_HIGH),
            "test_id=9.5.score.high expected=SCORE_HIGH"
        );
        assert_eq!(
            mid,
            ctx.style(STYLE_SCORE_MID),
            "test_id=9.5.score.mid expected=SCORE_MID"
        );
        assert_eq!(
            low,
            ctx.style(STYLE_SCORE_LOW),
            "test_id=9.5.score.low expected=SCORE_LOW"
        );

        // Boundary: exactly 8.0 → HIGH, exactly 5.0 → MID
        assert_eq!(ctx.score_style(8.0), ctx.style(STYLE_SCORE_HIGH));
        assert_eq!(ctx.score_style(5.0), ctx.style(STYLE_SCORE_MID));
        assert_eq!(ctx.score_style(4.99), ctx.style(STYLE_SCORE_LOW));

        // Fractional relevance scores (0.0..1.0) should map to the same visual tiers.
        assert_eq!(
            ctx.score_style(normalize_score_for_visuals(0.95)),
            ctx.style(STYLE_SCORE_HIGH),
            "fractional 0.95 should map to SCORE_HIGH"
        );
        assert_eq!(
            ctx.score_style(normalize_score_for_visuals(0.64)),
            ctx.style(STYLE_SCORE_MID),
            "fractional 0.64 should map to SCORE_MID"
        );
        assert_eq!(
            ctx.score_style(normalize_score_for_visuals(0.22)),
            ctx.style(STYLE_SCORE_LOW),
            "fractional 0.22 should map to SCORE_LOW"
        );
    }

    #[test]
    fn score_normalization_and_bar_labels_support_fractional_relevance() {
        assert!((normalize_score_for_visuals(0.95) - 9.5).abs() < 0.001);
        assert!((normalize_score_for_visuals(0.64) - 6.4).abs() < 0.001);
        assert!((normalize_score_for_visuals(0.22) - 2.2).abs() < 0.001);
        assert!((normalize_score_for_visuals(9.2) - 9.2).abs() < 0.001);

        let high = score_bar_str(0.95);
        let mid = score_bar_str(0.64);
        let low = score_bar_str(0.22);

        assert!(high.starts_with('H'), "expected HIGH-tier prefix in {high}");
        assert!(mid.starts_with('M'), "expected MID-tier prefix in {mid}");
        assert!(low.starts_with('L'), "expected LOW-tier prefix in {low}");

        assert!(
            high.contains("9.5"),
            "fractional 0.95 should render as 9.5/10 in score bar: {high}"
        );
        assert!(
            mid.contains("6.4"),
            "fractional 0.64 should render as 6.4/10 in score bar: {mid}"
        );
        assert!(
            low.contains("2.2"),
            "fractional 0.22 should render as 2.2/10 in score bar: {low}"
        );
    }

    #[test]
    fn results_metadata_includes_match_type_cue_for_scanning() {
        use ftui::render::budget::DegradationLevel;
        use ftui_harness::buffer_to_text;

        let mut app = app_with_hits(1);
        app.panes[0].hits[0].match_type = MatchType::ImplicitWildcard;
        app.panes[0].hits[0].score = 0.64;
        app.panes[0].hits[0].workspace = "/workspace/parity".to_string();
        app.active_pane = 0;
        app.density_mode = DensityMode::Cozy;

        let text = buffer_to_text(&render_at_degradation(
            &app,
            120,
            24,
            DegradationLevel::Full,
        ));
        assert!(
            text.contains("mt auto"),
            "results row metadata should include compact match-type cue"
        );
    }

    #[test]
    fn selected_row_has_distinct_style_from_default() {
        use crate::ui::style_system::{STYLE_RESULT_ROW_SELECTED, UiThemePreset};
        for preset in [UiThemePreset::Dark, UiThemePreset::Light] {
            let ctx = style_ctx_for_preset(preset);
            let selected = ctx.style(STYLE_RESULT_ROW_SELECTED);
            let default = ftui::Style::default();

            assert_ne!(
                selected.bg, default.bg,
                "test_id=9.5.focus.selection preset={:?} component=selected-vs-default expected=distinct-bg",
                preset
            );
        }
    }

    #[test]
    fn arrow_key_selection_moves_one_at_a_time() {
        let mut app = app_with_hits(10);
        assert_eq!(app.panes[0].selected, 0);

        let _ = app.update(CassMsg::SelectionMoved { delta: 1 });
        assert_eq!(
            app.panes[0].selected, 1,
            "test_id=9.5.navigation.arrow component=down expected=1"
        );

        let _ = app.update(CassMsg::SelectionMoved { delta: 1 });
        assert_eq!(
            app.panes[0].selected, 2,
            "test_id=9.5.navigation.arrow component=down expected=2"
        );

        let _ = app.update(CassMsg::SelectionMoved { delta: -1 });
        assert_eq!(
            app.panes[0].selected, 1,
            "test_id=9.5.navigation.arrow component=up expected=1"
        );

        // Up past 0 stays at 0
        let _ = app.update(CassMsg::SelectionMoved { delta: -1 });
        let _ = app.update(CassMsg::SelectionMoved { delta: -1 });
        assert_eq!(
            app.panes[0].selected, 0,
            "test_id=9.5.navigation.arrow component=clamp-top expected=0"
        );
    }

    #[test]
    fn results_suite_runs_under_3s_headless() {
        // Meta-test: verify the results-surface suite is fast enough for CI.
        // This test itself must complete instantly; the timing is implicit—
        // if the suite runs in < 3s total, this test is part of that budget.
        let start = std::time::Instant::now();
        let mut app = app_with_hits(50);
        for density in [
            DensityMode::Compact,
            DensityMode::Cozy,
            DensityMode::Spacious,
        ] {
            app.density_mode = density;
            let _buf =
                render_at_degradation(&app, 120, 24, ftui::render::budget::DegradationLevel::Full);
        }
        let elapsed = start.elapsed();
        assert!(
            elapsed.as_millis() < 1000,
            "test_id=9.5.meta.perf expected=<1s actual={:?}",
            elapsed
        );
    }

    // =====================================================================
    // 2noh9.3.3 — Filter UI tests
    // =====================================================================

    #[test]
    fn time_preset_cycles_all_today_week_month() {
        assert_eq!(TimePreset::All.next(), TimePreset::Today);
        assert_eq!(TimePreset::Today.next(), TimePreset::Week);
        assert_eq!(TimePreset::Week.next(), TimePreset::Month);
        assert_eq!(TimePreset::Month.next(), TimePreset::All);
        // Custom also goes back to All
        assert_eq!(TimePreset::Custom.next(), TimePreset::All);
    }

    #[test]
    fn time_preset_labels() {
        assert_eq!(TimePreset::All.label(), "All time");
        assert_eq!(TimePreset::Today.label(), "Today");
        assert_eq!(TimePreset::Week.label(), "Past 7d");
        assert_eq!(TimePreset::Month.label(), "Past 30d");
        assert_eq!(TimePreset::Custom.label(), "Custom");
    }

    #[test]
    fn time_preset_cycled_sets_filter_timestamps() {
        let mut app = CassApp::default();
        assert_eq!(app.time_preset, TimePreset::All);
        assert!(app.filters.created_from.is_none());

        // Cycle: All -> Today
        let _ = app.update(CassMsg::TimePresetCycled);
        assert_eq!(app.time_preset, TimePreset::Today);
        assert!(app.filters.created_from.is_some());
        assert!(app.filters.created_to.is_none());

        // Cycle: Today -> Week
        let _ = app.update(CassMsg::TimePresetCycled);
        assert_eq!(app.time_preset, TimePreset::Week);
        assert!(app.filters.created_from.is_some());

        // Cycle: Week -> Month
        let _ = app.update(CassMsg::TimePresetCycled);
        assert_eq!(app.time_preset, TimePreset::Month);
        assert!(app.filters.created_from.is_some());

        // Cycle: Month -> All (clears timestamps)
        let _ = app.update(CassMsg::TimePresetCycled);
        assert_eq!(app.time_preset, TimePreset::All);
        assert!(app.filters.created_from.is_none());
        assert!(app.filters.created_to.is_none());
    }

    #[test]
    fn source_filter_cycles_all_local_remote() {
        let mut app = CassApp::default();
        assert_eq!(app.filters.source_filter, SourceFilter::All);

        let _ = app.update(CassMsg::SourceFilterCycled);
        assert_eq!(app.filters.source_filter, SourceFilter::Local);

        let _ = app.update(CassMsg::SourceFilterCycled);
        assert_eq!(app.filters.source_filter, SourceFilter::Remote);

        let _ = app.update(CassMsg::SourceFilterCycled);
        assert_eq!(app.filters.source_filter, SourceFilter::All);
    }

    #[test]
    fn source_filter_source_id_resets_to_all() {
        let mut app = CassApp::default();
        app.filters.source_filter = SourceFilter::SourceId("myhost".to_string());
        let _ = app.update(CassMsg::SourceFilterCycled);
        assert_eq!(app.filters.source_filter, SourceFilter::All);
    }

    #[test]
    fn source_filter_menu_applies_selected_source_id() {
        let mut app = CassApp::default();
        let mut local = make_test_hit();
        local.source_id = "local".to_string();
        local.origin_kind = "local".to_string();
        local.origin_host = None;

        let mut remote = make_test_hit();
        remote.source_id = "work-laptop".to_string();
        remote.origin_kind = "ssh".to_string();
        remote.origin_host = Some("laptop".to_string());

        app.results = vec![local, remote];
        let _ = app.update(CassMsg::SourceFilterMenuToggled);
        assert!(app.source_filter_menu_open);
        assert_eq!(app.available_source_ids, vec!["work-laptop".to_string()]);

        app.source_filter_menu_selection = 3;
        let cmd = app.update(CassMsg::DetailOpened);
        for msg in extract_msgs(cmd) {
            let cmd2 = app.update(msg);
            for msg2 in extract_msgs(cmd2) {
                let _ = app.update(msg2);
            }
        }

        assert_eq!(
            app.filters.source_filter,
            SourceFilter::SourceId("work-laptop".to_string())
        );
        assert!(!app.source_filter_menu_open);
    }

    #[test]
    fn source_filter_menu_quit_requested_closes_and_releases_trap() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::SourceFilterMenuToggled);
        assert!(app.source_filter_menu_open);
        assert!(app.focus_manager.is_trapped());

        let _ = app.update(CassMsg::QuitRequested);
        assert!(!app.source_filter_menu_open);
        assert!(
            !app.focus_manager.is_trapped(),
            "closing source menu should release modal trap"
        );
    }

    #[test]
    fn input_mode_applied_agent_parses_csv() {
        let mut app = CassApp::default();
        app.input_mode = InputMode::Agent;
        app.input_buffer = "claude_code, aider, codex".to_string();
        let _ = app.update(CassMsg::InputModeApplied);

        // Should have reset mode and cleared buffer
        assert_eq!(app.input_mode, InputMode::Query);
        assert!(app.input_buffer.is_empty());
    }

    #[test]
    fn input_mode_applied_workspace_parses_csv() {
        let mut app = CassApp::default();
        app.input_mode = InputMode::Workspace;
        app.input_buffer = "project_a, project_b".to_string();
        let _ = app.update(CassMsg::InputModeApplied);

        assert_eq!(app.input_mode, InputMode::Query);
        assert!(app.input_buffer.is_empty());
    }

    #[test]
    fn input_mode_applied_created_from_invalid_date_shows_error() {
        let mut app = CassApp::default();
        app.input_mode = InputMode::CreatedFrom;
        app.input_buffer = "not-a-date".to_string();
        let _ = app.update(CassMsg::InputModeApplied);

        assert!(app.status.contains("Invalid date"));
        assert_eq!(app.input_mode, InputMode::Query);
        assert!(app.input_buffer.is_empty());
    }

    #[test]
    fn input_mode_applied_created_from_empty_clears_filter() {
        let mut app = CassApp::default();
        app.time_preset = TimePreset::Custom;
        app.input_mode = InputMode::CreatedFrom;
        app.input_buffer = "".to_string();
        let _ = app.update(CassMsg::InputModeApplied);

        assert_eq!(app.time_preset, TimePreset::All);
        assert_eq!(app.input_mode, InputMode::Query);
    }

    #[test]
    fn input_mode_applied_created_to_invalid_date_shows_error() {
        let mut app = CassApp::default();
        app.input_mode = InputMode::CreatedTo;
        app.input_buffer = "bogus".to_string();
        let _ = app.update(CassMsg::InputModeApplied);

        assert!(app.status.contains("Invalid date"));
        assert_eq!(app.input_mode, InputMode::Query);
    }

    #[test]
    fn filters_clear_all_resets_time_preset() {
        let mut app = CassApp::default();
        // Set up some filter state
        app.time_preset = TimePreset::Week;
        app.filters.created_from = Some(1000);
        app.filters.source_filter = SourceFilter::Local;

        let _ = app.update(CassMsg::FiltersClearAll);

        assert_eq!(app.time_preset, TimePreset::All);
        assert!(app.filters.created_from.is_none());
        assert_eq!(app.filters.source_filter, SourceFilter::All);
    }

    // =====================================================================
    // 2noh9.3.5 — Detail/preview view tests
    // =====================================================================

    #[test]
    fn detail_wrap_toggle_flips_state() {
        let mut app = CassApp::default();
        assert!(app.detail_wrap, "default should be true");
        let _ = app.update(CassMsg::DetailWrapToggled);
        assert!(!app.detail_wrap);
        let _ = app.update(CassMsg::DetailWrapToggled);
        assert!(app.detail_wrap);
    }

    #[test]
    fn detail_tab_changed_resets_scroll() {
        let mut app = CassApp::default();
        app.detail_scroll = 42;
        let _ = app.update(CassMsg::DetailTabChanged(DetailTab::Snippets));
        assert_eq!(app.detail_tab, DetailTab::Snippets);
        assert_eq!(app.detail_scroll, 0, "should reset scroll on tab change");

        app.detail_scroll = 10;
        let _ = app.update(CassMsg::DetailTabChanged(DetailTab::Raw));
        assert_eq!(app.detail_tab, DetailTab::Raw);
        assert_eq!(app.detail_scroll, 0);

        app.detail_scroll = 5;
        let _ = app.update(CassMsg::DetailTabChanged(DetailTab::Json));
        assert_eq!(app.detail_tab, DetailTab::Json);
        assert_eq!(app.detail_scroll, 0);
    }

    #[test]
    fn detail_find_toggle_creates_and_clears_state() {
        let mut app = CassApp::default();
        assert!(app.detail_find.is_none());
        let _ = app.update(CassMsg::DetailFindToggled);
        assert!(app.detail_find.is_some());
        let _ = app.update(CassMsg::DetailFindToggled);
        assert!(app.detail_find.is_none());
    }

    #[test]
    fn detail_find_query_changed_updates_state() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::DetailFindToggled);
        let _ = app.update(CassMsg::DetailFindQueryChanged("hello".to_string()));
        assert_eq!(app.detail_find.as_ref().unwrap().query, "hello");
    }

    #[test]
    fn detail_find_bar_line_formats_query_and_match_state() {
        let find = DetailFindState {
            query: "needle".to_string(),
            matches: vec![2, 4, 7],
            current: 1,
        };
        let line = build_detail_find_bar_line(
            &find,
            80,
            ftui::Style::default(),
            ftui::Style::default(),
            ftui::Style::default(),
        );
        let plain: String = line
            .spans()
            .iter()
            .map(|span| span.content.as_ref())
            .collect();
        assert!(
            plain.contains("/needle (2/3)"),
            "find bar should include query and match counter, got '{plain}'"
        );
        assert!(
            plain.contains("Enter next"),
            "find bar should include next-match hint when width permits, got '{plain}'"
        );
        assert!(
            plain.contains("Esc close"),
            "find bar should include close hint when width permits, got '{plain}'"
        );
    }

    #[test]
    fn detail_find_bar_line_uses_hint_for_empty_query() {
        let find = DetailFindState::default();
        let line = build_detail_find_bar_line(
            &find,
            24,
            ftui::Style::default(),
            ftui::Style::default(),
            ftui::Style::default(),
        );
        let plain: String = line
            .spans()
            .iter()
            .map(|span| span.content.as_ref())
            .collect();
        assert!(
            plain.contains("type to find"),
            "empty query should show find hint"
        );
    }

    #[test]
    fn detail_find_bar_line_truncates_long_query_but_keeps_match_context() {
        let find = DetailFindState {
            query: "this-is-a-very-long-query-string-that-must-be-truncated".to_string(),
            matches: vec![3, 8, 11],
            current: 0,
        };
        let line = build_detail_find_bar_line(
            &find,
            28,
            ftui::Style::default(),
            ftui::Style::default(),
            ftui::Style::default(),
        );
        let plain: String = line
            .spans()
            .iter()
            .map(|span| span.content.as_ref())
            .collect();
        assert!(
            plain.chars().count() <= 28,
            "find bar output must fit allotted width"
        );
        assert!(
            plain.contains("(1/3)"),
            "match context should remain visible after truncation"
        );
    }

    #[test]
    fn detail_find_bar_line_uses_compact_hints_when_full_phrase_does_not_fit() {
        let find = DetailFindState {
            query: "needle".to_string(),
            matches: vec![2, 4, 7],
            current: 1,
        };
        let line = build_detail_find_bar_line(
            &find,
            34,
            ftui::Style::default(),
            ftui::Style::default(),
            ftui::Style::default(),
        );
        let plain: String = line
            .spans()
            .iter()
            .map(|span| span.content.as_ref())
            .collect();
        assert!(
            plain.contains("/needle (2/3)"),
            "query and match counter should remain intact in compact mode"
        );
        assert!(
            plain.contains("Enter") && plain.contains("n/N") && plain.contains("Esc"),
            "compact hint set should retain key discoverability, got '{plain}'"
        );
        assert!(
            !plain.contains("Enter next"),
            "compact mode should drop verbose hint text when space is constrained"
        );
    }

    #[test]
    fn detail_find_bar_line_preserves_match_counter_when_hints_are_elided() {
        let find = DetailFindState {
            query: "needle".to_string(),
            matches: vec![2, 4, 7],
            current: 1,
        };
        let line = build_detail_find_bar_line(
            &find,
            18,
            ftui::Style::default(),
            ftui::Style::default(),
            ftui::Style::default(),
        );
        let plain: String = line
            .spans()
            .iter()
            .map(|span| span.content.as_ref())
            .collect();
        assert!(
            plain.contains("(2/3)"),
            "tight widths must preserve match state, got '{plain}'"
        );
        assert!(
            !plain.contains("Esc"),
            "hints should be elided before match context under tight width"
        );
    }

    #[test]
    fn detail_find_navigation_wraps() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::DetailFindToggled);
        if let Some(ref mut find) = app.detail_find {
            find.query = "test".to_string();
            find.matches = vec![5, 10, 20];
            find.current = 0;
        }
        // Navigate forward
        let _ = app.update(CassMsg::DetailFindNavigated { forward: true });
        assert_eq!(app.detail_find.as_ref().unwrap().current, 1);
        let _ = app.update(CassMsg::DetailFindNavigated { forward: true });
        assert_eq!(app.detail_find.as_ref().unwrap().current, 2);
        // Wrap around
        let _ = app.update(CassMsg::DetailFindNavigated { forward: true });
        assert_eq!(app.detail_find.as_ref().unwrap().current, 0);
        // Navigate backward from 0 wraps to end
        let _ = app.update(CassMsg::DetailFindNavigated { forward: false });
        assert_eq!(app.detail_find.as_ref().unwrap().current, 2);
    }

    #[test]
    fn detail_find_query_changed_resets_current_and_clears_matches() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::DetailFindToggled);
        // Simulate having matches from a previous query
        if let Some(ref mut find) = app.detail_find {
            find.matches = vec![5, 10, 20];
            find.current = 2;
        }
        let _ = app.update(CassMsg::DetailFindQueryChanged("new query".to_string()));
        let find = app.detail_find.as_ref().unwrap();
        assert_eq!(find.query, "new query");
        assert_eq!(find.current, 0, "current should reset on query change");
        assert!(find.matches.is_empty(), "stale matches should be cleared");
    }

    #[test]
    fn detail_find_navigation_auto_scrolls() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::DetailFindToggled);
        // Populate matches via the cache (simulating what the renderer does)
        *app.detail_find_matches_cache.borrow_mut() = vec![10, 30, 50];
        if let Some(ref mut find) = app.detail_find {
            find.query = "test".to_string();
        }
        // Navigate forward — should sync from cache and scroll
        let _ = app.update(CassMsg::DetailFindNavigated { forward: true });
        let find = app.detail_find.as_ref().unwrap();
        assert_eq!(find.matches, vec![10, 30, 50], "matches synced from cache");
        assert_eq!(find.current, 1); // advanced from 0 to 1
        assert_eq!(
            app.detail_scroll, 27,
            "should scroll to match line 30 minus 3"
        );
    }

    #[test]
    fn detail_find_bar_render_shows_query_and_match_state_in_detail_pane() {
        use ftui::render::budget::DegradationLevel;
        use ftui_harness::buffer_to_text;

        let mut app = app_with_hits(3);
        app.detail_find = Some(DetailFindState {
            query: "needle".to_string(),
            matches: vec![2, 6, 9],
            current: 1,
        });

        let text = buffer_to_text(&render_at_degradation(
            &app,
            120,
            24,
            DegradationLevel::Full,
        ));
        assert!(
            text.contains("/needle (2/3)"),
            "detail pane should render styled find bar query + match state"
        );
    }

    #[test]
    fn detail_find_bar_render_preserves_match_context_on_narrow_widths() {
        use ftui::render::budget::DegradationLevel;
        use ftui_harness::buffer_to_text;

        let mut app = app_with_hits(3);
        app.detail_find = Some(DetailFindState {
            query: "this-is-a-very-long-query-string-for-narrow-layout".to_string(),
            matches: vec![2, 6, 9],
            current: 0,
        });

        let text = buffer_to_text(&render_at_degradation(&app, 90, 24, DegradationLevel::Full));
        assert!(
            text.contains("(1/3)"),
            "narrow layouts should keep current/total match context visible"
        );
    }

    #[test]
    fn detail_find_bar_render_remains_readable_across_degradation_levels() {
        use ftui::render::budget::DegradationLevel;
        use ftui_harness::buffer_to_text;

        for level in [
            DegradationLevel::Full,
            DegradationLevel::SimpleBorders,
            DegradationLevel::NoStyling,
            DegradationLevel::EssentialOnly,
        ] {
            let mut app = app_with_hits(3);
            app.detail_find = Some(DetailFindState {
                query: "needle".to_string(),
                matches: vec![2, 6, 9],
                current: 1,
            });

            let text = buffer_to_text(&render_at_degradation(&app, 120, 24, level));
            assert!(
                text.contains("/needle"),
                "detail find query should remain visible at degradation {level:?}"
            );
            assert!(
                text.contains("(2/3)"),
                "detail find match state should remain visible at degradation {level:?}"
            );
        }
    }

    #[test]
    fn detail_modal_intercept_routes_slash_to_find() {
        let mut app = CassApp::default();
        app.show_detail_modal = true;
        // '/' in the event map becomes PaneFilterOpened
        let _ = app.update(CassMsg::PaneFilterOpened);
        assert!(
            app.detail_find.is_some(),
            "slash should toggle find in detail modal"
        );
    }

    #[test]
    fn detail_modal_intercept_routes_text_to_find_query() {
        let mut app = CassApp::default();
        app.show_detail_modal = true;
        let _ = app.update(CassMsg::DetailFindToggled);
        assert!(app.detail_find.is_some());
        // Type characters
        let _ = app.update(CassMsg::QueryChanged("h".to_string()));
        let _ = app.update(CassMsg::QueryChanged("i".to_string()));
        assert_eq!(app.detail_find.as_ref().unwrap().query, "hi");
        // Backspace
        let _ = app.update(CassMsg::QueryChanged(String::new()));
        assert_eq!(app.detail_find.as_ref().unwrap().query, "h");
    }

    #[test]
    fn detail_modal_intercept_esc_closes_modal_in_one_press() {
        let mut app = CassApp::default();
        app.show_detail_modal = true;
        let _ = app.update(CassMsg::DetailFindToggled);
        assert!(app.detail_find.is_some());
        // Esc closes the detail modal directly, even when find mode is active.
        let _ = app.update(CassMsg::QuitRequested);
        assert!(
            app.detail_find.is_none(),
            "detail find state should be cleared"
        );
        assert!(!app.show_detail_modal, "detail modal should close");
    }

    #[test]
    fn detail_modal_intercept_j_k_scroll() {
        let mut app = CassApp::default();
        app.show_detail_modal = true;
        app.detail_scroll = 0;
        // Provide enough content lines so scroll is not clamped to 0
        app.detail_content_lines.set(100);
        app.detail_visible_height.set(20);
        let _ = app.update(CassMsg::QueryChanged("j".to_string()));
        assert_eq!(app.detail_scroll, 3, "j should scroll down 3");
        let _ = app.update(CassMsg::QueryChanged("k".to_string()));
        assert_eq!(app.detail_scroll, 0, "k should scroll up 3");
    }

    #[test]
    fn detail_modal_intercept_tab_cycles_tabs() {
        let mut app = CassApp::default();
        app.show_detail_modal = true;
        assert_eq!(app.detail_tab, DetailTab::Messages);
        let _ = app.update(CassMsg::FocusToggled);
        assert_eq!(app.detail_tab, DetailTab::Snippets);
        let _ = app.update(CassMsg::FocusToggled);
        assert_eq!(app.detail_tab, DetailTab::Raw);
        let _ = app.update(CassMsg::FocusToggled);
        assert_eq!(app.detail_tab, DetailTab::Json);
        let _ = app.update(CassMsg::FocusToggled);
        assert_eq!(app.detail_tab, DetailTab::Analytics);
        let _ = app.update(CassMsg::FocusToggled);
        assert_eq!(app.detail_tab, DetailTab::Messages);
    }

    #[test]
    fn detail_modal_intercept_enter_navigates_find() {
        let mut app = CassApp::default();
        app.show_detail_modal = true;
        let _ = app.update(CassMsg::DetailFindToggled);
        // Pre-populate matches via cache
        *app.detail_find_matches_cache.borrow_mut() = vec![5, 15];
        if let Some(ref mut find) = app.detail_find {
            find.query = "test".to_string();
        }
        // Enter should navigate to next match
        let _ = app.update(CassMsg::QuerySubmitted);
        assert_eq!(app.detail_find.as_ref().unwrap().current, 1);
    }

    #[test]
    fn detail_modal_n_navigates_find_when_not_in_find_mode() {
        let mut app = CassApp::default();
        app.show_detail_modal = true;
        // Set up find state with matches but find bar closed
        app.detail_find = Some(DetailFindState {
            query: "test".to_string(),
            matches: vec![5, 15, 25],
            current: 0,
        });
        // Close find bar
        app.detail_find = None;
        // Re-open without query — press n should still navigate
        // (requires matches, which come from cache)
        *app.detail_find_matches_cache.borrow_mut() = vec![5, 15, 25];
        // Actually, n without active find just does nothing since
        // detail_find is None. This tests that n is consumed (no crash).
        let _ = app.update(CassMsg::QueryChanged("n".to_string()));
        // No crash — n was consumed by the detail modal intercept
    }

    #[test]
    fn detail_find_highlight_function_works() {
        let style_opts = crate::ui::style_system::StyleOptions::default();
        let styles = StyleContext::from_options(style_opts);

        let mut lines = vec![
            ftui::text::Line::raw("Hello world".to_string()),
            ftui::text::Line::raw("no match here".to_string()),
            ftui::text::Line::raw("HELLO again".to_string()),
        ];

        let matches = CassApp::apply_find_highlight(&mut lines, "hello", 0, &styles);
        // Should find "Hello" on line 0 and "HELLO" on line 2 (case-insensitive)
        assert_eq!(matches.len(), 2);
        assert_eq!(matches[0], 0);
        assert_eq!(matches[1], 2);
    }

    #[test]
    fn detail_find_highlight_empty_query_returns_no_matches() {
        let style_opts = crate::ui::style_system::StyleOptions::default();
        let styles = StyleContext::from_options(style_opts);

        let mut lines = vec![ftui::text::Line::raw("Hello".to_string())];
        let matches = CassApp::apply_find_highlight(&mut lines, "", 0, &styles);
        assert!(matches.is_empty());
    }

    // ── Detail find bar render/interaction tests (2dccg.4.3) ──────────

    /// Match-counter line structure is identical across all theme presets.
    #[test]
    fn detail_find_bar_match_counter_consistent_across_presets() {
        use crate::ui::style_system::UiThemePreset;

        let find = DetailFindState {
            query: "needle".to_string(),
            matches: vec![2, 4, 7],
            current: 1,
        };
        let mut structures = Vec::new();
        for preset in UiThemePreset::all() {
            let ctx = StyleContext::from_options(crate::ui::style_system::StyleOptions {
                preset,
                ..Default::default()
            });
            let line = build_detail_find_bar_line(
                &find,
                80,
                ctx.style(style_system::STYLE_DETAIL_FIND_QUERY),
                ctx.style(style_system::STYLE_DETAIL_FIND_MATCH_ACTIVE),
                ctx.style(style_system::STYLE_DETAIL_FIND_MATCH_INACTIVE),
            );
            let plain: String = line.spans().iter().map(|s| s.content.as_ref()).collect();
            structures.push((preset.name(), plain));
        }
        // All presets produce the same text structure
        let reference = &structures[0].1;
        for (name, text) in &structures[1..] {
            assert_eq!(
                text, reference,
                "match counter text should be identical between {} and {}",
                name, structures[0].0
            );
        }
    }

    /// Find bar line produces correct span count for different states.
    #[test]
    fn detail_find_bar_span_structure() {
        // With query and matches: expect "/" + query + " (" + current + "/" + total + ")"
        let find = DetailFindState {
            query: "test".to_string(),
            matches: vec![1, 3],
            current: 0,
        };
        let line = build_detail_find_bar_line(
            &find,
            80,
            ftui::Style::default(),
            ftui::Style::default(),
            ftui::Style::default(),
        );
        let span_count = line.spans().len();
        assert!(
            span_count >= 3,
            "find bar with matches should have at least 3 spans (/, query, match), got {span_count}"
        );

        // No matches: expect "/" + query + " (0/0 no matches)"
        let find_empty = DetailFindState {
            query: "test".to_string(),
            matches: vec![],
            current: 0,
        };
        let line_empty = build_detail_find_bar_line(
            &find_empty,
            80,
            ftui::Style::default(),
            ftui::Style::default(),
            ftui::Style::default(),
        );
        let plain: String = line_empty
            .spans()
            .iter()
            .map(|s| s.content.as_ref())
            .collect();
        assert!(plain.contains("0/0"), "no-match state should show 0/0");
    }

    /// Current match index updates correctly in the find bar line.
    #[test]
    fn detail_find_bar_current_match_index_updates() {
        for current in 0..3 {
            let find = DetailFindState {
                query: "q".to_string(),
                matches: vec![10, 20, 30],
                current,
            };
            let line = build_detail_find_bar_line(
                &find,
                80,
                ftui::Style::default(),
                ftui::Style::default(),
                ftui::Style::default(),
            );
            let plain: String = line.spans().iter().map(|s| s.content.as_ref()).collect();
            let expected = format!("({}/3)", current + 1);
            assert!(
                plain.contains(&expected),
                "current={current}: expected '{expected}' in '{plain}'"
            );
        }
    }

    /// Find bar at minimum width still produces output without panic.
    #[test]
    fn detail_find_bar_at_minimum_width() {
        let find = DetailFindState {
            query: "test".to_string(),
            matches: vec![1],
            current: 0,
        };
        for width in [1, 2, 3, 5, 10] {
            let line = build_detail_find_bar_line(
                &find,
                width,
                ftui::Style::default(),
                ftui::Style::default(),
                ftui::Style::default(),
            );
            let len: usize = line.spans().iter().map(|s| s.content.chars().count()).sum();
            assert!(
                len <= width as usize,
                "find bar at width={width} produced {len} chars, exceeds budget"
            );
        }
    }

    /// Find bar rendering in detail pane produces per-span styled output across presets.
    #[test]
    fn detail_find_bar_render_uses_styled_spans_across_presets() {
        use crate::ui::style_system::UiThemePreset;

        let find = DetailFindState {
            query: "needle".to_string(),
            matches: vec![2, 4, 7],
            current: 1,
        };

        for preset in UiThemePreset::all() {
            let ctx = StyleContext::from_options(crate::ui::style_system::StyleOptions {
                preset,
                ..Default::default()
            });
            let query_style = ctx.style(style_system::STYLE_DETAIL_FIND_QUERY);
            let match_active_style = ctx.style(style_system::STYLE_DETAIL_FIND_MATCH_ACTIVE);
            let line = build_detail_find_bar_line(
                &find,
                80,
                query_style,
                match_active_style,
                ctx.style(style_system::STYLE_DETAIL_FIND_MATCH_INACTIVE),
            );

            // Find the span containing the query text
            let query_span = line.spans().iter().find(|s| s.content.contains("needle"));
            assert!(
                query_span.is_some(),
                "preset {}: should have a span containing 'needle'",
                preset.name()
            );
            // Verify it has the query style (fg should match)
            if let Some(span) = query_span {
                assert_eq!(
                    span.style.as_ref().map(|style| style.fg),
                    Some(query_style.fg),
                    "preset {}: query span fg should use STYLE_DETAIL_FIND_QUERY",
                    preset.name()
                );
            }
        }
    }

    #[test]
    fn detail_scrolled_clamps_to_zero() {
        let mut app = CassApp::default();
        app.detail_scroll = 5;
        let _ = app.update(CassMsg::DetailScrolled { delta: -10 });
        assert_eq!(app.detail_scroll, 0, "should clamp at zero");
    }

    #[test]
    fn detail_scrolled_increments() {
        let mut app = CassApp::default();
        // Provide enough content lines so scroll is not clamped to 0
        app.detail_content_lines.set(100);
        app.detail_visible_height.set(20);
        let _ = app.update(CassMsg::DetailScrolled { delta: 3 });
        assert_eq!(app.detail_scroll, 3);
        let _ = app.update(CassMsg::DetailScrolled { delta: 5 });
        assert_eq!(app.detail_scroll, 8);
    }

    #[test]
    fn autocomplete_csv_suffix_single_token() {
        let candidates: BTreeSet<String> = ["claude_code", "cursor", "codex"]
            .iter()
            .map(|s| s.to_string())
            .collect();
        assert_eq!(
            autocomplete_csv_suffix("cl", &candidates),
            Some("claude_code".to_string()),
        );
        assert_eq!(
            autocomplete_csv_suffix("cu", &candidates),
            Some("cursor".to_string()),
        );
        assert_eq!(
            autocomplete_csv_suffix("co", &candidates),
            Some("codex".to_string()),
        );
    }

    #[test]
    fn autocomplete_csv_suffix_after_comma() {
        let candidates: BTreeSet<String> = ["aider", "claude_code", "cursor"]
            .iter()
            .map(|s| s.to_string())
            .collect();
        assert_eq!(
            autocomplete_csv_suffix("aider, cl", &candidates),
            Some("aider, claude_code".to_string()),
        );
    }

    #[test]
    fn autocomplete_csv_suffix_exact_match_returns_none() {
        let candidates: BTreeSet<String> = ["cursor"].iter().map(|s| s.to_string()).collect();
        assert_eq!(autocomplete_csv_suffix("cursor", &candidates), None);
    }

    #[test]
    fn autocomplete_csv_suffix_case_insensitive() {
        let candidates: BTreeSet<String> = ["claude_code"].iter().map(|s| s.to_string()).collect();
        assert_eq!(
            autocomplete_csv_suffix("CL", &candidates),
            Some("claude_code".to_string()),
        );
    }

    #[test]
    fn autocomplete_csv_suffix_no_match() {
        let candidates: BTreeSet<String> = ["cursor"].iter().map(|s| s.to_string()).collect();
        assert_eq!(autocomplete_csv_suffix("zz", &candidates), None);
    }

    #[test]
    fn autocomplete_csv_suffix_empty_input() {
        let candidates: BTreeSet<String> = ["cursor"].iter().map(|s| s.to_string()).collect();
        assert_eq!(autocomplete_csv_suffix("", &candidates), None);
        assert_eq!(autocomplete_csv_suffix("  ", &candidates), None);
    }

    #[test]
    fn input_autocomplete_candidates_agent_mode_includes_hints() {
        let mut app = CassApp::default();
        app.input_mode = InputMode::Agent;
        let candidates = app.input_autocomplete_candidates();
        assert!(candidates.contains("claude_code"));
        assert!(candidates.contains("cursor"));
        assert!(candidates.contains("aider"));
    }

    #[test]
    fn input_autocomplete_candidates_agent_mode_merges_filters() {
        let mut app = CassApp::default();
        app.input_mode = InputMode::Agent;
        app.filters.agents.insert("custom_agent".to_string());
        let candidates = app.input_autocomplete_candidates();
        assert!(
            candidates.contains("custom_agent"),
            "should include agents from filters"
        );
        assert!(
            candidates.contains("claude_code"),
            "should still include baseline hints"
        );
    }

    #[test]
    fn input_autocomplete_candidates_workspace_mode() {
        let mut app = CassApp::default();
        app.input_mode = InputMode::Workspace;
        app.filters
            .workspaces
            .insert("/home/user/project".to_string());
        let candidates = app.input_autocomplete_candidates();
        assert!(candidates.contains("/home/user/project"));
        // Should NOT contain agent hints
        assert!(!candidates.contains("claude_code"));
    }

    #[test]
    fn input_autocomplete_candidates_query_mode_empty() {
        let mut app = CassApp::default();
        app.input_mode = InputMode::Query;
        let candidates = app.input_autocomplete_candidates();
        assert!(candidates.is_empty(), "query mode has no autocomplete");
    }

    #[test]
    fn autocomplete_input_buffer_integration() {
        let mut app = CassApp::default();
        app.input_mode = InputMode::Agent;
        app.input_buffer = "cl".to_string();
        let result = app.autocomplete_input_buffer();
        assert_eq!(result, Some("claude_code".to_string()));
    }

    fn make_test_hit() -> SearchHit {
        SearchHit {
            title: "Test Conversation".into(),
            snippet: "Hello **world**\nThis is a test".into(),
            content: "# Heading\n\nSome **bold** text\n\n```rust\nfn main() {}\n```".into(),
            content_hash: 42,
            score: 0.95,
            agent: "claude_code".into(),
            source_path: "/test/session.jsonl".into(),
            workspace: "/projects/test".into(),
            workspace_original: None,
            created_at: Some(1700000000),
            line_number: None,
            match_type: Default::default(),
            source_id: "local".into(),
            origin_kind: "local".into(),
            origin_host: None,
        }
    }

    fn make_result_item(hit: SearchHit, row_height: u16) -> ResultItem {
        ResultItem {
            index: 1,
            hit,
            row_height,
            even: true,
            max_width: 120,
            queued: false,
            stripe_style: ftui::Style::default(),
            selected_style: ftui::Style::default(),
            agent_accent_style: ftui::Style::default(),
            score_style: ftui::Style::default(),
            text_primary_style: ftui::Style::default(),
            text_muted_style: ftui::Style::default(),
            text_subtle_style: ftui::Style::default(),
            success_style: ftui::Style::default(),
            source_local_style: ftui::Style::default(),
            source_remote_style: ftui::Style::default(),
            location_style: ftui::Style::default(),
            mini_analytics: None,
            reveal_progress: 1.0,
            focus_flash_intensity: 0.0,
            query_terms: vec![],
            query_highlight_style: ftui::Style::new(),
            hovered: false,
        }
    }

    fn make_test_conversation_view() -> ConversationView {
        use std::path::PathBuf;

        ConversationView {
            convo: crate::model::types::Conversation {
                id: Some(1),
                agent_slug: "claude_code".to_string(),
                workspace: Some(PathBuf::from("/projects/test")),
                external_id: Some("conv-1".to_string()),
                title: Some("Cached Conversation".to_string()),
                source_path: PathBuf::from("/test/session.jsonl"),
                started_at: Some(1_700_000_000),
                ended_at: Some(1_700_000_120),
                approx_tokens: Some(1024),
                metadata_json: serde_json::json!({}),
                messages: Vec::new(),
                source_id: "local".to_string(),
                origin_host: None,
            },
            messages: Vec::new(),
            workspace: None,
        }
    }

    fn markdown_span_fg_for_text(
        lines: &[ftui::text::Line],
        needle: &str,
    ) -> Option<ftui::render::cell::PackedRgba> {
        for line in lines {
            for span in line.spans() {
                if span.content.as_ref().contains(needle) {
                    return span.style.as_ref().and_then(|style| style.fg);
                }
            }
        }
        None
    }

    #[test]
    fn build_messages_lines_produces_output() {
        let app = CassApp::default();
        let hit = make_test_hit();
        let styles = StyleContext::from_options(StyleOptions::default());
        let lines = app.build_messages_lines(&hit, 80, &styles);
        assert!(
            !lines.is_empty(),
            "should produce at least header + content"
        );
        // Should have at least 3 lines: title, metadata, separator
        assert!(lines.len() >= 3);
    }

    #[test]
    fn build_messages_lines_include_source_provenance_fields() {
        let app = CassApp::default();
        let mut hit = make_test_hit();
        hit.source_id = "work-laptop".to_string();
        hit.origin_kind = "ssh".to_string();
        hit.origin_host = Some("laptop".to_string());
        hit.workspace_original = Some("/home/user/projects/test".to_string());
        let styles = StyleContext::from_options(StyleOptions::default());
        let lines = app.build_messages_lines(&hit, 80, &styles);
        let text: String = lines
            .iter()
            .map(|l| {
                l.spans()
                    .iter()
                    .map(|s| s.content.as_ref())
                    .collect::<String>()
            })
            .collect::<Vec<_>>()
            .join("\n");
        assert!(text.contains("source=laptop"));
        assert!(
            text.contains("(remote)"),
            "source kind should appear parenthesized: {text}"
        );
        assert!(text.contains("ws_orig=/home/user/projects/test"));
    }

    #[test]
    fn build_snippets_lines_produces_output() {
        let app = CassApp::default();
        let hit = make_test_hit();
        let styles = StyleContext::from_options(StyleOptions::default());
        let lines = app.build_snippets_lines(&hit, &styles);
        assert!(!lines.is_empty(), "should produce snippet lines");
    }

    #[test]
    fn build_raw_lines_produces_json() {
        let app = CassApp::default();
        let hit = make_test_hit();
        let styles = StyleContext::from_options(StyleOptions::default());
        let lines = app.build_raw_lines(&hit, &styles);
        // Raw tab should contain JSON-like content
        let text: String = lines
            .iter()
            .map(|l| {
                l.spans()
                    .iter()
                    .map(|s| s.content.as_ref())
                    .collect::<String>()
            })
            .collect::<Vec<_>>()
            .join("\n");
        assert!(text.contains("claude_code"), "should show agent in JSON");
        assert!(text.contains("score"), "should include score key in JSON");
        assert!(
            text.contains("source_kind"),
            "should include source_kind key"
        );
        assert!(
            text.contains("workspace_original"),
            "should include workspace_original key"
        );
    }

    #[test]
    fn apply_find_highlight_marks_matches() {
        let styles = StyleContext::from_options(StyleOptions::default());
        let mut lines = vec![
            ftui::text::Line::from("Hello world"),
            ftui::text::Line::from("World is great"),
            ftui::text::Line::from("No match here"),
        ];
        let matches = CassApp::apply_find_highlight(&mut lines, "world", 0, &styles);
        assert_eq!(matches.len(), 2, "should find 'world' in 2 lines");
    }

    #[test]
    fn detail_opened_in_non_query_mode_applies_input() {
        // In PaneFilter mode, Enter (DetailOpened) applies the filter and
        // returns to Query mode when the search bar owns input focus.
        let mut app = CassApp::default();
        app.input_mode = InputMode::PaneFilter;
        app.focus_manager.focus(focus_ids::SEARCH_BAR);
        app.input_buffer = "err".to_string();
        let _ = app.update(CassMsg::DetailOpened);
        assert_eq!(
            app.input_mode,
            InputMode::Query,
            "should return to Query mode"
        );
        assert!(
            !app.show_detail_modal,
            "should not open modal in PaneFilter mode"
        );

        // In Agent mode, Enter applies the agent filter (via chained Cmds).
        let mut app2 = CassApp::default();
        app2.input_mode = InputMode::Agent;
        app2.focus_manager.focus(focus_ids::SEARCH_BAR);
        app2.input_buffer = "claude_code".to_string();
        let cmd = app2.update(CassMsg::DetailOpened);
        // InputModeApplied returns a Cmd::Msg(FilterAgentSet) that must be processed.
        for msg in extract_msgs(cmd) {
            let cmd2 = app2.update(msg);
            for msg2 in extract_msgs(cmd2) {
                let _ = app2.update(msg2);
            }
        }
        assert_eq!(
            app2.input_mode,
            InputMode::Query,
            "Agent mode should return to Query"
        );
        assert!(
            app2.filters.agents.contains("claude_code"),
            "agent filter should be applied"
        );
    }

    #[test]
    fn detail_opened_cache_miss_sets_loading_and_dispatches_detail_load() {
        let mut app = CassApp::default();
        app.panes.push(AgentPane {
            agent: "claude_code".into(),
            total_count: 1,
            hits: vec![make_test_hit()],
            selected: 0,
        });
        app.active_pane = 0;
        let expected_path = app.panes[0].hits[0].source_path.clone();

        let cmd = app.update(CassMsg::DetailOpened);
        let msg = extract_msg(cmd);
        assert!(
            matches!(
                msg,
                Some(CassMsg::DetailLoadRequested { source_path }) if source_path == expected_path
            ),
            "detail open on cache miss should dispatch detail load request"
        );
        assert_eq!(app.loading_context, Some(LoadingContext::DetailModal));

        let _ = app.update(CassMsg::DetailLoadRequested {
            source_path: expected_path,
        });
        assert!(app.loading_context.is_none());
    }

    #[test]
    fn detail_closed_resets_focus() {
        let mut app = CassApp::default();
        app.show_detail_modal = true;
        app.focus_manager.focus(focus_ids::DETAIL_PANE);
        let _ = app.update(CassMsg::DetailClosed);
        assert!(!app.show_detail_modal);
        assert_eq!(app.focused_region(), FocusRegion::Results);
    }

    #[test]
    fn detail_modal_allows_copy_shortcuts_to_reach_action_handlers() {
        let mut app = app_with_hits(1);
        app.show_detail_modal = true;

        let _ = app.update(CassMsg::CopyPath);
        assert!(
            app.status.contains("Copied path"),
            "detail modal should not swallow copy-path action"
        );

        let _ = app.update(CassMsg::CopySnippet);
        assert!(
            app.status.contains("Copied snippet"),
            "detail modal should not swallow copy-snippet action"
        );
    }

    // =====================================================================
    // 2noh9.4.16 — JSON viewer tests
    // =====================================================================

    #[test]
    fn toggle_json_view_no_hit_sets_status() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::ToggleJsonView);
        assert!(
            app.status.contains("No active result"),
            "should show error when no hit selected"
        );
        assert_ne!(app.detail_tab, DetailTab::Json);
    }

    #[test]
    fn toggle_json_view_switches_to_json_tab() {
        let mut app = CassApp::default();
        app.panes.push(AgentPane {
            agent: "claude_code".into(),
            total_count: 1,
            hits: vec![make_test_hit()],
            selected: 0,
        });
        app.active_pane = 0;
        let _ = app.update(CassMsg::ToggleJsonView);
        assert_eq!(app.detail_tab, DetailTab::Json);
        assert!(app.show_detail_modal, "should open detail modal");
        assert_eq!(app.detail_scroll, 0, "should reset scroll");
    }

    #[test]
    fn toggle_json_view_toggles_back_to_raw() {
        let mut app = CassApp::default();
        app.panes.push(AgentPane {
            agent: "claude_code".into(),
            total_count: 1,
            hits: vec![make_test_hit()],
            selected: 0,
        });
        app.active_pane = 0;
        // First toggle: to Json
        let _ = app.update(CassMsg::ToggleJsonView);
        assert_eq!(app.detail_tab, DetailTab::Json);
        // Second toggle: back to Raw
        let _ = app.update(CassMsg::ToggleJsonView);
        assert_eq!(app.detail_tab, DetailTab::Raw);
    }

    #[test]
    fn enter_does_not_override_explicit_json_tab_when_modal_open() {
        let mut app = CassApp::default();
        app.panes.push(AgentPane {
            agent: "claude_code".into(),
            total_count: 1,
            hits: vec![make_test_hit()],
            selected: 0,
        });
        app.active_pane = 0;

        // Explicit Json pathway.
        let _ = app.update(CassMsg::ToggleJsonView);
        assert_eq!(app.detail_tab, DetailTab::Json);
        assert!(app.show_detail_modal);

        // Enter while modal is open should not force Messages tab.
        let _ = app.update(CassMsg::DetailOpened);
        assert_eq!(
            app.detail_tab,
            DetailTab::Json,
            "Enter should preserve explicit Json tab while modal is already open"
        );
    }

    #[test]
    fn enter_does_not_override_explicit_raw_tab_when_modal_open() {
        let mut app = CassApp::default();
        app.panes.push(AgentPane {
            agent: "claude_code".into(),
            total_count: 1,
            hits: vec![make_test_hit()],
            selected: 0,
        });
        app.active_pane = 0;

        // Open modal through explicit Json pathway, then explicitly switch to Raw.
        let _ = app.update(CassMsg::ToggleJsonView);
        assert_eq!(app.detail_tab, DetailTab::Json);
        let _ = app.update(CassMsg::DetailTabChanged(DetailTab::Raw));
        assert_eq!(app.detail_tab, DetailTab::Raw);

        // Enter while modal is open should keep explicit Raw selection.
        let _ = app.update(CassMsg::DetailOpened);
        assert_eq!(
            app.detail_tab,
            DetailTab::Raw,
            "Enter should preserve explicit Raw tab while modal is already open"
        );
    }

    #[test]
    fn build_json_lines_produces_syntax_colored_output() {
        let app = CassApp::default();
        let hit = make_test_hit();
        let styles = StyleContext::from_options(StyleOptions::default());
        let lines = app.build_json_lines(&hit, &styles);
        assert!(!lines.is_empty(), "should produce output");
        // Should contain JSON Viewer header + JSON content
        let text: String = lines
            .iter()
            .map(|l| {
                l.spans()
                    .iter()
                    .map(|s| s.content.as_ref())
                    .collect::<String>()
            })
            .collect::<Vec<_>>()
            .join("\n");
        assert!(text.contains("JSON Viewer"), "should have header");
        assert!(text.contains("claude_code"), "should contain agent name");
        assert!(text.contains("title"), "should contain JSON keys");
    }

    #[test]
    fn detail_tab_json_variant_has_correct_default() {
        // Json is not the default tab
        assert_ne!(DetailTab::default(), DetailTab::Json);
        assert_eq!(DetailTab::default(), DetailTab::Messages);
    }

    #[test]
    fn detail_tab_changed_to_json_resets_scroll() {
        let mut app = CassApp::default();
        app.detail_scroll = 99;
        let _ = app.update(CassMsg::DetailTabChanged(DetailTab::Json));
        assert_eq!(app.detail_tab, DetailTab::Json);
        assert_eq!(app.detail_scroll, 0);
    }

    #[test]
    fn detail_messages_with_markdown_content_renders() {
        let mut app = CassApp::default();
        let hit = make_test_hit();
        // Set cached_detail to None — should fall back to hit content
        app.cached_detail = None;
        let styles = StyleContext::from_options(StyleOptions::default());
        let lines = app.build_messages_lines(&hit, 80, &styles);
        // The content has "# Heading" which is markdown — should render it
        assert!(lines.len() > 5, "markdown should produce multiple lines");
    }

    #[test]
    fn detail_markdown_fallback_uses_active_theme_mapping() {
        use crate::ui::style_system::UiThemePreset;

        let mut app = CassApp::default();
        app.cached_detail = None;
        let mut hit = make_test_hit();
        hit.content = "# Themed Heading\n\nSome **bold** text".to_string();
        let presets = [
            (UiThemePreset::Dark, true),
            (UiThemePreset::Light, false),
            (UiThemePreset::HighContrast, true),
            (UiThemePreset::Catppuccin, true),
        ];
        for (preset, dark_mode) in presets {
            let styles = StyleContext::from_options(StyleOptions {
                preset,
                dark_mode,
                ..StyleOptions::default()
            });
            let lines = app.build_messages_lines(&hit, 80, &styles);
            let heading_fg = markdown_span_fg_for_text(&lines, "Themed Heading")
                .expect("fallback heading should render for preset");
            assert_eq!(
                Some(heading_fg),
                styles.markdown_theme().h1.fg,
                "fallback markdown heading should use active markdown theme h1 for preset {:?}",
                preset
            );
        }
    }

    #[test]
    fn detail_markdown_cached_messages_follow_theme_toggle() {
        let mut app = CassApp::default();
        let mut cv = make_test_conversation_view();
        cv.messages = vec![Message {
            id: Some(1),
            idx: 0,
            role: MessageRole::Agent,
            author: Some("cass".to_string()),
            created_at: Some(1_700_000_000),
            content: "# Cached Theme Heading\n\nSome **bold** markdown.".to_string(),
            extra_json: serde_json::json!({}),
            snippets: vec![],
        }];
        app.cached_detail = Some(("/test/session.jsonl".to_string(), cv));

        let hit = make_test_hit();
        let dark_styles = app.resolved_style_context();
        let dark_lines = app.build_messages_lines(&hit, 80, &dark_styles);
        let dark_fg = markdown_span_fg_for_text(&dark_lines, "Cached Theme Heading")
            .expect("cached markdown heading should be rendered before theme toggle");
        assert_eq!(
            Some(dark_fg),
            dark_styles.markdown_theme().h1.fg,
            "cached markdown heading should use current preset markdown theme before toggle"
        );

        let _ = app.update(CassMsg::ThemeToggled);
        let toggled_styles = app.resolved_style_context();
        let toggled_lines = app.build_messages_lines(&hit, 80, &toggled_styles);
        let toggled_fg = markdown_span_fg_for_text(&toggled_lines, "Cached Theme Heading")
            .expect("cached markdown heading should be rendered after theme toggle");
        assert_eq!(
            Some(toggled_fg),
            toggled_styles.markdown_theme().h1.fg,
            "cached markdown heading should use current preset markdown theme after toggle"
        );

        assert_ne!(
            dark_fg, toggled_fg,
            "theme toggle should immediately change cached markdown heading color"
        );
    }

    #[test]
    fn detail_messages_tab_renders_mixed_markdown_and_plain_stream() {
        let mut app = CassApp::default();
        let mut cv = make_test_conversation_view();
        cv.messages = vec![
            Message {
                id: Some(1),
                idx: 0,
                role: MessageRole::Agent,
                author: Some("cass".to_string()),
                created_at: Some(1_700_000_100),
                content: [
                    "# Feature Overview",
                    "",
                    "- list item alpha",
                    "- list item beta",
                    "",
                    "```rust",
                    "fn markdown_contract() -> bool { true }",
                    "```",
                    "",
                    "[Reference Link](https://example.com/docs)",
                ]
                .join("\n"),
                extra_json: serde_json::json!({}),
                snippets: vec![],
            },
            Message {
                id: Some(2),
                idx: 1,
                role: MessageRole::User,
                author: Some("user".to_string()),
                created_at: Some(1_700_000_200),
                content: "Plain text follow-up without markdown markers.".to_string(),
                extra_json: serde_json::json!({}),
                snippets: vec![],
            },
        ];
        app.cached_detail = Some(("/test/session.jsonl".to_string(), cv));

        let hit = make_test_hit();
        let styles = app.resolved_style_context();
        let lines = app.build_messages_lines(&hit, 100, &styles);
        let rendered = lines
            .iter()
            .map(|line| {
                line.spans()
                    .iter()
                    .map(|span| span.content.as_ref())
                    .collect::<String>()
            })
            .collect::<Vec<_>>()
            .join("\n");

        assert!(
            rendered.contains("Feature Overview"),
            "expected heading content in rendered messages tab"
        );
        assert!(
            rendered.contains("list item alpha"),
            "expected markdown list content in rendered messages tab"
        );
        assert!(
            rendered.contains("markdown_contract"),
            "expected fenced code block content in rendered messages tab"
        );
        assert!(
            rendered.contains("Reference Link"),
            "expected markdown link label in rendered messages tab"
        );
        assert!(
            rendered.contains("Plain text follow-up without markdown markers."),
            "expected plain-text message content alongside markdown content"
        );
    }

    #[test]
    fn detail_markdown_renderer_setup_cost_stays_below_render_work() {
        use std::hint::black_box;
        use std::time::Instant;

        use crate::ui::style_system::UiThemePreset;

        let markdown_doc = [
            "# Heading",
            "",
            "Theme-coherent markdown should stay readable after toggles.",
            "",
            "```rust",
            "fn parse_markdown_theme(input: &str) -> Option<String> {",
            "    Some(input.trim().to_string())",
            "}",
            "```",
            "",
            "- bullet one",
            "- bullet two",
            "- bullet three",
            "",
            "> blockquote",
        ]
        .join("\n")
        .repeat(24);

        for (preset, dark_mode) in [
            (UiThemePreset::Dark, true),
            (UiThemePreset::Light, false),
            (UiThemePreset::HighContrast, true),
            (UiThemePreset::Catppuccin, true),
        ] {
            let styles = StyleContext::from_options(StyleOptions {
                preset,
                dark_mode,
                ..StyleOptions::default()
            });

            let setup_iterations = 300u32;
            let setup_start = Instant::now();
            for _ in 0..setup_iterations {
                black_box(MarkdownRenderer::new(styles.markdown_theme()));
            }
            let setup_elapsed = setup_start.elapsed();

            let render_iterations = 120u32;
            let renderer = MarkdownRenderer::new(styles.markdown_theme());
            let render_start = Instant::now();
            for _ in 0..render_iterations {
                black_box(renderer.render(&markdown_doc));
            }
            let render_elapsed = render_start.elapsed();

            let setup_us = setup_elapsed.as_secs_f64() * 1_000_000.0 / setup_iterations as f64;
            let render_us = render_elapsed.as_secs_f64() * 1_000_000.0 / render_iterations as f64;

            assert!(
                setup_us <= render_us * 2.0,
                "markdown setup unexpectedly expensive for {:?}: setup={setup_us:.2}us render={render_us:.2}us",
                preset
            );
        }
    }

    // ==================== Analytics surface tests ====================

    #[test]
    fn analytics_entered_switches_surface() {
        use ftui::render::budget::DegradationLevel;

        let mut app = CassApp::default();
        assert_eq!(app.surface, AppSurface::Search);
        assert!(app.view_stack.is_empty());
        let _ = render_at_degradation(&app, 120, 24, DegradationLevel::Full);

        let _ = app.update(CassMsg::AnalyticsEntered);
        assert_eq!(app.surface, AppSurface::Analytics);
        assert_eq!(app.view_stack, vec![AppSurface::Search]);
        let transition = app
            .view_transition
            .as_ref()
            .expect("surface switch should start transition");
        assert_eq!(transition.from_label, "Search");
        assert_eq!(transition.to_label, "Analytics");
        assert_eq!(transition.duration, SURFACE_TRANSITION_DURATION);
        assert!(
            transition.from_snapshot.is_some(),
            "surface transition should capture previous surface snapshot"
        );
    }

    #[test]
    #[allow(clippy::arc_with_non_send_sync)]
    fn analytics_reload_scheduling_requires_db_and_manages_loading_context() {
        let mut app = CassApp::default();
        app.loading_context = Some(LoadingContext::Analytics);
        let cmd = app.schedule_analytics_reload();
        assert!(
            matches!(cmd, ftui::Cmd::None),
            "without db reader analytics reload should no-op"
        );
        assert!(
            app.loading_context.is_none(),
            "without db reader analytics loading context should clear"
        );

        let tmp = tempfile::TempDir::new().expect("tempdir");
        let db_path = tmp.path().join("analytics_loading.db");
        let storage = SqliteStorage::open(&db_path).expect("open sqlite for analytics test");
        app.db_reader = Some(Arc::new(storage));

        let cmd = app.schedule_analytics_reload();
        assert!(
            matches!(extract_msg(cmd), Some(CassMsg::AnalyticsLoadRequested)),
            "with db reader analytics reload should dispatch load message"
        );
        assert_eq!(app.loading_context, Some(LoadingContext::Analytics));

        // AnalyticsLoadRequested now spawns an async task — loading context
        // stays set until the response arrives.
        let _ = app.update(CassMsg::AnalyticsLoadRequested);
        assert_eq!(
            app.loading_context,
            Some(LoadingContext::Analytics),
            "loading context should remain set while async task is in flight"
        );

        // Simulate the async response arriving.
        let _ = app.update(CassMsg::AnalyticsChartDataLoaded(Box::default()));
        assert!(
            app.loading_context.is_none(),
            "loading context should clear after data arrives"
        );
        assert!(
            app.analytics_cache.is_some(),
            "analytics cache should be populated after data arrives"
        );
    }

    #[test]
    fn analytics_surface_renders_loading_placeholder() {
        use ftui::render::budget::DegradationLevel;
        use ftui_harness::buffer_to_text;

        let mut app = CassApp::default();
        app.surface = AppSurface::Analytics;
        app.loading_context = Some(LoadingContext::Analytics);
        let rendered = buffer_to_text(&render_at_degradation(
            &app,
            120,
            24,
            DegradationLevel::Full,
        ));
        assert!(
            rendered.contains("Loading analytics..."),
            "analytics surface should show loading placeholder text"
        );
    }

    #[test]
    fn analytics_chart_data_failure_clears_loading_and_sets_status() {
        let mut app = CassApp::default();
        app.loading_context = Some(LoadingContext::Analytics);
        let _ = app.update(CassMsg::AnalyticsChartDataFailed("db locked".to_string()));
        assert!(
            app.loading_context.is_none(),
            "loading context should clear on failure"
        );
        assert!(
            app.status.contains("db locked"),
            "status should contain error message"
        );
        assert!(
            app.analytics_cache.is_none(),
            "cache should remain None on failure"
        );
    }

    #[test]
    #[allow(clippy::arc_with_non_send_sync)]
    fn analytics_entered_sets_loading_context_when_cache_empty() {
        let tmp = tempfile::TempDir::new().expect("tempdir");
        let db_path = tmp.path().join("analytics_enter.db");
        let storage = SqliteStorage::open(&db_path).expect("open sqlite");
        let mut app = CassApp::default();
        app.db_reader = Some(Arc::new(storage));
        app.analytics_cache = None;
        app.surface = AppSurface::Search;
        let _ = app.update(CassMsg::AnalyticsEntered);
        assert_eq!(app.surface, AppSurface::Analytics);
        assert_eq!(
            app.loading_context,
            Some(LoadingContext::Analytics),
            "entering analytics with empty cache should set loading context"
        );
    }

    #[test]
    fn analytics_entered_skips_load_when_cache_present() {
        let mut app = CassApp::default();
        app.analytics_cache = Some(AnalyticsChartData::default());
        app.surface = AppSurface::Search;
        let _ = app.update(CassMsg::AnalyticsEntered);
        assert_eq!(app.surface, AppSurface::Analytics);
        assert!(
            app.loading_context.is_none(),
            "entering analytics with populated cache should not set loading context"
        );
    }

    #[test]
    fn state_load_sets_and_clears_loading_context() {
        let mut app = CassApp::default();
        assert!(app.loading_context.is_none());

        // StateLoadRequested sets loading context.
        let _ = app.update(CassMsg::StateLoadRequested);
        assert_eq!(
            app.loading_context,
            Some(LoadingContext::StateLoad),
            "state load should set loading context"
        );

        // StateLoaded clears it.
        let state = persisted_state_defaults();
        let _ = app.update(CassMsg::StateLoaded(Box::new(state)));
        assert!(
            app.loading_context.is_none(),
            "state loaded should clear loading context"
        );
    }

    #[test]
    fn state_load_failure_clears_loading_context() {
        let mut app = CassApp::default();
        app.loading_context = Some(LoadingContext::StateLoad);
        let _ = app.update(CassMsg::StateLoadFailed("disk error".to_string()));
        assert!(
            app.loading_context.is_none(),
            "state load failure should clear loading context"
        );
        assert!(
            app.status.contains("disk error"),
            "status should contain the error"
        );
    }

    #[test]
    fn loading_hud_token_includes_spinner_and_context_label() {
        let mut app = CassApp::default();
        app.loading_context = Some(LoadingContext::Search);
        app.spinner_frame = 0;

        let glyph = app.loading_spinner_glyph();
        let hud = app.loading_hud_token();
        assert!(hud.is_some(), "should have loading HUD token during search");
        let hud_text = hud.unwrap();
        assert!(
            hud_text.starts_with(glyph),
            "HUD token should start with spinner glyph"
        );
        assert!(
            hud_text.contains("search"),
            "HUD token should contain context label"
        );

        // No loading context → no HUD token.
        app.loading_context = None;
        assert!(app.loading_hud_token().is_none());
    }

    #[test]
    fn spinner_prefix_only_on_active_operation_status() {
        use ftui::render::budget::DegradationLevel;
        use ftui_harness::buffer_to_text;

        // With a "Searching" status and active loading context, the footer
        // should contain a spinner glyph.
        let mut app = CassApp::default();
        app.status = "Searching\u{2026}".to_string();
        app.loading_context = Some(LoadingContext::Search);
        app.spinner_frame = 0;
        let rendered = buffer_to_text(&render_at_degradation(
            &app,
            120,
            24,
            DegradationLevel::Full,
        ));
        let glyph = app.loading_spinner_glyph();
        assert!(
            rendered.contains(&format!("{glyph} Searching")),
            "searching status should get spinner prefix in footer"
        );

        // With a non-loading status but an active loading context, no prefix.
        app.status = "Explorer set to Hourly".to_string();
        app.loading_context = Some(LoadingContext::Analytics);
        let rendered = buffer_to_text(&render_at_degradation(
            &app,
            120,
            24,
            DegradationLevel::Full,
        ));
        assert!(
            !rendered.contains(&format!("{glyph} Explorer")),
            "non-loading status should NOT get spinner prefix"
        );
    }

    #[test]
    fn detail_panel_renders_loading_placeholder() {
        use ftui::render::budget::DegradationLevel;
        use ftui_harness::buffer_to_text;

        let mut app = CassApp::default();
        app.panes.push(AgentPane {
            agent: "claude_code".into(),
            total_count: 1,
            hits: vec![make_test_hit()],
            selected: 0,
        });
        app.active_pane = 0;
        app.loading_context = Some(LoadingContext::DetailModal);

        let rendered = buffer_to_text(&render_at_degradation(
            &app,
            120,
            24,
            DegradationLevel::Full,
        ));
        assert!(
            rendered.contains("Loading conversation details..."),
            "detail panel should show loading placeholder text"
        );
    }

    #[test]
    fn analytics_entered_idempotent() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::AnalyticsEntered);
        let _ = app.update(CassMsg::AnalyticsEntered);
        // Should not push duplicate onto stack
        assert_eq!(app.view_stack.len(), 1);
        assert_eq!(app.surface, AppSurface::Analytics);
    }

    #[test]
    fn analytics_view_changed_updates_subview() {
        use ftui::render::budget::DegradationLevel;

        let mut app = CassApp::default();
        let _ = app.update(CassMsg::AnalyticsEntered);
        let _ = render_at_degradation(&app, 120, 24, DegradationLevel::Full);
        assert_eq!(app.analytics_view, AnalyticsView::Dashboard);
        app.view_transition = None;

        let _ = app.update(CassMsg::AnalyticsViewChanged(AnalyticsView::Heatmap));
        assert_eq!(app.analytics_view, AnalyticsView::Heatmap);
        let transition = app
            .view_transition
            .as_ref()
            .expect("analytics tab change should start transition");
        assert_eq!(transition.from_label, "Analytics Dashboard");
        assert_eq!(transition.to_label, "Analytics Heatmap");
        assert_eq!(transition.duration, ANALYTICS_VIEW_TRANSITION_DURATION);
        assert!(
            transition.from_snapshot.is_some(),
            "analytics subview transition should capture previous subview snapshot"
        );
    }

    #[test]
    fn tick_clears_completed_view_transition() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::AnalyticsEntered);
        assert!(app.view_transition.is_some());

        if let Some(transition) = app.view_transition.as_mut() {
            transition.started_at = Instant::now() - transition.duration - Duration::from_millis(1);
        }

        let _ = app.update(CassMsg::Tick);
        assert!(
            app.view_transition.is_none(),
            "expired transition should be cleared on tick"
        );
    }

    #[test]
    fn transition_effect_hidden_under_essential_degradation() {
        use ftui::render::budget::DegradationLevel;
        use ftui_harness::buffer_to_text;

        let mut app = CassApp::default();
        let _ = render_at_degradation(&app, 120, 24, DegradationLevel::Full);
        let _ = app.update(CassMsg::AnalyticsEntered);
        let transition = app
            .view_transition
            .as_mut()
            .expect("expected active transition after surface switch");
        transition.started_at = Instant::now();

        let full_transition = buffer_to_text(&render_at_degradation(
            &app,
            120,
            24,
            DegradationLevel::Full,
        ));
        let saved_transition = app
            .view_transition
            .clone()
            .expect("transition should still be active");
        app.view_transition = None;
        let full_static = buffer_to_text(&render_at_degradation(
            &app,
            120,
            24,
            DegradationLevel::Full,
        ));
        assert!(
            full_transition != full_static,
            "full degradation should apply transition blending"
        );

        app.view_transition = Some(saved_transition.clone());
        let essential_transition = buffer_to_text(&render_at_degradation(
            &app,
            120,
            24,
            DegradationLevel::EssentialOnly,
        ));
        app.view_transition = None;
        let essential_static = buffer_to_text(&render_at_degradation(
            &app,
            120,
            24,
            DegradationLevel::EssentialOnly,
        ));
        assert!(
            essential_transition == essential_static,
            "essential degradation should suppress transition blending"
        );
        app.view_transition = Some(saved_transition);
        let essential_labeled = buffer_to_text(&render_at_degradation(
            &app,
            120,
            24,
            DegradationLevel::Full,
        ));
        assert!(
            essential_labeled.contains("Search -> Analytics"),
            "transition affordance should include source/target labels"
        );
    }

    #[test]
    fn active_transition_renders_cleanly_across_sizes_and_degradation_levels() {
        use ftui::render::budget::DegradationLevel;
        use ftui_harness::buffer_to_text;

        let mut app = CassApp::default();
        let _ = render_at_degradation(&app, 120, 24, DegradationLevel::Full);
        let _ = app.update(CassMsg::AnalyticsEntered);
        assert!(
            app.view_transition.is_some(),
            "analytics entry should activate transition state"
        );

        let levels = [
            DegradationLevel::Full,
            DegradationLevel::SimpleBorders,
            DegradationLevel::NoStyling,
            DegradationLevel::EssentialOnly,
            DegradationLevel::Skeleton,
        ];
        let sizes = [(40, 12), (64, 18), (80, 24), (120, 40), (160, 50)];

        for (width, height) in sizes {
            for level in levels {
                let rendered = buffer_to_text(&render_at_degradation(&app, width, height, level));
                assert!(
                    !rendered.is_empty(),
                    "transition render should produce output at {width}x{height} ({level:?})"
                );
                assert!(
                    !rendered.contains('\u{fffd}'),
                    "transition render should avoid replacement glyph artifacts at {width}x{height} ({level:?})"
                );
            }
        }
    }

    #[test]
    fn view_stack_popped_returns_to_search() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::AnalyticsEntered);
        assert_eq!(app.surface, AppSurface::Analytics);

        let _ = app.update(CassMsg::ViewStackPopped);
        assert_eq!(app.surface, AppSurface::Search);
        assert!(app.view_stack.is_empty());
    }

    #[test]
    fn view_stack_popped_empty_defaults_to_search() {
        let mut app = CassApp::default();
        app.surface = AppSurface::Analytics;
        // Stack is empty
        let _ = app.update(CassMsg::ViewStackPopped);
        assert_eq!(app.surface, AppSurface::Search);
    }

    #[test]
    fn esc_from_analytics_pops_view_stack() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::AnalyticsEntered);
        assert_eq!(app.surface, AppSurface::Analytics);

        // QuitRequested on analytics returns Cmd::msg(ViewStackPopped).
        // Simulate the two-step dispatch:
        let _ = app.update(CassMsg::QuitRequested);
        let _ = app.update(CassMsg::ViewStackPopped);
        assert_eq!(app.surface, AppSurface::Search);
    }

    #[test]
    fn analytics_time_range_set() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::AnalyticsTimeRangeSet {
            since_ms: Some(1000),
            until_ms: Some(2000),
        });
        assert_eq!(app.analytics_filters.since_ms, Some(1000));
        assert_eq!(app.analytics_filters.until_ms, Some(2000));
    }

    #[test]
    fn analytics_agent_filter_set() {
        let mut app = CassApp::default();
        let agents: HashSet<String> = ["claude_code", "codex"]
            .iter()
            .map(|s| s.to_string())
            .collect();
        let _ = app.update(CassMsg::AnalyticsAgentFilterSet(agents.clone()));
        assert_eq!(app.analytics_filters.agents, agents);
    }

    #[test]
    fn analytics_workspace_filter_set() {
        let mut app = CassApp::default();
        let ws: HashSet<String> = ["proj_a"].iter().map(|s| s.to_string()).collect();
        let _ = app.update(CassMsg::AnalyticsWorkspaceFilterSet(ws.clone()));
        assert_eq!(app.analytics_filters.workspaces, ws);
    }

    #[test]
    fn analytics_source_filter_set() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::AnalyticsSourceFilterSet(SourceFilter::Local));
        assert_eq!(app.analytics_filters.source_filter, SourceFilter::Local);
    }

    #[test]
    fn analytics_filters_clear_all() {
        let mut app = CassApp::default();
        app.analytics_filters.since_ms = Some(1000);
        app.analytics_filters.agents.insert("claude_code".into());
        app.analytics_filters.source_filter = SourceFilter::Remote;

        let _ = app.update(CassMsg::AnalyticsFiltersClearAll);
        assert!(app.analytics_filters.since_ms.is_none());
        assert!(app.analytics_filters.agents.is_empty());
        assert_eq!(app.analytics_filters.source_filter, SourceFilter::All);
    }

    #[test]
    fn analytics_drilldown_inherits_filters_and_clears_stale_search_filters() {
        let mut app = CassApp::default();
        app.surface = AppSurface::Analytics;

        // Seed stale search filters that should be replaced by analytics filters.
        app.filters.agents.insert("stale-agent".into());
        app.filters.workspaces.insert("/stale/ws".into());
        app.filters.source_filter = SourceFilter::Remote;
        app.filters
            .session_paths
            .insert("/tmp/stale-session.jsonl".into());

        app.analytics_filters.since_ms = Some(10_000);
        app.analytics_filters.until_ms = Some(20_000);
        app.analytics_filters.agents.insert("claude_code".into());
        app.analytics_filters
            .workspaces
            .insert("/analytics/ws".into());
        app.analytics_filters.source_filter = SourceFilter::Local;

        let _ = app.update(CassMsg::AnalyticsDrilldown(DrilldownContext {
            since_ms: Some(30_000),
            until_ms: Some(40_000),
            agent: None,
            workspace: None,
            source_filter: None,
            model: None,
        }));

        assert_eq!(app.surface, AppSurface::Search);
        assert_eq!(app.filters.created_from, Some(30_000));
        assert_eq!(app.filters.created_to, Some(40_000));
        assert_eq!(app.filters.agents, app.analytics_filters.agents);
        assert_eq!(app.filters.workspaces, app.analytics_filters.workspaces);
        assert_eq!(
            app.filters.source_filter,
            app.analytics_filters.source_filter
        );
        assert!(
            app.filters.session_paths.is_empty(),
            "drilldown should clear chained session_paths"
        );
    }

    #[test]
    fn analytics_drilldown_agent_dimension_overrides_inherited_agent_filters() {
        let mut app = CassApp::default();
        app.surface = AppSurface::Analytics;
        app.analytics_filters.agents.insert("claude_code".into());
        app.analytics_filters.agents.insert("cursor".into());

        let _ = app.update(CassMsg::AnalyticsDrilldown(DrilldownContext {
            since_ms: None,
            until_ms: None,
            agent: Some("codex".into()),
            workspace: None,
            source_filter: None,
            model: None,
        }));

        let expected: HashSet<String> = ["codex"].iter().map(|s| s.to_string()).collect();
        assert_eq!(app.filters.agents, expected);
    }

    #[test]
    fn analytics_drilldown_back_navigation_preserves_selection() {
        let mut app = CassApp::default();
        app.surface = AppSurface::Analytics;
        app.analytics_selection = 3;

        let cmd = app.update(CassMsg::AnalyticsDrilldown(DrilldownContext {
            since_ms: Some(1),
            until_ms: Some(2),
            agent: None,
            workspace: None,
            source_filter: None,
            model: None,
        }));
        assert!(matches!(extract_msg(cmd), Some(CassMsg::SearchRequested)));
        assert_eq!(app.surface, AppSurface::Search);
        assert_eq!(app.view_stack.last(), Some(&AppSurface::Analytics));

        let _ = app.update(CassMsg::ViewStackPopped);
        assert_eq!(app.surface, AppSurface::Analytics);
        assert_eq!(app.analytics_selection, 3);
    }

    #[test]
    fn analytics_drilldown_workspace_dimension_overrides_inherited_workspaces() {
        let mut app = CassApp::default();
        app.surface = AppSurface::Analytics;
        app.analytics_filters
            .workspaces
            .insert("/analytics/ws".into());

        let _ = app.update(CassMsg::AnalyticsDrilldown(DrilldownContext {
            since_ms: None,
            until_ms: None,
            agent: None,
            workspace: Some("/target/ws".into()),
            source_filter: None,
            model: None,
        }));

        let expected: HashSet<String> = ["/target/ws"].iter().map(|s| s.to_string()).collect();
        assert_eq!(app.filters.workspaces, expected);
    }

    #[test]
    fn analytics_drilldown_source_dimension_overrides_inherited_source_filter() {
        let mut app = CassApp::default();
        app.surface = AppSurface::Analytics;
        app.analytics_filters.source_filter = SourceFilter::Remote;

        let _ = app.update(CassMsg::AnalyticsDrilldown(DrilldownContext {
            since_ms: None,
            until_ms: None,
            agent: None,
            workspace: None,
            source_filter: Some(SourceFilter::SourceId("work-laptop".into())),
            model: None,
        }));

        assert_eq!(
            app.filters.source_filter,
            SourceFilter::SourceId("work-laptop".into())
        );
    }

    #[test]
    fn analytics_drilldown_model_dimension_seeds_query() {
        let mut app = CassApp::default();
        app.surface = AppSurface::Analytics;

        let _ = app.update(CassMsg::AnalyticsDrilldown(DrilldownContext {
            since_ms: None,
            until_ms: None,
            agent: None,
            workspace: None,
            source_filter: None,
            model: Some("gpt-4o".into()),
        }));

        assert_eq!(app.query, "gpt-4o");
        assert_eq!(app.cursor_pos, "gpt-4o".chars().count());
        assert_eq!(app.input_mode, InputMode::Query);
    }

    #[test]
    fn day_label_to_epoch_range_validates_calendar_dates() {
        assert_eq!(
            day_label_to_epoch_range("1970-01-01"),
            Some((0, 86_400_000))
        );
        assert_eq!(
            day_label_to_epoch_range("2024-02-29").map(|(start, end)| end - start),
            Some(86_400_000)
        );
        assert!(day_label_to_epoch_range("2023-02-29").is_none());
        assert!(day_label_to_epoch_range("2026-13-01").is_none());
        assert!(day_label_to_epoch_range("2026-04-31").is_none());
        assert!(day_label_to_epoch_range("not-a-date").is_none());
    }

    #[test]
    fn analytics_view_labels_all_unique() {
        let views = AnalyticsView::all();
        let labels: Vec<&str> = views.iter().map(|v| v.label()).collect();
        let mut unique = labels.clone();
        unique.sort();
        unique.dedup();
        assert_eq!(labels.len(), unique.len(), "all view labels must be unique");
    }

    #[test]
    fn analytics_view_all_has_seven_entries() {
        assert_eq!(AnalyticsView::all().len(), 7);
    }

    #[test]
    fn analytics_filter_summary_empty() {
        let app = CassApp::default();
        assert_eq!(app.analytics_filter_summary(), "Filters: none");
    }

    #[test]
    fn analytics_filter_summary_with_filters() {
        let mut app = CassApp::default();
        app.analytics_filters.since_ms = Some(1000);
        app.analytics_filters.agents.insert("claude_code".into());
        let summary = app.analytics_filter_summary();
        assert!(summary.contains("since:1000"));
        assert!(summary.contains("agents:claude_code"));
    }

    #[test]
    fn palette_has_analytics_actions() {
        let actions = default_actions();
        let labels: Vec<&str> = actions.iter().map(|a| a.label.as_str()).collect();
        assert!(labels.contains(&"Analytics: Dashboard"));
        assert!(labels.contains(&"Analytics: Explorer"));
        assert!(labels.contains(&"Analytics: Heatmap"));
        assert!(labels.contains(&"Analytics: Breakdowns"));
        assert!(labels.contains(&"Analytics: Tools"));
        assert!(!labels.contains(&"Analytics: Cost"));
        assert!(labels.contains(&"Analytics: Coverage"));
    }

    #[test]
    fn default_surface_is_search() {
        let app = CassApp::default();
        assert_eq!(app.surface, AppSurface::Search);
        assert_eq!(app.analytics_view, AnalyticsView::Dashboard);
        assert!(app.analytics_filters.agents.is_empty());
        assert!(app.analytics_filters.workspaces.is_empty());
        assert!(app.analytics_filters.since_ms.is_none());
        assert!(app.analytics_filters.until_ms.is_none());
    }

    // ── Adaptive rendering / perf budget tests ─────────────────────────

    /// Helper: render the app into a buffer at a given degradation level.
    fn render_at_degradation(
        app: &CassApp,
        width: u16,
        height: u16,
        level: ftui::render::budget::DegradationLevel,
    ) -> ftui::Buffer {
        let mut pool = ftui::GraphemePool::new();
        let mut frame = ftui::Frame::new(width, height, &mut pool);
        frame.set_degradation(level);
        app.view(&mut frame);
        frame.buffer
    }

    #[test]
    fn view_deterministic_under_repeated_renders() {
        use ftui_harness::buffer_to_text;

        let app = CassApp::default();
        let buf1 =
            render_at_degradation(&app, 80, 24, ftui::render::budget::DegradationLevel::Full);
        let buf2 =
            render_at_degradation(&app, 80, 24, ftui::render::budget::DegradationLevel::Full);
        assert_eq!(
            buffer_to_text(&buf1),
            buffer_to_text(&buf2),
            "Repeated renders of the same state must produce identical output"
        );
    }

    #[test]
    fn view_no_panic_at_every_degradation_level() {
        use ftui::render::budget::DegradationLevel;

        let app = CassApp::default();
        let levels = [
            DegradationLevel::Full,
            DegradationLevel::SimpleBorders,
            DegradationLevel::NoStyling,
            DegradationLevel::EssentialOnly,
            DegradationLevel::Skeleton,
        ];
        for level in levels {
            let _ = render_at_degradation(&app, 80, 24, level);
        }
    }

    #[test]
    fn view_no_panic_analytics_at_every_degradation_level() {
        use ftui::render::budget::DegradationLevel;

        let mut app = CassApp::default();
        let _ = app.update(CassMsg::AnalyticsEntered);
        let levels = [
            DegradationLevel::Full,
            DegradationLevel::SimpleBorders,
            DegradationLevel::NoStyling,
            DegradationLevel::EssentialOnly,
            DegradationLevel::Skeleton,
        ];
        for level in levels {
            let _ = render_at_degradation(&app, 80, 24, level);
        }
    }

    #[test]
    fn view_degraded_borders_differ_from_full() {
        use ftui::render::budget::DegradationLevel;
        use ftui_harness::buffer_to_text;

        let app = CassApp::default();
        let full = buffer_to_text(&render_at_degradation(&app, 80, 24, DegradationLevel::Full));
        let simple = buffer_to_text(&render_at_degradation(
            &app,
            80,
            24,
            DegradationLevel::SimpleBorders,
        ));
        // Full uses rounded borders (╭), SimpleBorders uses ASCII (+/-/|).
        assert_ne!(
            full, simple,
            "SimpleBorders should produce different output than Full"
        );
    }

    #[test]
    fn view_essential_only_skips_borders() {
        use ftui::render::budget::DegradationLevel;
        use ftui_harness::buffer_to_text;

        let app = CassApp::default();
        let full_text =
            buffer_to_text(&render_at_degradation(&app, 80, 24, DegradationLevel::Full));
        let essential_text = buffer_to_text(&render_at_degradation(
            &app,
            80,
            24,
            DegradationLevel::EssentialOnly,
        ));
        // Full rendering has border characters; essential does not.
        let has_box_char = |s: &str| {
            s.contains('╭')
                || s.contains('╮')
                || s.contains('╰')
                || s.contains('╯')
                || s.contains('─')
        };
        assert!(
            has_box_char(&full_text),
            "Full should contain border characters"
        );
        assert!(
            !has_box_char(&essential_text),
            "EssentialOnly should not contain border characters"
        );
    }

    #[test]
    fn view_skeleton_skips_analytics_content() {
        use ftui::render::budget::DegradationLevel;
        use ftui_harness::buffer_to_text;

        let mut app = CassApp::default();
        let _ = app.update(CassMsg::AnalyticsEntered);
        let full_text =
            buffer_to_text(&render_at_degradation(&app, 80, 24, DegradationLevel::Full));
        let skeleton_text = buffer_to_text(&render_at_degradation(
            &app,
            80,
            24,
            DegradationLevel::Skeleton,
        ));
        // Full shows chart content (e.g. KPI text or "No agent data" fallback);
        // Skeleton skips content entirely.
        assert!(
            full_text.contains("Agents:") || full_text.contains("No "),
            "Full analytics should show chart content: {full_text}"
        );
        assert!(
            !skeleton_text.contains("Agents:") && !skeleton_text.contains("No agent"),
            "Skeleton should skip content text"
        );
    }

    #[test]
    fn view_no_styling_drops_colors() {
        use ftui::render::budget::DegradationLevel;
        use ftui::render::cell::PackedRgba;

        let app = CassApp::default();
        let full_buf = render_at_degradation(&app, 80, 24, DegradationLevel::Full);
        let no_style_buf = render_at_degradation(&app, 80, 24, DegradationLevel::NoStyling);

        // Count cells with non-default/non-transparent foreground or background.
        let count_colored = |buf: &ftui::Buffer| -> usize {
            buf.cells()
                .iter()
                .filter(|c| {
                    c.fg != PackedRgba::WHITE && c.fg != PackedRgba::TRANSPARENT
                        || c.bg != PackedRgba::TRANSPARENT
                })
                .count()
        };
        let full_colored = count_colored(&full_buf);
        let no_style_colored = count_colored(&no_style_buf);
        assert!(
            no_style_colored < full_colored,
            "NoStyling ({no_style_colored}) should have fewer colored cells than Full ({full_colored})"
        );
    }

    #[test]
    fn degradation_level_status_tag_shown_when_degraded() {
        use ftui::render::budget::DegradationLevel;
        use ftui_harness::buffer_to_text;

        let app = CassApp::default();
        let full_text = buffer_to_text(&render_at_degradation(
            &app,
            120,
            24,
            DegradationLevel::Full,
        ));
        let degraded_text = buffer_to_text(&render_at_degradation(
            &app,
            120,
            24,
            DegradationLevel::SimpleBorders,
        ));
        assert!(
            !full_text.contains("deg:"),
            "Full should not show degradation tag"
        );
        assert!(
            degraded_text.contains("deg:SimpleBorders"),
            "SimpleBorders should show degradation tag in status"
        );
    }

    #[test]
    fn degradation_level_enum_progression() {
        use ftui::render::budget::DegradationLevel;

        let mut level = DegradationLevel::Full;
        assert!(level.is_full());
        assert!(level.use_unicode_borders());
        assert!(level.apply_styling());
        assert!(level.render_decorative());
        assert!(level.render_content());

        level = level.next(); // SimpleBorders
        assert!(!level.use_unicode_borders());
        assert!(level.apply_styling());

        level = level.next(); // NoStyling
        assert!(!level.apply_styling());
        assert!(level.render_decorative());

        level = level.next(); // EssentialOnly
        assert!(!level.render_decorative());
        assert!(level.render_content());

        level = level.next(); // Skeleton
        assert!(!level.render_content());

        level = level.next(); // SkipFrame
        assert!(level.is_max());
    }

    #[test]
    fn frame_budget_config_defaults_are_sane() {
        use ftui::render::budget::FrameBudgetConfig;

        let cfg = FrameBudgetConfig::default();
        assert_eq!(cfg.total, std::time::Duration::from_millis(16));
        assert!(cfg.allow_frame_skip);
        assert_eq!(cfg.degradation_cooldown, 3);
    }

    #[test]
    fn cass_runtime_budget_profile_is_quality_first_and_stable() {
        let cfg = cass_runtime_budget_config();
        assert_eq!(cfg.total, std::time::Duration::from_millis(120));
        assert_eq!(cfg.phase_budgets.diff, std::time::Duration::from_millis(6));
        assert_eq!(
            cfg.phase_budgets.present,
            std::time::Duration::from_millis(12)
        );
        assert_eq!(
            cfg.phase_budgets.render,
            std::time::Duration::from_millis(24)
        );
        assert!(!cfg.allow_frame_skip);
        assert_eq!(cfg.degradation_cooldown, 20);
        assert!((cfg.upgrade_threshold - 0.40).abs() < f32::EPSILON);
    }

    #[test]
    fn cass_runtime_budget_upgrade_is_debounced_by_cooldown() {
        use ftui::render::budget::{DegradationLevel, RenderBudget};

        let cfg = cass_runtime_budget_config();
        let mut budget = RenderBudget::from_config(&cfg);
        budget.set_degradation(DegradationLevel::SimpleBorders);

        // next_frame() checks frames_since_change BEFORE incrementing it (via
        // its internal reset() call). So the upgrade eligibility check on the
        // N-th call sees frames_since_change = N-1. We need cooldown+1 calls
        // total for the check to see frames_since_change == cooldown.
        for _ in 0..cfg.degradation_cooldown {
            budget.record_frame_time(std::time::Duration::from_millis(10));
            budget.next_frame();
        }
        // During cooldown, upgrade should not have fired yet.
        assert_eq!(budget.degradation(), DegradationLevel::SimpleBorders);

        // One more frame: check sees frames_since_change == cooldown → upgrade.
        budget.record_frame_time(std::time::Duration::from_millis(10));
        budget.next_frame();
        assert_eq!(budget.degradation(), DegradationLevel::Full);
    }

    #[test]
    fn dumb_term_style_profile_upgrade_triggers_for_inherited_mono() {
        let style_options = StyleOptions {
            color_profile: ftui::ColorProfile::Mono,
            no_color: false,
            ..StyleOptions::default()
        };
        assert!(should_upgrade_style_profile_for_dumb_term(
            style_options,
            true,
            false,
            false,
            false,
            false
        ));
    }

    #[test]
    fn dumb_term_style_profile_upgrade_triggers_for_inherited_ansi16() {
        let style_options = StyleOptions {
            color_profile: ftui::ColorProfile::Ansi16,
            no_color: false,
            ..StyleOptions::default()
        };
        assert!(should_upgrade_style_profile_for_dumb_term(
            style_options,
            true,
            false,
            false,
            false,
            false
        ));
    }

    #[test]
    fn dumb_term_style_profile_upgrade_respects_explicit_no_color_intent() {
        let style_options = StyleOptions {
            color_profile: ftui::ColorProfile::Mono,
            no_color: true,
            ..StyleOptions::default()
        };
        assert!(!should_upgrade_style_profile_for_dumb_term(
            style_options,
            true,
            false,
            false,
            true,
            false
        ));
    }

    #[test]
    fn dumb_term_style_profile_upgrade_respects_explicit_profile_override() {
        let style_options = StyleOptions {
            color_profile: ftui::ColorProfile::Ansi16,
            no_color: false,
            ..StyleOptions::default()
        };
        assert!(!should_upgrade_style_profile_for_dumb_term(
            style_options,
            true,
            false,
            false,
            false,
            true
        ));
    }

    #[test]
    fn dumb_term_style_profile_upgrade_skips_when_not_in_compat_mode() {
        let style_options = StyleOptions {
            color_profile: ftui::ColorProfile::Mono,
            no_color: false,
            ..StyleOptions::default()
        };
        assert!(!should_upgrade_style_profile_for_dumb_term(
            style_options,
            true,
            true,
            false,
            false,
            false
        ));
        assert!(!should_upgrade_style_profile_for_dumb_term(
            style_options,
            true,
            false,
            true,
            false,
            false
        ));
        assert!(!should_upgrade_style_profile_for_dumb_term(
            style_options,
            false,
            false,
            false,
            false,
            false
        ));
    }

    #[test]
    fn render_deterministic_across_both_surfaces() {
        use ftui::render::budget::DegradationLevel;
        use ftui_harness::buffer_to_text;

        let mut app = CassApp::default();
        let search_buf1 = render_at_degradation(&app, 80, 24, DegradationLevel::Full);
        let search_buf2 = render_at_degradation(&app, 80, 24, DegradationLevel::Full);
        assert_eq!(buffer_to_text(&search_buf1), buffer_to_text(&search_buf2));

        let _ = app.update(CassMsg::AnalyticsEntered);
        // Clear the time-dependent view transition overlay so consecutive
        // renders are not affected by wall-clock Instant::now() drift.
        app.view_transition = None;
        let analytics_buf1 = render_at_degradation(&app, 80, 24, DegradationLevel::Full);
        let analytics_buf2 = render_at_degradation(&app, 80, 24, DegradationLevel::Full);
        assert_eq!(
            buffer_to_text(&analytics_buf1),
            buffer_to_text(&analytics_buf2)
        );
    }

    // =====================================================================
    // 2noh9.3.9 — Multi-select & bulk actions
    // =====================================================================

    /// Helper: build a test SearchHit with a unique source_path and content_hash.
    fn make_hit(id: u64, path: &str) -> SearchHit {
        SearchHit {
            title: format!("Hit {id}"),
            snippet: String::new(),
            content: String::new(),
            content_hash: id,
            score: 1.0 - (id as f32 * 0.1),
            agent: "claude_code".into(),
            source_path: path.into(),
            workspace: "/w".into(),
            workspace_original: None,
            created_at: None,
            line_number: Some(id as usize),
            match_type: Default::default(),
            source_id: "local".into(),
            origin_kind: "local".into(),
            origin_host: None,
        }
    }

    /// Deterministic high-fidelity fixture set for TUI visual rendering tests.
    fn rich_visual_fixture_hits() -> Vec<SearchHit> {
        vec![
            SearchHit {
                title: "Auth regression triage summary".into(),
                snippet: "## Incident summary\n- symptom: OAuth callback loop\n- blast radius: desktop + remote users\n- status: mitigated".into(),
                content: "## Timeline\n1. 09:12 deploy\n2. 09:17 alert\n3. 09:32 rollback\n\n```rust\nif token.is_expired() { refresh()?; }\n```\n\n[runbook](https://internal.example/auth)".into(),
                content_hash: 9001,
                score: 0.98,
                agent: "claude_code".into(),
                source_path: "/workspace/cass/src/auth/session.rs".into(),
                workspace: "/workspace/cass".into(),
                workspace_original: Some("/Users/dev/cass".into()),
                created_at: None,
                line_number: Some(142),
                match_type: MatchType::Exact,
                source_id: "local".into(),
                origin_kind: "local".into(),
                origin_host: None,
            },
            SearchHit {
                title: "Search ranking tuning notes".into(),
                snippet: "### Candidate signals\n- lexical boost\n- semantic recall\n- recency decay window=30d\n- quality rerank with guardrails".into(),
                content: "### Experiment matrix\n| mode | ndcg@10 |\n| --- | --- |\n| lexical | 0.61 |\n| hybrid | 0.74 |\n\n```sql\nSELECT source_id, avg(score) FROM hits GROUP BY 1;\n```".into(),
                content_hash: 9002,
                score: 0.91,
                agent: "codex".into(),
                source_path: "/workspace/cass/src/search/ranking.rs".into(),
                workspace: "/workspace/cass".into(),
                workspace_original: Some("/srv/repos/cass".into()),
                created_at: None,
                line_number: Some(287),
                match_type: MatchType::Prefix,
                source_id: "workstation-west".into(),
                origin_kind: "ssh".into(),
                origin_host: Some("workstation-west".into()),
            },
            SearchHit {
                title: "Theme audit and contrast findings".into(),
                snippet: "High-contrast preset retains hierarchy; Nord needed low-score tint adjustment to prevent SCORE_MID collision.".into(),
                content: "## Contrast report\n- pass: text.primary on pane.base\n- pass: pill.active fg/bg\n- follow-up: find-bar border token\n\n```json\n{\"preset\":\"nord\",\"issue\":\"score_low_collision\"}\n```".into(),
                content_hash: 9003,
                score: 0.88,
                agent: "cursor".into(),
                source_path: "/workspace/cass/src/ui/style_system.rs".into(),
                workspace: "/workspace/cass".into(),
                workspace_original: Some("/home/ops/cass".into()),
                created_at: None,
                line_number: Some(1166),
                match_type: MatchType::Substring,
                source_id: "remote-ci".into(),
                origin_kind: "remote".into(),
                origin_host: Some("runner-17".into()),
            },
            SearchHit {
                title: "Multi-agent coordination transcript".into(),
                snippet: "Participants: user, assistant, tool, system, reviewer. Includes dependency routing and escalation policy.".into(),
                content: "## Roles\n- user: requested visual parity\n- assistant: implemented search-bar affordance\n- tool: generated PTY captures\n- system: enforced quality gates\n\n> Coordination stayed in thread `coding_agent_session_search-2dccg`.".into(),
                content_hash: 9004,
                score: 0.77,
                agent: "gemini".into(),
                source_path: "/workspace/cass/docs/coordination/2dccg.md".into(),
                workspace: "/workspace/cass".into(),
                workspace_original: Some("/Users/research/cass".into()),
                created_at: None,
                line_number: Some(63),
                match_type: MatchType::Wildcard,
                source_id: "laptop-east".into(),
                origin_kind: "ssh".into(),
                origin_host: Some("laptop-east".into()),
            },
            SearchHit {
                title: "Large-snippet rendering edge case".into(),
                snippet: "The following snippet intentionally exceeds normal row budgets to exercise truncation, striping, selection, and horizontal clipping behavior under compact and spacious densities.".into(),
                content: "```text\nThis is a deliberately long snippet line that includes repeated context windows, remote provenance markers, and unicode glyphs → λ Δ ✓ to stress wrapping behavior.\n```".into(),
                content_hash: 9005,
                score: 0.64,
                agent: "aider".into(),
                source_path: "/workspace/cass/tests/regression/long_snippet.md".into(),
                workspace: "/workspace/cass".into(),
                workspace_original: Some("/mnt/build/cass".into()),
                created_at: None,
                line_number: Some(9),
                match_type: MatchType::Suffix,
                source_id: "ci-linux".into(),
                origin_kind: "remote".into(),
                origin_host: Some("ci-linux".into()),
            },
            SearchHit {
                title: "JSON payload decode failure".into(),
                snippet: "{\"error\":\"invalid_schema\",\"path\":\"payload.message.parts[2]\",\"hint\":\"expected string\"}".into(),
                content: "{\n  \"event\": \"decode_failure\",\n  \"severity\": \"warning\",\n  \"retries\": 3,\n  \"module\": \"html_export\"\n}".into(),
                content_hash: 9006,
                score: 0.53,
                agent: "opencode".into(),
                source_path: "/workspace/cass/src/export/payload.rs".into(),
                workspace: "/workspace/cass".into(),
                workspace_original: Some("/tmp/cass".into()),
                created_at: None,
                line_number: Some(411),
                match_type: MatchType::Exact,
                source_id: "local".into(),
                origin_kind: "local".into(),
                origin_host: None,
            },
            SearchHit {
                title: "Legacy migration checklist".into(),
                snippet: "1. Replace ratatui snapshots\n2. Align markdown theme mapping\n3. Verify breadcrumbs + pills + footer lanes".into(),
                content: "## Checklist\n- [x] mode-aware title\n- [x] query caret emphasis\n- [ ] full visual matrix in 8.6\n\nSee also: `docs/ftui_visual_parity_rubric.md`.".into(),
                content_hash: 9007,
                score: 0.41,
                agent: "pi-agent".into(),
                source_path: "/workspace/cass/docs/migrations/ftui.md".into(),
                workspace: "/workspace/cass".into(),
                workspace_original: Some("/home/docs/cass".into()),
                created_at: None,
                line_number: Some(101),
                match_type: MatchType::Substring,
                source_id: "docs-host".into(),
                origin_kind: "remote".into(),
                origin_host: Some("docs-host".into()),
            },
            SearchHit {
                title: "Background telemetry heartbeat".into(),
                snippet: "system event: runtime evidence snapshot refreshed; no user-visible errors".into(),
                content: "heartbeat ok\nresize regime: stable\nbudget level: full\ndiff mode: unicode".into(),
                content_hash: 9008,
                score: 0.22,
                agent: "system".into(),
                source_path: "/workspace/cass/runtime/evidence.log".into(),
                workspace: "/workspace/cass".into(),
                workspace_original: Some("/var/lib/cass".into()),
                created_at: None,
                line_number: Some(7),
                match_type: MatchType::ImplicitWildcard,
                source_id: "daemon".into(),
                origin_kind: "service".into(),
                origin_host: Some("daemon-1".into()),
            },
        ]
    }

    /// Helper: create a CassApp with one pane of N hits.
    fn app_with_hits(n: usize) -> CassApp {
        let mut app = CassApp::default();
        let hits: Vec<SearchHit> = (0..n)
            .map(|i| make_hit(i as u64, &format!("/path/{i}")))
            .collect();
        app.panes.push(AgentPane {
            agent: "claude_code".into(),
            total_count: hits.len(),
            hits,
            selected: 0,
        });
        app.active_pane = 0;
        app
    }

    /// Helper: create a CassApp with a richer, deterministic result corpus.
    fn app_with_rich_visual_fixture() -> CassApp {
        let mut app = CassApp::default();
        app.results = rich_visual_fixture_hits();
        app.regroup_panes();
        app.active_pane = 0;
        app
    }

    #[test]
    fn rich_visual_fixture_dataset_is_deterministic_and_diverse() {
        let first = rich_visual_fixture_hits();
        let second = rich_visual_fixture_hits();
        assert_eq!(first.len(), second.len(), "fixture size must be stable");
        for (a, b) in first.iter().zip(second.iter()) {
            assert_eq!(a.title, b.title, "fixture ordering/content must be stable");
            assert_eq!(a.content_hash, b.content_hash);
            assert_eq!(a.score, b.score);
        }

        assert!(
            first.len() >= 8,
            "fixture should include enough rows for striping/scroll tests"
        );

        let agents: std::collections::BTreeSet<_> =
            first.iter().map(|hit| hit.agent.as_str()).collect();
        assert!(
            agents.len() >= 6,
            "fixture should span many agents, got {}",
            agents.len()
        );

        let max_score = first.iter().map(|hit| hit.score).fold(f32::MIN, f32::max);
        let min_score = first.iter().map(|hit| hit.score).fold(f32::MAX, f32::min);
        assert!(
            max_score - min_score > 0.6,
            "fixture should cover a wide score range"
        );

        assert!(
            first
                .iter()
                .any(|hit| hit.content.contains("```") && hit.content.contains("##")),
            "fixture should include markdown-heavy messages with code blocks/headings"
        );
        assert!(
            first.iter().any(|hit| hit.origin_host.is_some()),
            "fixture should include remote source metadata"
        );
        assert!(
            first.iter().any(|hit| hit.snippet.len() > 140),
            "fixture should include long snippets to stress truncation/wrapping"
        );
    }

    #[test]
    fn rich_visual_fixture_renders_across_layouts_without_panic() {
        let app = app_with_rich_visual_fixture();
        for (width, height) in [(60, 24), (100, 24), (140, 36)] {
            let buf = render_at_degradation(
                &app,
                width,
                height,
                ftui::render::budget::DegradationLevel::Full,
            );
            let text = ftui_harness::buffer_to_text(&buf);
            assert!(
                !text.trim().is_empty(),
                "render output should be non-empty at {width}x{height}"
            );
        }
    }

    #[test]
    fn selected_hit_key_from_hit_captures_stable_fields() {
        let hit = make_hit(42, "/some/path");
        let key = SelectedHitKey::from_hit(&hit);
        assert_eq!(key.source_id, "local");
        assert_eq!(key.source_path, "/some/path");
        assert_eq!(key.line_number, Some(42));
        assert_eq!(key.content_hash, 42);
    }

    #[test]
    fn selected_hit_key_equality_and_hash() {
        let h1 = make_hit(1, "/a");
        let h2 = make_hit(1, "/a");
        let h3 = make_hit(2, "/b");
        assert_eq!(SelectedHitKey::from_hit(&h1), SelectedHitKey::from_hit(&h2));
        assert_ne!(SelectedHitKey::from_hit(&h1), SelectedHitKey::from_hit(&h3));
    }

    #[test]
    fn toggle_select_adds_and_removes() {
        let mut app = app_with_hits(3);

        // Toggle: nothing selected → first item selected
        let _ = app.update(CassMsg::SelectionToggled);
        assert_eq!(app.selected.len(), 1);
        assert!(
            app.selected
                .contains(&SelectedHitKey::from_hit(&app.panes[0].hits[0]))
        );

        // Toggle again: removes it
        let _ = app.update(CassMsg::SelectionToggled);
        assert!(app.selected.is_empty());
    }

    #[test]
    fn toggle_select_multiple_items() {
        let mut app = app_with_hits(3);

        // Select item 0
        let _ = app.update(CassMsg::SelectionToggled);
        assert_eq!(app.selected.len(), 1);

        // Move to item 1 and select
        let _ = app.update(CassMsg::SelectionMoved { delta: 1 });
        let _ = app.update(CassMsg::SelectionToggled);
        assert_eq!(app.selected.len(), 2);

        // Move to item 2 and select
        let _ = app.update(CassMsg::SelectionMoved { delta: 1 });
        let _ = app.update(CassMsg::SelectionToggled);
        assert_eq!(app.selected.len(), 3);
    }

    #[test]
    fn select_all_toggles_between_all_and_none() {
        let mut app = app_with_hits(5);

        // Select all
        let _ = app.update(CassMsg::SelectAllToggled);
        assert_eq!(app.selected.len(), 5);

        // Toggle again: clears all
        let _ = app.update(CassMsg::SelectAllToggled);
        assert!(app.selected.is_empty());
    }

    #[test]
    fn item_enqueued_adds_and_advances() {
        let mut app = app_with_hits(3);

        // Enqueue first item → selection moves to 1
        let _ = app.update(CassMsg::ItemEnqueued);
        assert_eq!(app.selected.len(), 1);
        assert!(
            app.selected
                .contains(&SelectedHitKey::from_hit(&app.panes[0].hits[0]))
        );
        assert_eq!(app.panes[0].selected, 1);

        // Enqueue again → adds second, advances to 2
        let _ = app.update(CassMsg::ItemEnqueued);
        assert_eq!(app.selected.len(), 2);
        assert_eq!(app.panes[0].selected, 2);

        // Enqueue at end → no further advance (already at last)
        let _ = app.update(CassMsg::ItemEnqueued);
        assert_eq!(app.selected.len(), 3);
        assert_eq!(app.panes[0].selected, 2); // stays at last
    }

    #[test]
    fn selection_survives_reranking() {
        let mut app = app_with_hits(3);
        // Select item 1
        let _ = app.update(CassMsg::SelectionMoved { delta: 1 });
        let _ = app.update(CassMsg::SelectionToggled);
        let key = SelectedHitKey::from_hit(&app.panes[0].hits[1]);
        assert!(app.selected.contains(&key));

        // Simulate reranking by swapping items 0 and 1
        app.panes[0].hits.swap(0, 1);

        // The key should still match the same hit regardless of position
        assert!(app.selected.contains(&key));
        // And the hit at position 0 (formerly at position 1) should still match
        assert!(
            app.selected
                .contains(&SelectedHitKey::from_hit(&app.panes[0].hits[0]))
        );
    }

    #[test]
    fn open_confirm_armed_resets_on_selection_change() {
        let mut app = app_with_hits(3);
        app.open_confirm_armed = true;

        let _ = app.update(CassMsg::SelectionToggled);
        assert!(!app.open_confirm_armed);

        app.open_confirm_armed = true;
        let _ = app.update(CassMsg::SelectAllToggled);
        assert!(!app.open_confirm_armed);

        app.open_confirm_armed = true;
        let _ = app.update(CassMsg::ItemEnqueued);
        assert!(!app.open_confirm_armed);
    }

    #[test]
    fn bulk_modal_opens_and_closes() {
        let mut app = app_with_hits(3);
        assert!(!app.show_bulk_modal);

        // Must select something first — guard prevents opening with empty selection
        let _ = app.update(CassMsg::SelectAllToggled);
        let _ = app.update(CassMsg::BulkActionsOpened);
        assert!(app.show_bulk_modal);
        assert_eq!(app.bulk_action_idx, 0);

        let _ = app.update(CassMsg::BulkActionsClosed);
        assert!(!app.show_bulk_modal);
    }

    #[test]
    fn bulk_modal_refuses_to_open_with_empty_selection() {
        let mut app = app_with_hits(3);
        let _ = app.update(CassMsg::BulkActionsOpened);
        assert!(!app.show_bulk_modal);
        assert!(app.status.contains("No items selected"));
    }

    #[test]
    fn bulk_modal_navigation_up_down() {
        let mut app = app_with_hits(3);
        let _ = app.update(CassMsg::SelectAllToggled);
        let _ = app.update(CassMsg::BulkActionsOpened);

        // Move down
        let _ = app.update(CassMsg::SelectionMoved { delta: 1 });
        assert_eq!(app.bulk_action_idx, 1);

        let _ = app.update(CassMsg::SelectionMoved { delta: 1 });
        assert_eq!(app.bulk_action_idx, 2);

        let _ = app.update(CassMsg::SelectionMoved { delta: 1 });
        assert_eq!(app.bulk_action_idx, 3); // last item (0-indexed, 4 items)

        // No overflow
        let _ = app.update(CassMsg::SelectionMoved { delta: 1 });
        assert_eq!(app.bulk_action_idx, 3);

        // Move back up
        let _ = app.update(CassMsg::SelectionMoved { delta: -1 });
        assert_eq!(app.bulk_action_idx, 2);

        // No underflow
        let _ = app.update(CassMsg::SelectionMoved { delta: -1 });
        let _ = app.update(CassMsg::SelectionMoved { delta: -1 });
        let _ = app.update(CassMsg::SelectionMoved { delta: -1 });
        assert_eq!(app.bulk_action_idx, 0);
    }

    #[test]
    fn bulk_clear_selection_clears_and_shows_status() {
        let mut app = app_with_hits(3);
        let _ = app.update(CassMsg::SelectAllToggled);
        assert_eq!(app.selected.len(), 3);

        let _ = app.update(CassMsg::BulkActionExecuted { action_index: 3 });
        assert!(app.selected.is_empty());
        assert!(app.status.contains("Cleared 3"));
    }

    #[test]
    fn open_all_queued_empty_shows_message() {
        let mut app = app_with_hits(3);
        // No items selected
        let _ = app.update(CassMsg::OpenAllQueued);
        assert!(app.status.contains("No items queued"));
    }

    #[test]
    fn open_all_queued_large_batch_requires_confirmation() {
        let mut app = app_with_hits(15);
        // Select all 15
        let _ = app.update(CassMsg::SelectAllToggled);
        assert_eq!(app.selected.len(), 15);

        // First press: arms confirmation
        let _ = app.update(CassMsg::OpenAllQueued);
        assert!(app.open_confirm_armed);
        assert!(app.status.contains("again to confirm"));
        // Selection NOT cleared yet
        assert_eq!(app.selected.len(), 15);
    }

    #[test]
    fn open_all_queued_small_batch_opens_directly() {
        let mut app = app_with_hits(3);
        let _ = app.update(CassMsg::SelectAllToggled);
        assert_eq!(app.selected.len(), 3);

        // Small batch (< threshold) — opens directly (will fail with editor error, but
        // selection should be cleared)
        let _ = app.update(CassMsg::OpenAllQueued);
        // Selection cleared after attempt
        assert!(app.selected.is_empty());
        assert!(!app.open_confirm_armed);
    }

    #[test]
    fn selected_hits_collects_matching_pane_hits() {
        let mut app = app_with_hits(5);
        // Enqueue items 0, 2, 4
        let _ = app.update(CassMsg::ItemEnqueued); // item 0, advances to 1
        let _ = app.update(CassMsg::SelectionMoved { delta: 1 }); // now at 2
        let _ = app.update(CassMsg::ItemEnqueued); // item 2, advances to 3
        let _ = app.update(CassMsg::SelectionMoved { delta: 1 }); // now at 4
        let _ = app.update(CassMsg::ItemEnqueued); // item 4
        assert_eq!(app.selected.len(), 3);

        let hits = app.selected_hits();
        assert_eq!(hits.len(), 3);
        let paths: HashSet<String> = hits.iter().map(|h| h.source_path.clone()).collect();
        assert!(paths.contains("/path/0"));
        assert!(paths.contains("/path/2"));
        assert!(paths.contains("/path/4"));
    }

    #[test]
    fn bulk_modal_esc_closes_without_executing() {
        let mut app = app_with_hits(3);
        let _ = app.update(CassMsg::SelectAllToggled);
        let _ = app.update(CassMsg::BulkActionsOpened);
        assert!(app.show_bulk_modal);

        // Esc closes the modal
        let _ = app.update(CassMsg::QuitRequested);
        assert!(!app.show_bulk_modal);
        // Selection not cleared
        assert_eq!(app.selected.len(), 3);
    }

    #[test]
    fn bulk_modal_renders_without_panic() {
        use ftui_harness::buffer_to_text;

        let mut app = app_with_hits(3);
        let _ = app.update(CassMsg::SelectAllToggled);
        let _ = app.update(CassMsg::BulkActionsOpened);
        let buf = render_at_degradation(&app, 80, 24, ftui::render::budget::DegradationLevel::Full);
        let text = buffer_to_text(&buf);
        assert!(text.contains("Bulk Actions"));
    }

    // =====================================================================
    // 2noh9.6.3 — Final UI polish
    // =====================================================================

    #[test]
    fn render_80x24_no_panic() {
        let app = CassApp::default();
        let buf = render_at_degradation(&app, 80, 24, ftui::render::budget::DegradationLevel::Full);
        let text = ftui_harness::buffer_to_text(&buf);
        assert!(text.contains("cass"), "should show app title");
        assert!(
            text.contains("med-n"),
            "80-col should show medium-narrow breakpoint"
        );
    }

    #[test]
    fn render_40x12_no_panic() {
        // Extreme small terminal — must not panic
        let app = CassApp::default();
        let _buf =
            render_at_degradation(&app, 40, 12, ftui::render::budget::DegradationLevel::Full);
    }

    #[test]
    fn render_1x1_no_panic() {
        // Degenerate case
        let app = CassApp::default();
        let _buf = render_at_degradation(&app, 1, 1, ftui::render::budget::DegradationLevel::Full);
    }

    #[test]
    fn status_footer_adapts_to_width() {
        let app = CassApp::default();

        // Wide: shows richer contextual hints.
        let wide_text = ftui_harness::buffer_to_text(&render_at_degradation(
            &app,
            120,
            24,
            ftui::render::budget::DegradationLevel::Full,
        ));
        assert!(
            wide_text.contains("Enter=open"),
            "wide footer should show contextual open hint"
        );

        // MediumNarrow: still shows at least one contextual hint.
        let medium_narrow_text = ftui_harness::buffer_to_text(&render_at_degradation(
            &app,
            90,
            24,
            ftui::render::budget::DegradationLevel::Full,
        ));
        assert!(
            medium_narrow_text.contains("Enter=open"),
            "medium-narrow footer should keep essential contextual hints"
        );

        // Narrow: hints collapse to keep the status compact.
        let narrow_text = ftui_harness::buffer_to_text(&render_at_degradation(
            &app,
            60,
            24,
            ftui::render::budget::DegradationLevel::Full,
        ));
        assert!(
            !narrow_text.contains("Enter=open"),
            "narrow footer should omit contextual hints"
        );
    }

    #[test]
    fn status_footer_hud_surfaces_progress_perf_cache_and_degradation_signals() {
        use ftui::render::budget::DegradationLevel;
        use ftui_harness::buffer_to_text;

        let mut app = app_with_hits(3);
        app.status = "indexing 3/9".to_string();
        app.last_search_ms = Some(42);
        app.cached_detail = Some((
            "/test/session.jsonl".to_string(),
            make_test_conversation_view(),
        ));

        let text = buffer_to_text(&render_at_degradation(
            &app,
            120,
            24,
            DegradationLevel::SimpleBorders,
        ));
        assert!(
            text.contains("status:indexing 3/9"),
            "footer should surface progress/status lane"
        );
        assert!(
            text.contains("perf:lat:42ms cache:warm"),
            "footer should surface perf+cache lane"
        );
        assert!(
            text.contains("runtime:deg:SimpleBorders"),
            "footer should surface degradation state lane"
        );
    }

    #[test]
    fn status_footer_hud_truncates_to_core_lanes_on_narrow_widths() {
        use ftui_harness::buffer_to_text;

        let app = app_with_hits(3);
        let text = buffer_to_text(&render_at_degradation(
            &app,
            50,
            24,
            ftui::render::budget::DegradationLevel::Full,
        ));
        assert!(text.contains("hits:3"), "narrow footer keeps hits lane");
        assert!(text.contains("query:"), "narrow footer keeps query lane");
        assert!(
            !text.contains("scope:"),
            "narrow footer should drop lower-priority scope lane"
        );
        assert!(
            !text.contains("runtime:"),
            "narrow footer should drop lower-priority runtime lane"
        );
    }

    #[test]
    fn contextual_footer_hints_results_include_search_mode_cycle() {
        let app = app_with_hits(3);
        let hints = app.build_contextual_footer_hints(120);
        assert!(
            hints.contains("Alt+S=mode"),
            "results footer should advertise lexical/semantic/hybrid mode cycling"
        );
    }

    #[test]
    fn contextual_footer_hints_include_bulk_actions_when_selected() {
        let mut app = app_with_hits(3);
        let _ = app.update(CassMsg::SelectAllToggled);
        let hints = app.build_contextual_footer_hints(120);
        assert!(
            hints.contains("bulk"),
            "selected-state hints should surface bulk actions"
        );
        // Ctrl+O=open may be dropped when TOGGLE_SELECT label is long
        // enough to exhaust the 52-char footer hint budget at this width.
        assert!(hints.contains("select"));
    }

    #[test]
    fn contextual_footer_hints_switch_for_filter_mode() {
        let mut app = CassApp::default();
        app.input_mode = InputMode::Agent;
        let hints = app.build_contextual_footer_hints(120);
        assert!(hints.contains("Enter=apply"));
        assert!(hints.contains("Esc=cancel"));
    }

    #[test]
    fn contextual_footer_hints_switch_for_analytics_surface() {
        let mut app = CassApp::default();
        app.surface = AppSurface::Analytics;
        let hints = app.build_contextual_footer_hints(120);
        assert!(hints.contains("←/→=views"));
        assert!(hints.contains("Esc=back"));
    }

    #[test]
    fn contextual_footer_hints_analytics_dashboard_no_special_keys() {
        let mut app = CassApp::default();
        app.surface = AppSurface::Analytics;
        app.analytics_view = AnalyticsView::Dashboard;
        let hints = app.build_contextual_footer_hints(120);
        assert!(hints.contains("←/→=views"));
        // Dashboard is read-only — no metric/overlay/tab hints
        assert!(!hints.contains("m=metric"));
        assert!(!hints.contains("Tab=tab"));
    }

    #[test]
    fn contextual_footer_hints_analytics_explorer_shows_controls() {
        let mut app = CassApp::default();
        app.surface = AppSurface::Analytics;
        app.analytics_view = AnalyticsView::Explorer;
        let hints = app.build_contextual_footer_hints(120);
        assert!(hints.contains("←/→=views"), "missing views hint");
        assert!(hints.contains("m=metric"), "missing metric hint");
        assert!(hints.contains("o=overlay"), "missing overlay hint");
        assert!(hints.contains("g=group"), "missing group hint");
    }

    #[test]
    fn contextual_footer_hints_analytics_heatmap_shows_tab_metric() {
        let mut app = CassApp::default();
        app.surface = AppSurface::Analytics;
        app.analytics_view = AnalyticsView::Heatmap;
        let hints = app.build_contextual_footer_hints(120);
        assert!(hints.contains("←/→=views"));
        assert!(
            hints.contains("Tab=metric"),
            "missing metric hint for heatmap"
        );
    }

    #[test]
    fn contextual_footer_hints_analytics_breakdowns_shows_tab() {
        let mut app = CassApp::default();
        app.surface = AppSurface::Analytics;
        app.analytics_view = AnalyticsView::Breakdowns;
        let hints = app.build_contextual_footer_hints(120);
        assert!(hints.contains("←/→=views"));
        assert!(hints.contains("Tab=tab"), "missing tab hint for breakdowns");
    }

    #[test]
    fn contextual_footer_hints_analytics_context_key_per_subview() {
        let mut app = CassApp::default();
        app.surface = AppSurface::Analytics;

        for (view, expected_key) in [
            (AnalyticsView::Dashboard, "analytics:dashboard"),
            (AnalyticsView::Explorer, "analytics:explorer"),
            (AnalyticsView::Heatmap, "analytics:heatmap"),
            (AnalyticsView::Breakdowns, "analytics:breakdowns"),
            (AnalyticsView::Tools, "analytics:tools"),
            (AnalyticsView::Plans, "analytics:plans"),
            (AnalyticsView::Coverage, "analytics:coverage"),
        ] {
            app.analytics_view = view;
            assert_eq!(
                app.footer_hint_context_key(),
                expected_key,
                "wrong context key for {:?}",
                view
            );
        }
    }

    #[test]
    fn search_title_adapts_to_width() {
        let app = CassApp::default();

        // Wide: shows theme name
        let wide_text = ftui_harness::buffer_to_text(&render_at_degradation(
            &app,
            100,
            24,
            ftui::render::budget::DegradationLevel::Full,
        ));
        assert!(
            wide_text.contains("Dark") || wide_text.contains("Light"),
            "wide search title should show theme preset name"
        );

        // Narrow: just mode
        let narrow_text = ftui_harness::buffer_to_text(&render_at_degradation(
            &app,
            60,
            24,
            ftui::render::budget::DegradationLevel::Full,
        ));
        assert!(
            narrow_text.contains("lexical"),
            "narrow search title should show mode"
        );
    }

    #[test]
    fn search_title_and_caret_render_across_core_presets() {
        use ftui_harness::buffer_to_text;
        let presets = [
            UiThemePreset::Dark,
            UiThemePreset::Light,
            UiThemePreset::HighContrast,
        ];

        for preset in presets {
            let mut app = CassApp::default();
            app.theme_preset = preset;
            app.style_options.preset = preset;
            app.theme_dark = !matches!(preset, UiThemePreset::Light);
            app.style_options.dark_mode = app.theme_dark;

            let medium_text = buffer_to_text(&render_at_degradation(
                &app,
                100,
                24,
                ftui::render::budget::DegradationLevel::Full,
            ));
            assert!(
                medium_text.contains(preset.name()),
                "medium title should include preset name for {:?}",
                preset
            );
            assert!(
                medium_text.contains("<type to search>") && medium_text.contains("│"),
                "query row should include placeholder and caret for {:?}",
                preset
            );

            let narrow_text = buffer_to_text(&render_at_degradation(
                &app,
                60,
                24,
                ftui::render::budget::DegradationLevel::Full,
            ));
            assert!(
                narrow_text.contains("mode:lexical"),
                "narrow title should include explicit mode token for {:?}",
                preset
            );
            assert!(
                narrow_text.contains("match:standard"),
                "narrow title should include explicit match token for {:?}",
                preset
            );
        }
    }

    #[test]
    fn results_title_shows_selection_count() {
        let mut app = app_with_hits(3);
        let _ = app.update(CassMsg::SelectAllToggled);
        let text = ftui_harness::buffer_to_text(&render_at_degradation(
            &app,
            120,
            24,
            ftui::render::budget::DegradationLevel::Full,
        ));
        assert!(
            text.contains("selected"),
            "results title should show selection count when items selected"
        );
    }

    #[test]
    fn analytics_header_adapts_to_width() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::AnalyticsEntered);

        // Wide: shows all view tabs
        let wide_text = ftui_harness::buffer_to_text(&render_at_degradation(
            &app,
            120,
            24,
            ftui::render::budget::DegradationLevel::Full,
        ));
        assert!(
            wide_text.contains("Dashboard"),
            "wide analytics should show view tabs"
        );

        // Narrow: just current view
        let narrow_text = ftui_harness::buffer_to_text(&render_at_degradation(
            &app,
            70,
            24,
            ftui::render::budget::DegradationLevel::Full,
        ));
        assert!(
            narrow_text.contains("analytics"),
            "narrow analytics should show label"
        );
    }

    #[test]
    fn adaptive_borders_reach_results_and_detail_panes() {
        use ftui::render::budget::DegradationLevel;
        use ftui_harness::buffer_to_text;

        let app = CassApp::default();

        // At EssentialOnly, borders should be dropped from all panes
        let essential = buffer_to_text(&render_at_degradation(
            &app,
            120,
            24,
            DegradationLevel::EssentialOnly,
        ));
        let full = buffer_to_text(&render_at_degradation(
            &app,
            120,
            24,
            DegradationLevel::Full,
        ));

        // Full should have more border characters than EssentialOnly
        let full_border_chars = full
            .chars()
            .filter(|c| matches!(c, '─' | '│' | '┌' | '┐' | '└' | '┘' | '╭' | '╮' | '╯' | '╰'))
            .count();
        let essential_border_chars = essential
            .chars()
            .filter(|c| matches!(c, '─' | '│' | '┌' | '┐' | '└' | '┘' | '╭' | '╮' | '╯' | '╰'))
            .count();
        assert!(
            full_border_chars > essential_border_chars,
            "EssentialOnly should have fewer border characters than Full (full={full_border_chars}, essential={essential_border_chars})"
        );
    }

    // ==================== Mouse support tests ====================

    #[test]
    fn hit_regions_recorded_after_render() {
        let app = app_with_hits(5);
        render_at_degradation(&app, 120, 24, ftui::render::budget::DegradationLevel::Full);

        assert!(
            app.last_search_bar_area.borrow().is_some(),
            "search bar area should be recorded"
        );
        assert!(
            app.last_results_inner.borrow().is_some(),
            "results inner area should be recorded"
        );
        assert!(
            app.last_status_area.borrow().is_some(),
            "status area should be recorded"
        );
    }

    #[test]
    fn hit_regions_include_detail_pane_in_wide_layout() {
        let app = app_with_hits(5);
        render_at_degradation(&app, 120, 24, ftui::render::budget::DegradationLevel::Full);

        assert!(
            app.last_detail_area.borrow().is_some(),
            "detail area should be recorded in wide layout"
        );
    }

    #[test]
    fn hit_test_returns_results_for_results_inner() {
        let app = app_with_hits(5);
        render_at_degradation(&app, 120, 24, ftui::render::budget::DegradationLevel::Full);

        let inner = app.last_results_inner.borrow().unwrap();
        let region = app.hit_test(inner.x, inner.y);
        assert!(
            matches!(
                region,
                MouseHitRegion::Results {
                    pane_idx: 0,
                    item_idx: 0
                }
            ),
            "click at results origin should return Results(pane=0,row=0), got {region:?}"
        );
    }

    #[test]
    fn wide_layout_records_multiple_visible_pane_rects() {
        let app = app_with_rich_visual_fixture();
        render_at_degradation(&app, 180, 32, ftui::render::budget::DegradationLevel::Full);

        let pane_rects = app.last_pane_rects.borrow();
        assert!(
            pane_rects.len() >= 3,
            "wide layout should show multiple side-by-side panes, got {}",
            pane_rects.len()
        );
    }

    #[test]
    fn mouse_click_in_non_active_pane_switches_active_pane() {
        use ftui::Model;
        let mut app = app_with_rich_visual_fixture();
        app.active_pane = 0;
        render_at_degradation(&app, 180, 32, ftui::render::budget::DegradationLevel::Full);

        let first_idx = *app.last_pane_first_index.borrow();
        let pane_rects = app.last_pane_rects.borrow().clone();
        assert!(
            pane_rects.len() >= 2,
            "test fixture should render at least two panes"
        );
        let target = pane_rects[1];
        let _ = app.update(CassMsg::MouseEvent {
            kind: MouseEventKind::LeftClick,
            x: target.x.saturating_add(2),
            y: target.y.saturating_add(2),
        });
        assert_eq!(
            app.active_pane,
            first_idx + 1,
            "clicking a non-active pane should switch active pane"
        );
    }

    #[test]
    fn hit_test_returns_detail_for_detail_area() {
        let app = app_with_hits(5);
        render_at_degradation(&app, 120, 24, ftui::render::budget::DegradationLevel::Full);

        let detail = app.last_detail_area.borrow().unwrap();
        let region = app.hit_test(detail.x + 1, detail.y + 1);
        assert_eq!(region, MouseHitRegion::Detail);
    }

    #[test]
    fn hit_test_returns_search_bar_for_top_row() {
        let app = app_with_hits(5);
        render_at_degradation(&app, 120, 24, ftui::render::budget::DegradationLevel::Full);

        let search = app.last_search_bar_area.borrow().unwrap();
        let region = app.hit_test(search.x + 1, search.y);
        assert_eq!(region, MouseHitRegion::SearchBar);
    }

    #[test]
    fn mouse_left_click_on_agent_pill_enters_agent_input_mode() {
        use ftui::Model;
        let mut app = app_with_hits(5);
        app.filters.agents.insert("codex".to_string());
        render_at_degradation(&app, 120, 24, ftui::render::budget::DegradationLevel::Full);

        let rect = app
            .last_pill_rects
            .borrow()
            .iter()
            .find_map(|(rect, pill)| (pill.label == "agent").then_some(*rect))
            .expect("agent pill should be rendered");

        let _ = app.update(CassMsg::MouseEvent {
            kind: MouseEventKind::LeftClick,
            x: rect.x,
            y: rect.y,
        });
        assert_eq!(app.input_mode, InputMode::Agent);
    }

    #[test]
    fn mouse_right_click_on_agent_pill_clears_agent_filter() {
        use ftui::Model;
        let mut app = app_with_hits(5);
        app.filters.agents.insert("codex".to_string());
        render_at_degradation(&app, 120, 24, ftui::render::budget::DegradationLevel::Full);

        let rect = app
            .last_pill_rects
            .borrow()
            .iter()
            .find_map(|(rect, pill)| (pill.label == "agent").then_some(*rect))
            .expect("agent pill should be rendered");

        let _ = app.update(CassMsg::MouseEvent {
            kind: MouseEventKind::RightClick,
            x: rect.x,
            y: rect.y,
        });
        assert!(
            app.filters.agents.is_empty(),
            "right-click on agent pill should clear agent filter"
        );
        assert!(
            app.search_dirty_since.is_some(),
            "clearing a filter should trigger a debounced search"
        );
    }

    #[test]
    fn filter_pills_include_inactive_slots() {
        let app = app_with_hits(5);
        // No filters set — all slot pills should be inactive
        let pills = app.filter_pills();
        assert!(
            pills.len() >= 4,
            "should have at least 4 filter slot pills (agent, ws, time, source)"
        );
        assert!(
            pills.iter().all(|p| !p.active),
            "with no filters set, all pills should be inactive"
        );
    }

    #[test]
    fn filter_pills_mark_active_filters() {
        let mut app = app_with_hits(5);
        app.filters.agents.insert("codex".to_string());
        let pills = app.filter_pills();
        let agent_pill = pills.iter().find(|p| p.label == "agent").unwrap();
        assert!(
            agent_pill.active,
            "agent pill should be active when filter is set"
        );
        let ws_pill = pills.iter().find(|p| p.label == "ws").unwrap();
        assert!(
            !ws_pill.active,
            "ws pill should be inactive when filter is not set"
        );
    }

    #[test]
    fn build_pills_row_produces_per_pill_spans() {
        let app = app_with_hits(5);
        let active = ftui::Style::new().fg(ftui::render::cell::PackedRgba::rgba(255, 0, 0, 255));
        let inactive =
            ftui::Style::new().fg(ftui::render::cell::PackedRgba::rgba(128, 128, 128, 255));
        let label = ftui::Style::new().fg(ftui::render::cell::PackedRgba::rgba(200, 200, 200, 255));
        let sep = ftui::Style::new();
        let pills = vec![
            Pill {
                label: "agent".into(),
                value: "codex".into(),
                active: true,
                editable: true,
            },
            Pill {
                label: "ws".into(),
                value: "any".into(),
                active: false,
                editable: true,
            },
        ];
        let area = Rect::new(0, 0, 80, 1);
        let (line, rects) = app.build_pills_row(area, &pills, active, inactive, label, sep);
        assert_eq!(rects.len(), 2, "should have 2 pill rects");
        // The line should have spans — label + value for each pill, plus separator
        let spans = line.spans();
        assert!(
            spans.len() >= 4,
            "should have at least 4 spans (label+value per pill), got {}",
            spans.len()
        );
        let agent_label = spans
            .iter()
            .find(|sp| sp.content.contains("[agent:"))
            .expect("agent label span should be present");
        assert_eq!(
            agent_label.style.as_ref().cloned(),
            Some(label.underline()),
            "active editable label should use label style with underline"
        );
        let ws_label = spans
            .iter()
            .find(|sp| sp.content.contains("[ws:"))
            .expect("ws label span should be present");
        assert_eq!(
            ws_label.style.as_ref().cloned(),
            Some(inactive.underline()),
            "inactive editable label should use inactive style with underline"
        );

        let active_value = spans
            .iter()
            .find(|sp| sp.content.contains("codex]"))
            .expect("active value span should be present");
        assert_eq!(
            active_value.style.as_ref().cloned(),
            Some(active.italic()),
            "active editable value should use active style + italic"
        );
        let inactive_value = spans
            .iter()
            .find(|sp| sp.content.contains("any]"))
            .expect("inactive value span should be present");
        assert_eq!(
            inactive_value.style.as_ref().cloned(),
            Some(inactive.italic()),
            "inactive editable value should use inactive style + italic"
        );
    }

    #[test]
    fn build_pills_row_underlines_only_editable_labels() {
        let app = app_with_hits(5);
        let active = ftui::Style::new().fg(ftui::render::cell::PackedRgba::rgba(255, 0, 0, 255));
        let inactive =
            ftui::Style::new().fg(ftui::render::cell::PackedRgba::rgba(128, 128, 128, 255));
        let label = ftui::Style::new().fg(ftui::render::cell::PackedRgba::rgba(200, 200, 200, 255));
        let sep = ftui::Style::new();
        let pills = vec![
            Pill {
                label: "edit".into(),
                value: "yes".into(),
                active: true,
                editable: true,
            },
            Pill {
                label: "fixed".into(),
                value: "no".into(),
                active: true,
                editable: false,
            },
        ];
        let area = Rect::new(0, 0, 80, 1);
        let (line, _rects) = app.build_pills_row(area, &pills, active, inactive, label, sep);
        let spans = line.spans();
        let editable_label = spans
            .iter()
            .find(|sp| sp.content.contains("[edit:"))
            .expect("editable label span should be present");
        assert_eq!(
            editable_label.style.as_ref().cloned(),
            Some(label.underline()),
            "editable label should be underlined"
        );
        let fixed_label = spans
            .iter()
            .find(|sp| sp.content.contains("[fixed:"))
            .expect("readonly label span should be present");
        assert_eq!(
            fixed_label.style.as_ref().cloned(),
            Some(label),
            "readonly label should not be underlined"
        );
    }

    #[test]
    fn editable_pill_values_are_italic() {
        let app = app_with_hits(5);
        let active = ftui::Style::new().fg(ftui::render::cell::PackedRgba::rgba(255, 0, 0, 255));
        let inactive =
            ftui::Style::new().fg(ftui::render::cell::PackedRgba::rgba(128, 128, 128, 255));
        let label = ftui::Style::new().fg(ftui::render::cell::PackedRgba::rgba(200, 200, 200, 255));
        let sep = ftui::Style::new();
        let pills = vec![
            Pill {
                label: "agent".into(),
                value: "codex".into(),
                active: true,
                editable: true,
            },
            Pill {
                label: "ws".into(),
                value: "any".into(),
                active: false,
                editable: true,
            },
            Pill {
                label: "fixed".into(),
                value: "frozen".into(),
                active: true,
                editable: false,
            },
        ];
        let area = Rect::new(0, 0, 120, 1);
        let (line, _) = app.build_pills_row(area, &pills, active, inactive, label, sep);
        let spans = line.spans();

        // Active + editable value should be italic
        let active_val = spans
            .iter()
            .find(|sp| sp.content.contains("codex]"))
            .expect("active editable value span should be present");
        assert_eq!(
            active_val.style.as_ref().cloned(),
            Some(active.italic()),
            "editable active value should have italic modifier"
        );

        // Inactive + editable value should be italic
        let inactive_val = spans
            .iter()
            .find(|sp| sp.content.contains("any]"))
            .expect("inactive editable value span should be present");
        assert_eq!(
            inactive_val.style.as_ref().cloned(),
            Some(inactive.italic()),
            "editable inactive value should have italic modifier"
        );

        // Non-editable value should NOT be italic
        let fixed_val = spans
            .iter()
            .find(|sp| sp.content.contains("frozen]"))
            .expect("non-editable value span should be present");
        assert_eq!(
            fixed_val.style.as_ref().cloned(),
            Some(active),
            "non-editable active value should not have italic modifier"
        );
    }

    #[test]
    fn editable_inactive_pill_shows_pencil_glyph() {
        let app = app_with_hits(5);
        let active = ftui::Style::new().fg(ftui::render::cell::PackedRgba::rgba(255, 0, 0, 255));
        let inactive =
            ftui::Style::new().fg(ftui::render::cell::PackedRgba::rgba(128, 128, 128, 255));
        let label = ftui::Style::new().fg(ftui::render::cell::PackedRgba::rgba(200, 200, 200, 255));
        let sep = ftui::Style::new();
        let pills = vec![
            Pill {
                label: "ws".into(),
                value: "any".into(),
                active: false,
                editable: true,
            },
            Pill {
                label: "agent".into(),
                value: "codex".into(),
                active: true,
                editable: true,
            },
        ];
        let area = Rect::new(0, 0, 120, 1);
        let (line, _) = app.build_pills_row(area, &pills, active, inactive, label, sep);
        let spans = line.spans();

        // Inactive editable pill should include the pencil glyph span
        let pencil = spans.iter().find(|sp| sp.content.contains('\u{270E}'));
        assert!(
            pencil.is_some(),
            "editable inactive pill should include pencil glyph cue"
        );

        // Active editable pill should NOT include pencil glyph (only inactive gets it)
        let all_pencils: Vec<_> = spans
            .iter()
            .filter(|sp| sp.content.contains('\u{270E}'))
            .collect();
        assert_eq!(
            all_pencils.len(),
            1,
            "only the inactive editable pill should have a pencil glyph, not the active one"
        );
    }

    #[test]
    fn non_editable_pill_has_no_pencil_glyph() {
        let app = app_with_hits(5);
        let active = ftui::Style::new().fg(ftui::render::cell::PackedRgba::rgba(255, 0, 0, 255));
        let inactive =
            ftui::Style::new().fg(ftui::render::cell::PackedRgba::rgba(128, 128, 128, 255));
        let label = ftui::Style::new().fg(ftui::render::cell::PackedRgba::rgba(200, 200, 200, 255));
        let sep = ftui::Style::new();
        let pills = vec![Pill {
            label: "static".into(),
            value: "on".into(),
            active: false,
            editable: false,
        }];
        let area = Rect::new(0, 0, 120, 1);
        let (line, _) = app.build_pills_row(area, &pills, active, inactive, label, sep);
        let spans = line.spans();
        let pencil = spans.iter().find(|sp| sp.content.contains('\u{270E}'));
        assert!(
            pencil.is_none(),
            "non-editable pill should not have a pencil glyph"
        );
    }

    #[test]
    fn pill_hit_rects_account_for_pencil_glyph_width() {
        let app = app_with_hits(5);
        let active = ftui::Style::new().fg(ftui::render::cell::PackedRgba::rgba(255, 0, 0, 255));
        let inactive =
            ftui::Style::new().fg(ftui::render::cell::PackedRgba::rgba(128, 128, 128, 255));
        let label = ftui::Style::new().fg(ftui::render::cell::PackedRgba::rgba(200, 200, 200, 255));
        let sep = ftui::Style::new();
        let pills = vec![
            Pill {
                label: "ws".into(),
                value: "any".into(),
                active: false,
                editable: true,
            },
            Pill {
                label: "agent".into(),
                value: "codex".into(),
                active: true,
                editable: true,
            },
        ];
        let area = Rect::new(0, 0, 120, 1);
        let (_, rects) = app.build_pills_row(area, &pills, active, inactive, label, sep);
        assert_eq!(rects.len(), 2);

        // The inactive editable pill (ws) should have rect width = "[ws:any]".len() + 1 for pencil
        let ws_rect = &rects[0].0;
        let base_len = "[ws:any]".len() as u16;
        assert_eq!(
            ws_rect.width,
            base_len + 1,
            "inactive editable pill rect should include 1 extra char for pencil glyph"
        );

        // The active editable pill (agent) should NOT have the extra width
        let agent_rect = &rects[1].0;
        let agent_base_len = "[agent:codex]".len() as u16;
        assert_eq!(
            agent_rect.width, agent_base_len,
            "active editable pill rect should not include pencil glyph width"
        );

        // Second pill starts after first pill + separator
        assert_eq!(
            agent_rect.x,
            ws_rect.x + ws_rect.width + 1,
            "second pill x should follow first pill + 1 separator char"
        );
    }

    #[test]
    fn inactive_pill_click_opens_editor() {
        use ftui::Model;
        // With no agent filter set, clicking the inactive "agent:any" pill should open agent editor
        let mut app = app_with_hits(5);
        render_at_degradation(&app, 120, 24, ftui::render::budget::DegradationLevel::Full);
        let rect = app
            .last_pill_rects
            .borrow()
            .iter()
            .find_map(|(rect, pill)| (pill.label == "agent").then_some(*rect))
            .expect("agent pill should be rendered even when inactive");
        let _ = app.update(CassMsg::MouseEvent {
            kind: MouseEventKind::LeftClick,
            x: rect.x,
            y: rect.y,
        });
        assert_eq!(
            app.input_mode,
            InputMode::Agent,
            "clicking inactive agent pill should enter agent input mode"
        );
    }

    #[test]
    fn hit_test_returns_none_outside_all_regions() {
        let app = CassApp::default();
        let region = app.hit_test(0, 0);
        assert_eq!(region, MouseHitRegion::None);
    }

    #[test]
    fn hit_test_returns_split_handle_when_present() {
        let app = app_with_hits(5);
        render_at_degradation(&app, 180, 24, ftui::render::budget::DegradationLevel::Full);

        let handle = app
            .last_split_handle_area
            .borrow()
            .as_ref()
            .copied()
            .expect("split handle should be recorded in wide layout");
        let region = app.hit_test(handle.x, handle.y);
        assert_eq!(region, MouseHitRegion::SplitHandle);
    }

    #[test]
    fn mouse_click_in_results_moves_selection() {
        use ftui::Model;
        let mut app = app_with_hits(10);
        render_at_degradation(&app, 120, 24, ftui::render::budget::DegradationLevel::Full);

        let inner = app.last_results_inner.borrow().unwrap();
        let row_h = app.density_mode.row_height();
        let target_y = inner.y + row_h * 2;
        let cmd = app.update(CassMsg::MouseEvent {
            kind: MouseEventKind::LeftClick,
            x: inner.x + 1,
            y: target_y,
        });
        assert!(
            !matches!(cmd, ftui::Cmd::None),
            "clicking a non-selected row should produce a command"
        );
    }

    #[test]
    fn mouse_click_in_results_restores_results_navigation_context() {
        use ftui::Model;
        let mut app = app_with_hits(10);
        app.input_mode = InputMode::Agent;
        app.input_buffer = "codex".to_string();
        app.focus_manager.focus(focus_ids::SEARCH_BAR);
        render_at_degradation(&app, 120, 24, ftui::render::budget::DegradationLevel::Full);

        let inner = app.last_results_inner.borrow().unwrap();
        let row_h = app.density_mode.row_height();
        let target_y = inner.y + row_h * 2;
        let _ = app.update(CassMsg::MouseEvent {
            kind: MouseEventKind::LeftClick,
            x: inner.x + 1,
            y: target_y,
        });

        assert_eq!(
            app.focus_manager.current(),
            Some(focus_ids::RESULTS_LIST),
            "clicking a result row should leave focus in results context"
        );
        assert_eq!(
            app.input_mode,
            InputMode::Query,
            "result-row interaction should exit stale non-query input mode"
        );
        assert!(
            app.input_buffer.is_empty(),
            "stale input-mode buffer should be cleared when returning to results context"
        );
    }

    #[test]
    fn enter_after_mouse_result_click_opens_detail_from_stale_input_mode() {
        use ftui::Model;
        let mut app = app_with_hits(10);
        app.input_mode = InputMode::Agent;
        app.input_buffer = "codex".to_string();
        app.focus_manager.focus(focus_ids::SEARCH_BAR);
        render_at_degradation(&app, 120, 24, ftui::render::budget::DegradationLevel::Full);

        let inner = app.last_results_inner.borrow().unwrap();
        let row_h = app.density_mode.row_height();
        let target_y = inner.y + row_h * 2;
        let click_cmd = app.update(CassMsg::MouseEvent {
            kind: MouseEventKind::LeftClick,
            x: inner.x + 1,
            y: target_y,
        });
        for msg in extract_msgs(click_cmd) {
            let _ = app.update(msg);
        }

        let _ = app.update(CassMsg::DetailOpened);
        assert!(
            app.show_detail_modal,
            "Enter should open detail modal after result-row click even when starting from stale input mode"
        );
        assert_eq!(
            app.detail_tab,
            DetailTab::Messages,
            "Enter-open should land on contextual Messages tab"
        );
    }

    #[test]
    fn mouse_click_on_selected_row_opens_detail() {
        use ftui::Model;
        let mut app = app_with_hits(5);
        render_at_degradation(&app, 120, 24, ftui::render::budget::DegradationLevel::Full);

        let inner = app.last_results_inner.borrow().unwrap();
        let cmd = app.update(CassMsg::MouseEvent {
            kind: MouseEventKind::LeftClick,
            x: inner.x + 1,
            y: inner.y,
        });
        assert!(
            !matches!(cmd, ftui::Cmd::None),
            "clicking selected row should emit DetailOpened"
        );
    }

    #[test]
    fn mouse_right_click_in_results_toggles_selection() {
        use ftui::Model;
        let mut app = app_with_hits(5);
        render_at_degradation(&app, 120, 24, ftui::render::budget::DegradationLevel::Full);

        assert!(app.selected.is_empty());
        let inner = app.last_results_inner.borrow().unwrap();
        let cmd = app.update(CassMsg::MouseEvent {
            kind: MouseEventKind::RightClick,
            x: inner.x + 1,
            y: inner.y,
        });
        assert!(
            !matches!(cmd, ftui::Cmd::None),
            "right-click should produce toggle command"
        );
    }

    #[test]
    fn mouse_scroll_in_results_moves_selection() {
        use ftui::Model;
        let mut app = app_with_hits(20);
        render_at_degradation(&app, 120, 24, ftui::render::budget::DegradationLevel::Full);

        let inner = app.last_results_inner.borrow().unwrap();
        let cmd = app.update(CassMsg::MouseEvent {
            kind: MouseEventKind::ScrollDown,
            x: inner.x + 1,
            y: inner.y + 1,
        });
        assert!(
            !matches!(cmd, ftui::Cmd::None),
            "scroll in results should produce SelectionMoved"
        );
    }

    #[test]
    fn mouse_scroll_in_detail_scrolls_detail() {
        use ftui::Model;
        let mut app = app_with_hits(5);
        render_at_degradation(&app, 120, 24, ftui::render::budget::DegradationLevel::Full);

        let detail = app.last_detail_area.borrow().unwrap();
        let cmd = app.update(CassMsg::MouseEvent {
            kind: MouseEventKind::ScrollDown,
            x: detail.x + 1,
            y: detail.y + 1,
        });
        assert!(
            !matches!(cmd, ftui::Cmd::None),
            "scroll in detail should produce DetailScrolled"
        );
    }

    #[test]
    fn mouse_click_in_detail_focuses_detail() {
        use ftui::Model;
        let mut app = app_with_hits(5);
        render_at_degradation(&app, 120, 24, ftui::render::budget::DegradationLevel::Full);

        assert_eq!(app.focused_region(), FocusRegion::Results);
        let detail = app.last_detail_area.borrow().unwrap();
        let cmd = app.update(CassMsg::MouseEvent {
            kind: MouseEventKind::LeftClick,
            x: detail.x + 1,
            y: detail.y + 1,
        });
        assert!(
            !matches!(cmd, ftui::Cmd::None),
            "click in detail should emit FocusToggled"
        );
    }

    #[test]
    fn mouse_click_in_search_bar_focuses_results() {
        use ftui::Model;
        let mut app = app_with_hits(5);
        app.focus_manager.focus(focus_ids::DETAIL_PANE);
        render_at_degradation(&app, 120, 24, ftui::render::budget::DegradationLevel::Full);

        let search = app.last_search_bar_area.borrow().unwrap();
        let cmd = app.update(CassMsg::MouseEvent {
            kind: MouseEventKind::LeftClick,
            x: search.x + 1,
            y: search.y,
        });
        assert!(
            !matches!(cmd, ftui::Cmd::None),
            "click in search bar should emit FocusToggled"
        );
    }

    #[test]
    fn mouse_event_kind_has_right_click() {
        assert_ne!(MouseEventKind::LeftClick, MouseEventKind::RightClick);
        assert_ne!(MouseEventKind::RightClick, MouseEventKind::ScrollUp);
        assert_ne!(MouseEventKind::LeftDrag, MouseEventKind::LeftRelease);
    }

    #[test]
    fn mouse_drag_on_split_handle_updates_panel_ratio_target() {
        use ftui::Model;
        let mut app = app_with_hits(25);
        render_at_degradation(&app, 180, 24, ftui::render::budget::DegradationLevel::Full);

        let handle = app
            .last_split_handle_area
            .borrow()
            .as_ref()
            .copied()
            .expect("split handle should be recorded");
        let content = app
            .last_content_area
            .borrow()
            .as_ref()
            .copied()
            .expect("content area should be recorded");
        let start_ratio = app.anim.panel_ratio.target();
        let drag_x = content.x + content.width.saturating_mul(3) / 10;

        let _ = app.update(CassMsg::MouseEvent {
            kind: MouseEventKind::LeftClick,
            x: handle.x,
            y: handle.y,
        });
        let _ = app.update(CassMsg::MouseEvent {
            kind: MouseEventKind::LeftDrag,
            x: drag_x,
            y: handle.y,
        });
        let _ = app.update(CassMsg::MouseEvent {
            kind: MouseEventKind::LeftRelease,
            x: drag_x,
            y: handle.y,
        });

        let updated_ratio = app.anim.panel_ratio.target();
        assert!(
            (updated_ratio - start_ratio).abs() > 0.01,
            "panel ratio target should change after drag (before={start_ratio}, after={updated_ratio})"
        );
        assert!(
            app.pane_split_drag.is_none(),
            "split drag state should clear on release"
        );
    }

    #[test]
    fn saved_views_mouse_drag_reorders_rows() {
        use ftui::Model;

        let mut app = CassApp::default();
        app.saved_views = vec![
            SavedView {
                slot: 1,
                label: Some("One".to_string()),
                agents: HashSet::new(),
                workspaces: HashSet::new(),
                created_from: None,
                created_to: None,
                ranking: RankingMode::Balanced,
                source_filter: SourceFilter::All,
            },
            SavedView {
                slot: 2,
                label: Some("Two".to_string()),
                agents: HashSet::new(),
                workspaces: HashSet::new(),
                created_from: None,
                created_to: None,
                ranking: RankingMode::Balanced,
                source_filter: SourceFilter::All,
            },
            SavedView {
                slot: 3,
                label: Some("Three".to_string()),
                agents: HashSet::new(),
                workspaces: HashSet::new(),
                created_from: None,
                created_to: None,
                ranking: RankingMode::Balanced,
                source_filter: SourceFilter::All,
            },
        ];

        let _ = app.update(CassMsg::SavedViewsOpened);
        render_at_degradation(&app, 120, 30, ftui::render::budget::DegradationLevel::Full);

        let row_areas = app.last_saved_view_row_areas.borrow().clone();
        assert_eq!(row_areas.len(), 3, "should capture row areas for drag");
        let from = row_areas[0].0;
        let to = row_areas[2].0;

        let _ = app.update(CassMsg::MouseEvent {
            kind: MouseEventKind::LeftClick,
            x: from.x + 1,
            y: from.y,
        });
        let _ = app.update(CassMsg::MouseEvent {
            kind: MouseEventKind::LeftDrag,
            x: to.x + 1,
            y: to.y,
        });
        let _ = app.update(CassMsg::MouseEvent {
            kind: MouseEventKind::LeftRelease,
            x: to.x + 1,
            y: to.y,
        });

        let labels: Vec<String> = app
            .saved_views
            .iter()
            .map(|view| view.label.clone().unwrap_or_default())
            .collect();
        assert_eq!(labels, vec!["Two", "Three", "One"]);
        assert_eq!(app.saved_views_selection, 2);
        assert!(app.saved_view_drag.is_none());
    }

    #[test]
    fn hit_regions_cleared_on_analytics_surface() {
        let mut app = app_with_hits(5);
        render_at_degradation(&app, 120, 24, ftui::render::budget::DegradationLevel::Full);
        assert!(app.last_results_inner.borrow().is_some());

        app.surface = AppSurface::Analytics;
        render_at_degradation(&app, 120, 24, ftui::render::budget::DegradationLevel::Full);

        assert!(
            app.last_results_inner.borrow().is_none(),
            "results inner should be cleared on analytics surface"
        );
        assert!(
            app.last_detail_area.borrow().is_none(),
            "detail area should be cleared on analytics surface"
        );
        assert!(
            app.last_search_bar_area.borrow().is_none(),
            "search bar should be cleared on analytics surface"
        );
    }

    #[test]
    fn mouse_scroll_outside_regions_defaults_to_results() {
        use ftui::Model;
        let mut app = CassApp::default();
        let cmd = app.update(CassMsg::MouseEvent {
            kind: MouseEventKind::ScrollDown,
            x: 999,
            y: 999,
        });
        assert!(
            !matches!(cmd, ftui::Cmd::None),
            "scroll outside tracked regions should still produce SelectionMoved"
        );
    }

    // =========================================================================
    // Input smoothness (drag jitter / hover stabilization) tests
    // =========================================================================

    #[test]
    fn drag_jitter_filter_suppresses_small_movements() {
        use ftui::Model;
        let mut app = CassApp::default();
        // Simulate initial click at (50, 10)
        let _ = app.update(CassMsg::MouseEvent {
            kind: MouseEventKind::LeftClick,
            x: 50,
            y: 10,
        });
        assert_eq!(app.last_mouse_pos, Some((50, 10)));

        // Drag by 1 pixel (below threshold of 2) — should be suppressed
        let cmd = app.update(CassMsg::MouseEvent {
            kind: MouseEventKind::LeftDrag,
            x: 51,
            y: 10,
        });
        // Position should NOT update (event was filtered)
        assert_eq!(app.last_mouse_pos, Some((50, 10)));
        assert!(matches!(cmd, ftui::Cmd::None));
    }

    #[test]
    fn drag_above_threshold_is_accepted() {
        use ftui::Model;
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::MouseEvent {
            kind: MouseEventKind::LeftClick,
            x: 50,
            y: 10,
        });

        // Drag by 3 pixels (above threshold of 2) — should be accepted
        let _ = app.update(CassMsg::MouseEvent {
            kind: MouseEventKind::LeftDrag,
            x: 53,
            y: 10,
        });
        // Position SHOULD update
        assert_eq!(app.last_mouse_pos, Some((53, 10)));
    }

    #[test]
    fn mouse_release_clears_tracking_state() {
        use ftui::Model;
        let mut app = CassApp::default();
        app.last_mouse_pos = Some((50, 10));
        app.drag_hover_settled_at = Some(Instant::now());

        let _ = app.update(CassMsg::MouseEvent {
            kind: MouseEventKind::LeftRelease,
            x: 50,
            y: 10,
        });
        assert!(app.last_mouse_pos.is_none());
        assert!(app.drag_hover_settled_at.is_none());
    }

    #[test]
    fn first_drag_event_without_prior_click_is_not_filtered() {
        use ftui::Model;
        let mut app = CassApp::default();
        assert!(app.last_mouse_pos.is_none());

        // First drag with no prior click — no previous position to compare, so not filtered
        let _ = app.update(CassMsg::MouseEvent {
            kind: MouseEventKind::LeftDrag,
            x: 50,
            y: 10,
        });
        assert_eq!(app.last_mouse_pos, Some((50, 10)));
    }

    #[test]
    fn drag_hover_settle_fields_initialized_to_none() {
        let app = CassApp::default();
        assert!(app.last_mouse_pos.is_none());
        assert!(app.drag_hover_settled_at.is_none());
    }

    #[test]
    fn scroll_events_are_not_jitter_filtered() {
        use ftui::Model;
        let mut app = CassApp::default();
        app.last_mouse_pos = Some((50, 10));

        // Scroll events should never be filtered even if mouse is tracked
        let cmd = app.update(CassMsg::MouseEvent {
            kind: MouseEventKind::ScrollDown,
            x: 50,
            y: 10,
        });
        assert!(
            !matches!(cmd, ftui::Cmd::None),
            "scroll should not be filtered"
        );
    }

    #[test]
    fn hit_test_row_calculation_respects_density() {
        let mut app = app_with_hits(10);
        app.density_mode = DensityMode::Spacious;
        render_at_degradation(&app, 120, 24, ftui::render::budget::DegradationLevel::Full);

        let inner = app.last_results_inner.borrow().unwrap();
        let row_h = app.density_mode.row_height();
        let region = app.hit_test(inner.x, inner.y + row_h + 1);
        assert!(
            matches!(
                region,
                MouseHitRegion::Results {
                    pane_idx: 0,
                    item_idx: 1
                }
            ),
            "2nd row in spacious density should be item_idx=1 in pane 0, got {region:?}"
        );
    }

    #[test]
    fn narrow_layout_only_records_visible_pane() {
        let mut app = app_with_hits(5);
        app.focus_manager.focus(focus_ids::RESULTS_LIST);
        render_at_degradation(&app, 60, 24, ftui::render::budget::DegradationLevel::Full);

        assert!(
            app.last_results_inner.borrow().is_some(),
            "results inner should be recorded in narrow/results mode"
        );
        assert!(
            app.last_detail_area.borrow().is_none(),
            "detail area should be None in narrow layout with results focus"
        );
    }

    // =====================================================================
    // Layout breakpoint classification tests
    // =====================================================================

    #[test]
    fn breakpoint_narrow_below_80() {
        assert_eq!(LayoutBreakpoint::from_width(40), LayoutBreakpoint::Narrow);
        assert_eq!(LayoutBreakpoint::from_width(79), LayoutBreakpoint::Narrow);
    }

    #[test]
    fn breakpoint_medium_narrow_80_to_119() {
        assert_eq!(
            LayoutBreakpoint::from_width(80),
            LayoutBreakpoint::MediumNarrow
        );
        assert_eq!(
            LayoutBreakpoint::from_width(100),
            LayoutBreakpoint::MediumNarrow
        );
        assert_eq!(
            LayoutBreakpoint::from_width(119),
            LayoutBreakpoint::MediumNarrow
        );
    }

    #[test]
    fn breakpoint_medium_120_to_159() {
        assert_eq!(LayoutBreakpoint::from_width(120), LayoutBreakpoint::Medium);
        assert_eq!(LayoutBreakpoint::from_width(140), LayoutBreakpoint::Medium);
        assert_eq!(LayoutBreakpoint::from_width(159), LayoutBreakpoint::Medium);
    }

    #[test]
    fn breakpoint_wide_160_plus() {
        assert_eq!(LayoutBreakpoint::from_width(160), LayoutBreakpoint::Wide);
        assert_eq!(LayoutBreakpoint::from_width(200), LayoutBreakpoint::Wide);
        assert_eq!(LayoutBreakpoint::from_width(300), LayoutBreakpoint::Wide);
    }

    #[test]
    fn breakpoint_zero_is_narrow() {
        assert_eq!(LayoutBreakpoint::from_width(0), LayoutBreakpoint::Narrow);
    }

    #[test]
    fn topology_narrow_is_single_pane() {
        let t = LayoutBreakpoint::Narrow.search_topology();
        assert!(!t.dual_pane);
        assert!(!t.has_split_handle);
        assert_eq!(t.min_results, 0);
        assert_eq!(t.min_detail, 0);
    }

    #[test]
    fn topology_medium_narrow_tight_split() {
        let t = LayoutBreakpoint::MediumNarrow.search_topology();
        assert!(t.dual_pane);
        assert!(t.has_split_handle);
        assert_eq!(t.min_results, 35);
        assert_eq!(t.min_detail, 25);
    }

    #[test]
    fn topology_medium_balanced_split() {
        let t = LayoutBreakpoint::Medium.search_topology();
        assert!(t.dual_pane);
        assert!(t.has_split_handle);
        assert_eq!(t.min_results, 45);
        assert_eq!(t.min_detail, 32);
    }

    #[test]
    fn topology_wide_spacious_split() {
        let t = LayoutBreakpoint::Wide.search_topology();
        assert!(t.dual_pane);
        assert!(t.has_split_handle);
        assert_eq!(t.min_results, 50);
        assert_eq!(t.min_detail, 34);
    }

    #[test]
    fn topology_min_sum_fits_breakpoint() {
        // The sum of min_results + min_detail must fit within the breakpoint's minimum width.
        let mn = LayoutBreakpoint::MediumNarrow.search_topology();
        assert!(
            mn.min_results + mn.min_detail <= 80,
            "MediumNarrow mins must fit in 80 cols"
        );

        let m = LayoutBreakpoint::Medium.search_topology();
        assert!(
            m.min_results + m.min_detail <= 120,
            "Medium mins must fit in 120 cols"
        );

        let w = LayoutBreakpoint::Wide.search_topology();
        assert!(
            w.min_results + w.min_detail <= 160,
            "Wide mins must fit in 160 cols"
        );
    }

    #[test]
    fn footer_labels_are_short() {
        for bp in [
            LayoutBreakpoint::Narrow,
            LayoutBreakpoint::MediumNarrow,
            LayoutBreakpoint::Medium,
            LayoutBreakpoint::Wide,
        ] {
            assert!(
                bp.footer_label().len() <= 6,
                "footer label too long: {}",
                bp.footer_label()
            );
        }
    }

    #[test]
    fn inspector_labels_contain_range() {
        assert!(LayoutBreakpoint::Narrow.inspector_label().contains("<80"));
        assert!(
            LayoutBreakpoint::MediumNarrow
                .inspector_label()
                .contains("80")
        );
        assert!(LayoutBreakpoint::Medium.inspector_label().contains("120"));
        assert!(LayoutBreakpoint::Wide.inspector_label().contains("160"));
    }

    #[test]
    fn analytics_topology_narrow_hides_tab_bar() {
        let t = LayoutBreakpoint::Narrow.analytics_topology();
        assert!(!t.show_tab_bar);
        assert!(!t.show_filter_summary);
        assert!(!t.show_footer_hints);
    }

    #[test]
    fn analytics_topology_medium_narrow_shows_filter() {
        let t = LayoutBreakpoint::MediumNarrow.analytics_topology();
        assert!(!t.show_tab_bar, "medium-narrow should hide tab bar");
        assert!(t.show_filter_summary);
        assert!(t.show_footer_hints);
    }

    #[test]
    fn analytics_topology_medium_shows_tabs() {
        let t = LayoutBreakpoint::Medium.analytics_topology();
        assert!(t.show_tab_bar);
        assert!(t.show_filter_summary);
        assert!(t.show_footer_hints);
    }

    #[test]
    fn analytics_topology_wide_shows_everything() {
        let t = LayoutBreakpoint::Wide.analytics_topology();
        assert!(t.show_tab_bar);
        assert!(t.show_filter_summary);
        assert!(t.show_footer_hints);
    }

    #[test]
    fn analytics_footer_includes_breakpoint_label() {
        use ftui_harness::buffer_to_text;
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::AnalyticsEntered);
        let buf =
            render_at_degradation(&app, 120, 24, ftui::render::budget::DegradationLevel::Full);
        let text = buffer_to_text(&buf);
        assert!(
            text.contains("med"),
            "analytics footer at 120 cols should include breakpoint label 'med'"
        );
    }

    #[test]
    fn medium_narrow_renders_both_panes() {
        let app = app_with_hits(5);
        // 100 cols = MediumNarrow: should render both results and detail
        render_at_degradation(&app, 100, 24, ftui::render::budget::DegradationLevel::Full);

        assert!(
            app.last_results_inner.borrow().is_some(),
            "results inner should be recorded in medium-narrow layout"
        );
        assert!(
            app.last_detail_area.borrow().is_some(),
            "detail area should be recorded in medium-narrow layout (both panes visible)"
        );
    }

    #[test]
    fn topology_driven_render_all_widths() {
        // Verify that topology-driven rendering doesn't panic at representative widths
        // for each breakpoint tier.
        let widths = [40, 79, 80, 100, 119, 120, 140, 159, 160, 200];
        for w in widths {
            let app = app_with_hits(3);
            render_at_degradation(&app, w, 24, ftui::render::budget::DegradationLevel::Full);
            let bp = LayoutBreakpoint::from_width(w);
            let topo = bp.search_topology();
            if topo.dual_pane {
                assert!(
                    app.last_detail_area.borrow().is_some(),
                    "dual_pane at w={w} should render detail area"
                );
            }
        }
    }

    #[test]
    fn narrow_single_pane_hides_other() {
        let app = app_with_hits(3);
        // 60 cols = Narrow: only results visible (default focus is Results)
        render_at_degradation(&app, 60, 24, ftui::render::budget::DegradationLevel::Full);
        // In narrow mode the detail area should NOT be set (single pane, results focused)
        assert!(
            app.last_detail_area.borrow().is_none(),
            "narrow layout should not render detail when results are focused"
        );
    }

    // =====================================================================
    // 1mfw3.4.5 — Hit-region and focus invariants
    // =====================================================================

    #[test]
    fn hit_regions_cleared_in_narrow_single_pane() {
        let app = app_with_hits(3);
        // 60 cols = Narrow, focus defaults to Results.
        render_at_degradation(&app, 60, 24, ftui::render::budget::DegradationLevel::Full);
        // Split handle must be None in narrow (no dual pane).
        assert!(
            app.last_split_handle_area.borrow().is_none(),
            "narrow mode should never set split handle hit region"
        );
        // Results pane should be populated (it's the focused one).
        assert!(
            app.last_results_inner.borrow().is_some(),
            "narrow mode should record results inner when focused"
        );
    }

    #[test]
    fn dual_pane_records_both_hit_regions() {
        // All dual-pane breakpoints should record results, detail, AND split handle.
        for w in [90, 130, 180] {
            let app = app_with_hits(3);
            render_at_degradation(&app, w, 24, ftui::render::budget::DegradationLevel::Full);
            let bp = LayoutBreakpoint::from_width(w);
            assert!(
                app.last_results_inner.borrow().is_some(),
                "dual_pane at w={w} ({bp:?}) should record results inner"
            );
            assert!(
                app.last_detail_area.borrow().is_some(),
                "dual_pane at w={w} ({bp:?}) should record detail area"
            );
            assert!(
                app.last_split_handle_area.borrow().is_some(),
                "dual_pane at w={w} ({bp:?}) should record split handle"
            );
        }
    }

    #[test]
    fn dual_pane_grouping_cues_survive_degradation_levels() {
        use ftui::render::budget::DegradationLevel;

        for level in [
            DegradationLevel::Full,
            DegradationLevel::SimpleBorders,
            DegradationLevel::NoStyling,
            DegradationLevel::EssentialOnly,
        ] {
            let app = app_with_hits(3);
            render_at_degradation(&app, 130, 24, level);
            assert!(
                app.last_results_inner.borrow().is_some(),
                "results hit region should remain present at {level:?}"
            );
            assert!(
                app.last_detail_area.borrow().is_some(),
                "detail region should remain present at {level:?}"
            );
            assert!(
                app.last_split_handle_area.borrow().is_some(),
                "split-handle grouping cue should remain present at {level:?}"
            );
        }
    }

    #[test]
    fn focus_toggle_switches_region() {
        let mut app = CassApp::default();
        assert_eq!(app.focused_region(), FocusRegion::Results);
        let _ = app.update(CassMsg::FocusToggled);
        assert_eq!(app.focused_region(), FocusRegion::Detail);
        let _ = app.update(CassMsg::FocusToggled);
        assert_eq!(app.focused_region(), FocusRegion::Results);
    }

    #[test]
    fn narrow_focus_toggle_swaps_visible_pane() {
        let mut app = app_with_hits(3);
        // Start in Results focus.
        render_at_degradation(&app, 60, 24, ftui::render::budget::DegradationLevel::Full);
        assert!(app.last_results_inner.borrow().is_some());
        assert!(app.last_detail_area.borrow().is_none());

        // Toggle focus to Detail.
        let _ = app.update(CassMsg::FocusToggled);
        render_at_degradation(&app, 60, 24, ftui::render::budget::DegradationLevel::Full);
        assert!(
            app.last_detail_area.borrow().is_some(),
            "after focus toggle, narrow mode should show detail"
        );
    }

    // -- Focus ownership hardening (dcor9.2) ---------------------------------

    #[test]
    fn selection_moved_transfers_focus_to_results_list() {
        let mut app = app_with_hits(5);
        // Start with focus on search bar (simulates typing then arrowing down).
        app.focus_manager.focus(focus_ids::SEARCH_BAR);
        assert_eq!(app.focus_manager.current(), Some(focus_ids::SEARCH_BAR));

        let _ = app.update(CassMsg::SelectionMoved { delta: 1 });

        assert_eq!(
            app.focus_manager.current(),
            Some(focus_ids::RESULTS_LIST),
            "SelectionMoved in Query mode should transfer focus to results list"
        );
    }

    #[test]
    fn selection_moved_preserves_focus_in_filter_input_modes() {
        // When the user is editing a filter (Agent/Workspace/PaneFilter),
        // navigation should NOT steal focus from the search bar.
        for mode in [
            InputMode::Agent,
            InputMode::Workspace,
            InputMode::PaneFilter,
        ] {
            let mut app = app_with_hits(5);
            app.input_mode = mode;
            app.focus_manager.focus(focus_ids::SEARCH_BAR);

            let _ = app.update(CassMsg::SelectionMoved { delta: 1 });

            assert_eq!(
                app.focus_manager.current(),
                Some(focus_ids::SEARCH_BAR),
                "SelectionMoved in {mode:?} should preserve search bar focus"
            );
        }
    }

    #[test]
    fn selection_jumped_transfers_focus_to_results_list() {
        let mut app = app_with_hits(5);
        app.focus_manager.focus(focus_ids::SEARCH_BAR);

        let _ = app.update(CassMsg::SelectionJumped { to_end: true });

        assert_eq!(
            app.focus_manager.current(),
            Some(focus_ids::RESULTS_LIST),
            "SelectionJumped should transfer focus to results list"
        );
    }

    #[test]
    fn active_pane_changed_transfers_focus_to_results_list() {
        let mut app = app_with_hits(5);
        // Add a second pane so we can switch.
        app.panes.push(AgentPane {
            agent: "claude-code".into(),
            total_count: 2,
            hits: vec![make_hit(100, "/other"), make_hit(101, "/other2")],
            selected: 0,
        });
        app.focus_manager.focus(focus_ids::DETAIL_PANE);

        let _ = app.update(CassMsg::ActivePaneChanged { index: 1 });

        assert_eq!(
            app.focus_manager.current(),
            Some(focus_ids::RESULTS_LIST),
            "ActivePaneChanged should transfer focus to results list"
        );
        assert_eq!(app.active_pane, 1);
    }

    #[test]
    fn keyboard_navigation_then_enter_opens_detail() {
        let mut app = app_with_hits(3);
        // Simulate: user types query, focus on search bar, then arrows down.
        app.focus_manager.focus(focus_ids::SEARCH_BAR);

        // Arrow down moves selection and transfers focus.
        let _ = app.update(CassMsg::SelectionMoved { delta: 1 });
        assert_eq!(app.focus_manager.current(), Some(focus_ids::RESULTS_LIST));

        // Enter should open detail modal.
        let _ = app.update(CassMsg::DetailOpened);
        assert!(
            app.show_detail_modal,
            "Enter after keyboard navigation should open detail modal"
        );
    }

    #[test]
    fn detail_close_restores_focus_to_results_list() {
        let mut app = app_with_hits(3);
        // Open detail modal.
        let _ = app.update(CassMsg::DetailOpened);
        assert!(app.show_detail_modal);

        // Close detail modal.
        let _ = app.update(CassMsg::DetailClosed);
        assert!(!app.show_detail_modal);
        assert_eq!(
            app.focus_manager.current(),
            Some(focus_ids::RESULTS_LIST),
            "Closing detail modal should restore focus to results list"
        );
    }

    // -- Enter-routing interaction matrix (dcor9.4) ---------------------------
    //
    // Covers all known ambiguous routing states for Enter/DetailOpened.
    // Matrix axes: focus state × input mode × modal state × hit presence.

    #[test]
    fn enter_matrix_query_mode_with_hit_opens_detail() {
        // Focus on SEARCH_BAR, Query mode, no modal, hit present → detail
        let mut app = app_with_hits(3);
        app.input_mode = InputMode::Query;
        app.focus_manager.focus(focus_ids::SEARCH_BAR);

        let _ = app.update(CassMsg::DetailOpened);

        assert!(
            app.show_detail_modal,
            "should open detail with selected hit"
        );
        assert_eq!(app.detail_tab, DetailTab::Messages);
    }

    #[test]
    fn enter_matrix_query_mode_without_hit_submits_query() {
        // Focus on SEARCH_BAR, Query mode, no modal, no hit → query submit
        let mut app = CassApp::default();
        app.input_mode = InputMode::Query;
        app.input_buffer = "test".into();
        app.focus_manager.focus(focus_ids::SEARCH_BAR);

        let _ = app.update(CassMsg::DetailOpened);

        assert!(
            !app.show_detail_modal,
            "no hit: should NOT open detail modal"
        );
    }

    #[test]
    fn enter_matrix_results_focus_with_hit_opens_detail() {
        // Focus on RESULTS_LIST, Query mode, no modal, hit present → detail
        let mut app = app_with_hits(3);
        app.input_mode = InputMode::Query;
        app.focus_manager.focus(focus_ids::RESULTS_LIST);

        let _ = app.update(CassMsg::DetailOpened);

        assert!(app.show_detail_modal);
        assert_eq!(app.detail_tab, DetailTab::Messages);
    }

    #[test]
    fn enter_matrix_detail_modal_already_open_stays_open() {
        // Detail modal already open → stays open (re-entrant)
        let mut app = app_with_hits(3);
        let _ = app.update(CassMsg::DetailOpened);
        assert!(app.show_detail_modal);
        let prev_tab = app.detail_tab;

        // Enter again while modal is open.
        let _ = app.update(CassMsg::DetailOpened);

        assert!(
            app.show_detail_modal,
            "detail modal should remain open on re-entry"
        );
        assert_eq!(
            app.detail_tab, prev_tab,
            "tab should not change on re-entry"
        );
    }

    #[test]
    fn enter_reentry_does_not_stack_detail_focus_traps() {
        let mut app = app_with_hits(3);

        let _ = app.update(CassMsg::DetailOpened);
        assert!(app.show_detail_modal);
        assert!(app.focus_manager.is_trapped());

        // Rapid Enter repeats should not accumulate additional traps.
        for _ in 0..3 {
            let _ = app.update(CassMsg::DetailOpened);
        }

        let _ = app.update(CassMsg::DetailClosed);
        assert!(
            !app.show_detail_modal,
            "closing once should exit detail modal after re-entry presses"
        );
        assert!(
            !app.focus_manager.is_trapped(),
            "rapid Enter re-entry should not leave stale traps"
        );
        assert_eq!(
            app.focus_manager.current(),
            Some(focus_ids::RESULTS_LIST),
            "focus should restore to results list after close"
        );
    }

    #[test]
    fn enter_reentry_preserves_detail_scroll_state() {
        let mut app = app_with_hits(3);
        let _ = app.update(CassMsg::DetailOpened);
        app.detail_scroll = 11;
        app.modal_scroll = 7;

        let _ = app.update(CassMsg::DetailOpened);

        assert_eq!(
            app.detail_scroll, 11,
            "re-entry should not reset detail scroll"
        );
        assert_eq!(
            app.modal_scroll, 7,
            "re-entry should not reset modal scroll"
        );
    }

    #[test]
    fn enter_matrix_pane_filter_mode_applies_filter() {
        // PaneFilter mode with focus on SEARCH_BAR → applies pane filter
        let mut app = app_with_hits(3);
        app.input_mode = InputMode::PaneFilter;
        app.input_buffer = "test filter".into();
        app.focus_manager.focus(focus_ids::SEARCH_BAR);

        let _ = app.update(CassMsg::DetailOpened);

        assert!(
            !app.show_detail_modal,
            "PaneFilter mode should apply filter, not open detail"
        );
        // After PaneFilterClosed, mode returns to Query.
        assert_eq!(app.input_mode, InputMode::Query);
    }

    #[test]
    fn enter_matrix_agent_filter_mode_applies_filter() {
        // Agent input mode → applies agent filter, not detail open
        let mut app = app_with_hits(3);
        app.input_mode = InputMode::Agent;
        app.input_buffer = "codex".into();
        app.focus_manager.focus(focus_ids::SEARCH_BAR);

        let _ = app.update(CassMsg::DetailOpened);

        assert!(
            !app.show_detail_modal,
            "Agent filter mode should apply filter, not open detail"
        );
        assert_eq!(app.input_mode, InputMode::Query);
    }

    #[test]
    fn enter_matrix_navigation_flow_search_to_detail_roundtrip() {
        // Full workflow: type → navigate → Enter → close → back to results
        let mut app = app_with_hits(5);
        app.focus_manager.focus(focus_ids::SEARCH_BAR);

        // 1. Arrow down to browse results.
        let _ = app.update(CassMsg::SelectionMoved { delta: 2 });
        assert_eq!(app.focus_manager.current(), Some(focus_ids::RESULTS_LIST));

        // 2. Enter opens detail.
        let _ = app.update(CassMsg::DetailOpened);
        assert!(app.show_detail_modal);

        // 3. Escape closes detail, focus returns to results.
        let _ = app.update(CassMsg::DetailClosed);
        assert!(!app.show_detail_modal);
        assert_eq!(app.focus_manager.current(), Some(focus_ids::RESULTS_LIST));

        // 4. Selection should still be on the row we navigated to.
        assert_eq!(app.panes[0].selected, 2);
    }

    #[test]
    fn toggle_json_view_while_modal_open_no_duplicate_trap() {
        // Pressing 'J' (ToggleJsonView) while detail modal is already open
        // should switch tabs but NOT push a duplicate focus trap.
        let mut app = app_with_hits(3);
        let _ = app.update(CassMsg::DetailOpened);
        assert!(app.show_detail_modal);
        assert_eq!(app.detail_tab, DetailTab::Messages);

        // Toggle to Json — modal stays open, no duplicate trap.
        let _ = app.update(CassMsg::ToggleJsonView);
        assert!(app.show_detail_modal);
        assert_eq!(app.detail_tab, DetailTab::Json);

        // Toggle back to Raw.
        let _ = app.update(CassMsg::ToggleJsonView);
        assert!(app.show_detail_modal);
        assert_eq!(app.detail_tab, DetailTab::Raw);

        // Single Escape should close the detail modal cleanly.
        let _ = app.update(CassMsg::DetailClosed);
        assert!(!app.show_detail_modal);
        assert_eq!(app.focus_manager.current(), Some(focus_ids::RESULTS_LIST));
    }

    #[test]
    fn rapid_enter_presses_no_focus_trap_stack() {
        // Rapid Enter presses should not corrupt the focus stack.
        let mut app = app_with_hits(3);

        // Press Enter 5 times rapidly.
        for _ in 0..5 {
            let _ = app.update(CassMsg::DetailOpened);
        }
        assert!(app.show_detail_modal);

        // A single close should return to results, not leave stale traps.
        let _ = app.update(CassMsg::DetailClosed);
        assert!(!app.show_detail_modal);
        assert_eq!(app.focus_manager.current(), Some(focus_ids::RESULTS_LIST));
    }

    #[test]
    fn enter_with_empty_panes_submits_query() {
        // When panes are empty (no results at all), Enter should fall back
        // to query submit rather than opening a detail modal.
        let mut app = CassApp::default();
        app.input_mode = InputMode::Query;
        app.input_buffer = "some query".into();
        assert!(app.panes.is_empty() || app.panes.iter().all(|p| p.hits.is_empty()));

        let _ = app.update(CassMsg::DetailOpened);

        assert!(
            !app.show_detail_modal,
            "empty panes should not open detail modal"
        );
    }

    // -- End focus ownership & Enter-routing matrix ---------------------------

    // -- Collapsible tool call tests ------------------------------------------

    #[test]
    fn tool_collapse_toggle_flips_state() {
        let mut app = app_with_hits(3);
        assert!(!app.collapsed_tools.contains(&2));
        let _ = app.update(CassMsg::ToolCollapseToggled(2));
        assert!(app.collapsed_tools.contains(&2));
        let _ = app.update(CassMsg::ToolCollapseToggled(2));
        assert!(!app.collapsed_tools.contains(&2));
    }

    #[test]
    fn tool_expand_all_clears_collapsed() {
        let mut app = app_with_hits(3);
        app.collapsed_tools.insert(0);
        app.collapsed_tools.insert(3);
        app.collapsed_tools.insert(7);
        assert_eq!(app.collapsed_tools.len(), 3);
        let _ = app.update(CassMsg::ToolExpandAll);
        assert!(app.collapsed_tools.is_empty());
    }

    #[test]
    fn detail_opened_auto_collapses_tool_messages() {
        let mut app = app_with_hits(3);
        // Ensure collapsed_tools is empty before open
        assert!(app.collapsed_tools.is_empty());
        let _ = app.update(CassMsg::DetailOpened);
        assert!(app.show_detail_modal);
        // If there's a cached_detail with tool/system messages, they should
        // be in collapsed_tools. If no cached_detail, set stays empty.
        // The important thing is the mechanism is wired.
    }

    #[test]
    fn tool_collapse_all_populates_from_cached_detail() {
        use crate::model::types::{Message, MessageRole};
        let mut app = app_with_hits(3);

        fn msg(role: MessageRole, content: &str) -> Message {
            Message {
                id: None,
                idx: 0,
                role,
                author: None,
                created_at: None,
                content: content.to_string(),
                extra_json: serde_json::json!({}),
                snippets: Vec::new(),
            }
        }

        let mut cv = make_test_conversation_view();
        cv.messages = vec![
            msg(MessageRole::User, "hello"),
            msg(MessageRole::Agent, "hi there"),
            msg(MessageRole::Tool, "tool output here"),
            msg(MessageRole::System, "system note"),
        ];
        app.cached_detail = Some(("test-id".to_string(), cv));

        let _ = app.update(CassMsg::ToolCollapseAll);
        // Indices 2 (Tool) and 3 (System) should be collapsed
        assert!(app.collapsed_tools.contains(&2));
        assert!(app.collapsed_tools.contains(&3));
        // Indices 0 (User) and 1 (Agent) should NOT be collapsed
        assert!(!app.collapsed_tools.contains(&0));
        assert!(!app.collapsed_tools.contains(&1));
    }

    // -- End collapsible tool call tests --------------------------------------

    // -- Detail header tests --------------------------------------------------

    #[test]
    fn build_detail_header_lines_without_cached_detail() {
        let app = app_with_hits(3);
        let hit = make_test_hit();
        let styles = StyleContext::from_options(StyleOptions::default());
        let lines = app.build_detail_header_lines(&hit, 80, &styles);
        // Should have at least agent/workspace line + separator
        assert!(lines.len() >= 2, "header should have at least 2 lines");
    }

    #[test]
    fn build_detail_header_lines_with_cached_detail() {
        use crate::model::types::{Message, MessageRole};
        let mut app = app_with_hits(3);

        fn msg(role: MessageRole, content: &str, ts: Option<i64>) -> Message {
            Message {
                id: None,
                idx: 0,
                role,
                author: None,
                created_at: ts,
                content: content.to_string(),
                extra_json: serde_json::json!({}),
                snippets: Vec::new(),
            }
        }

        let mut cv = make_test_conversation_view();
        cv.messages = vec![
            msg(MessageRole::User, "hello", Some(1_700_000)),
            msg(MessageRole::Agent, "hi", Some(1_700_010)),
            msg(MessageRole::Tool, "result", Some(1_700_020)),
            msg(MessageRole::User, "thanks", Some(1_700_030)),
        ];
        app.cached_detail = Some(("test-id".to_string(), cv));

        let hit = make_test_hit();
        let styles = StyleContext::from_options(StyleOptions::default());
        let lines = app.build_detail_header_lines(&hit, 80, &styles);
        // Should have: agent line, metadata line, sparkline, separator = 4 lines
        assert!(
            lines.len() >= 3,
            "header with cached_detail should have >= 3 lines, got {}",
            lines.len()
        );
    }

    #[test]
    fn build_text_sparkline_produces_output() {
        use crate::model::types::{Message, MessageRole};

        fn msg(ts: i64) -> Message {
            Message {
                id: None,
                idx: 0,
                role: MessageRole::User,
                author: None,
                created_at: Some(ts),
                content: String::new(),
                extra_json: serde_json::json!({}),
                snippets: Vec::new(),
            }
        }

        let messages = vec![msg(1000), msg(2000), msg(3000), msg(4000), msg(5000)];
        let sparkline = CassApp::build_text_sparkline(&messages, 20);
        assert!(
            !sparkline.is_empty(),
            "sparkline should be non-empty for 5 messages"
        );
        assert!(
            sparkline.chars().count() <= 20,
            "sparkline width should not exceed max_width"
        );
    }

    #[test]
    fn build_text_sparkline_empty_for_single_message() {
        use crate::model::types::{Message, MessageRole};
        let messages = vec![Message {
            id: None,
            idx: 0,
            role: MessageRole::User,
            author: None,
            created_at: Some(1000),
            content: String::new(),
            extra_json: serde_json::json!({}),
            snippets: Vec::new(),
        }];
        let sparkline = CassApp::build_text_sparkline(&messages, 20);
        assert!(
            sparkline.is_empty(),
            "sparkline should be empty for < 2 timestamps"
        );
    }

    // -- End detail header tests ----------------------------------------------

    // -- Analytics tab tests --------------------------------------------------

    #[test]
    fn build_analytics_lines_without_cached_detail() {
        let app = app_with_hits(3);
        let hit = make_test_hit();
        let styles = StyleContext::from_options(StyleOptions::default());
        let lines = app.build_analytics_lines(&hit, 80, &styles);
        // Should show header + "No conversation data" message
        assert!(lines.len() >= 2, "should produce fallback lines");
    }

    #[test]
    fn build_analytics_lines_with_messages() {
        use crate::model::types::{Message, MessageRole};
        let mut app = app_with_hits(3);

        fn msg(role: MessageRole, content: &str, ts: Option<i64>) -> Message {
            Message {
                id: None,
                idx: 0,
                role,
                author: None,
                created_at: ts,
                content: content.to_string(),
                extra_json: serde_json::json!({}),
                snippets: Vec::new(),
            }
        }

        let mut cv = make_test_conversation_view();
        cv.messages = vec![
            msg(MessageRole::User, "hello world", Some(1_000)),
            msg(MessageRole::Agent, "hi there friend", Some(2_000)),
            msg(MessageRole::Tool, "tool output data here", Some(3_000)),
            msg(MessageRole::User, "thanks for help", Some(4_000)),
            msg(MessageRole::Agent, "you are welcome", Some(5_000)),
        ];
        app.cached_detail = Some(("test-id".to_string(), cv));

        let hit = make_test_hit();
        let styles = StyleContext::from_options(StyleOptions::default());
        let lines = app.build_analytics_lines(&hit, 80, &styles);

        let text: String = lines
            .iter()
            .flat_map(|l| l.spans().iter().map(|s| s.content.as_ref().to_string()))
            .collect();
        // Should contain section headers
        assert!(text.contains("Overview"), "should have Overview section");
        assert!(
            text.contains("Message Breakdown"),
            "should have Message Breakdown section"
        );
        assert!(
            text.contains("Activity Timeline"),
            "should have Activity Timeline section"
        );
        // Should show role counts
        assert!(text.contains("User"), "should show User role");
        assert!(text.contains("Agent"), "should show Agent role");
        assert!(text.contains("Tool"), "should show Tool role");
    }

    #[test]
    fn tab_cycling_includes_analytics() {
        let mut app = app_with_hits(3);
        let _ = app.update(CassMsg::DetailOpened);
        assert_eq!(app.detail_tab, DetailTab::Messages);

        // Cycle through all tabs
        let _ = app.update(CassMsg::DetailTabChanged(DetailTab::Json));
        assert_eq!(app.detail_tab, DetailTab::Json);
        // Json -> Analytics (via tab cycle logic, but we test direct tab change)
        let _ = app.update(CassMsg::DetailTabChanged(DetailTab::Analytics));
        assert_eq!(app.detail_tab, DetailTab::Analytics);
    }

    // -- End analytics tab tests ----------------------------------------------

    // -- Message navigation tests ---------------------------------------------

    #[test]
    fn detail_message_jumped_forward() {
        let mut app = app_with_hits(3);
        // Populate message offsets manually
        *app.detail_message_offsets.borrow_mut() = vec![
            (0, crate::model::types::MessageRole::User),
            (10, crate::model::types::MessageRole::Agent),
            (25, crate::model::types::MessageRole::Tool),
            (40, crate::model::types::MessageRole::User),
        ];
        app.detail_scroll = 0;
        let _ = app.update(CassMsg::DetailMessageJumped {
            forward: true,
            user_only: false,
        });
        assert_eq!(app.detail_scroll, 10, "should jump to next message");

        let _ = app.update(CassMsg::DetailMessageJumped {
            forward: true,
            user_only: false,
        });
        assert_eq!(app.detail_scroll, 25, "should jump to third message");
    }

    #[test]
    fn detail_message_jumped_backward() {
        let mut app = app_with_hits(3);
        *app.detail_message_offsets.borrow_mut() = vec![
            (0, crate::model::types::MessageRole::User),
            (10, crate::model::types::MessageRole::Agent),
            (25, crate::model::types::MessageRole::Tool),
        ];
        app.detail_scroll = 25;
        let _ = app.update(CassMsg::DetailMessageJumped {
            forward: false,
            user_only: false,
        });
        assert_eq!(app.detail_scroll, 10, "should jump to previous message");
    }

    #[test]
    fn detail_message_jumped_user_only() {
        let mut app = app_with_hits(3);
        *app.detail_message_offsets.borrow_mut() = vec![
            (0, crate::model::types::MessageRole::User),
            (10, crate::model::types::MessageRole::Agent),
            (25, crate::model::types::MessageRole::Tool),
            (40, crate::model::types::MessageRole::User),
        ];
        app.detail_scroll = 0;
        let _ = app.update(CassMsg::DetailMessageJumped {
            forward: true,
            user_only: true,
        });
        assert_eq!(
            app.detail_scroll, 40,
            "should skip Agent/Tool and jump to next User"
        );
    }

    #[test]
    fn detail_g_jumps_to_top() {
        let mut app = CassApp::default();
        app.show_detail_modal = true;
        app.detail_scroll = 50;
        // Simulate pressing 'g' via the QueryChanged intercept
        let _ = app.update(CassMsg::QueryChanged("g".to_string()));
        assert_eq!(app.detail_scroll, 0, "g should jump to top");
    }

    #[test]
    fn detail_g_capital_jumps_to_bottom() {
        let mut app = CassApp::default();
        app.show_detail_modal = true;
        app.detail_content_lines.set(100);
        app.detail_visible_height.set(20);
        app.detail_scroll = 0;
        let _ = app.update(CassMsg::QueryChanged("G".to_string()));
        assert_eq!(app.detail_scroll, 80, "G should jump to bottom");
    }

    // -- End message navigation tests -----------------------------------------

    // -- Stats bar tests ------------------------------------------------------

    #[test]
    fn stats_bar_toggled_flips_state() {
        let mut app = app_with_hits(3);
        assert!(app.show_stats_bar, "should default to true");
        let _ = app.update(CassMsg::StatsBarToggled);
        assert!(!app.show_stats_bar);
        let _ = app.update(CassMsg::StatsBarToggled);
        assert!(app.show_stats_bar);
    }

    #[test]
    fn build_results_stats_line_with_hits() {
        let app = app_with_hits(5);
        let styles = StyleContext::from_options(StyleOptions::default());
        let line = app.build_results_stats_line(80, &styles);
        let text: String = line
            .spans()
            .iter()
            .map(|s| s.content.as_ref().to_string())
            .collect();
        assert!(
            text.contains("sessions"),
            "stats line should show session count"
        );
        assert!(
            text.contains("msgs"),
            "stats line should show message count"
        );
        assert!(!text.contains("$"), "stats line should not show token cost");
        assert!(
            !text.contains("tok"),
            "stats line should not show token metrics"
        );
    }

    #[test]
    fn build_results_stats_line_empty_panes() {
        let app = CassApp::default();
        let styles = StyleContext::from_options(StyleOptions::default());
        let line = app.build_results_stats_line(80, &styles);
        let text: String = line
            .spans()
            .iter()
            .map(|s| s.content.as_ref().to_string())
            .collect();
        assert!(text.contains("0"), "empty panes should show zeroed metrics");
        assert!(text.contains("sessions"));
        assert!(text.contains("msgs"));
        assert!(!text.contains('$'));
    }

    #[test]
    fn build_results_stats_line_omits_token_estimate_from_content() {
        let mut app = CassApp::default();
        let mut hit = make_hit(1, "/path/1");
        hit.content = "x".repeat(8_000); // ~2,000 tokens by chars/4 heuristic
        hit.created_at = Some(1_700_000_000);
        app.results = vec![hit];
        app.regroup_panes();

        let styles = StyleContext::from_options(StyleOptions::default());
        let line = app.build_results_stats_line(120, &styles);
        let text: String = line
            .spans()
            .iter()
            .map(|s| s.content.as_ref().to_string())
            .collect();

        assert!(!text.contains("2,000"), "token estimate should be omitted");
        assert!(!text.contains("tok"), "token metrics should be omitted");
        assert!(
            !text.contains('$'),
            "should not show estimated cost, got: {text}"
        );
    }

    #[test]
    fn build_result_row_mini_analytics_map_aggregates_by_session() {
        let mut app = CassApp::default();

        let mut a1 = make_hit(1, "/session/a");
        a1.content = "a".repeat(4_000); // ~1,000 tok
        a1.source_id = "local".into();
        a1.line_number = Some(1);

        let mut a2 = make_hit(2, "/session/a");
        a2.content = "b".repeat(2_000); // ~500 tok
        a2.source_id = "local".into();
        a2.line_number = Some(2);

        let mut b1 = make_hit(3, "/session/b");
        b1.content = "c".repeat(800); // ~200 tok
        b1.source_id = "remote-ci".into();
        b1.line_number = Some(1);

        app.results = vec![a1, a2, b1];
        let by_session = app.build_result_row_mini_analytics_map();

        assert_eq!(by_session.len(), 2, "expected two unique sessions");
        let a_metrics = by_session
            .get(&(String::from("local"), String::from("/session/a")))
            .expect("missing session a metrics");
        assert_eq!(a_metrics.matched_messages, 2);

        let b_metrics = by_session
            .get(&(String::from("remote-ci"), String::from("/session/b")))
            .expect("missing session b metrics");
        assert_eq!(b_metrics.matched_messages, 1);
    }

    // -- End stats bar tests --------------------------------------------------

    // -- Detail modal regression test suite (A.6) -----------------------------

    /// Helper: create an app with a rich cached_detail for regression testing.
    fn app_with_cached_conversation() -> CassApp {
        use crate::model::types::{Message, MessageRole};
        let mut app = app_with_hits(3);
        // selected hit[0].source_path is "/path/0" from app_with_hits —
        // cached_detail below uses the same key so DetailOpened takes the
        // cache-hit branch.

        fn msg(idx: i64, role: MessageRole, content: &str, ts: Option<i64>) -> Message {
            Message {
                id: None,
                idx,
                role,
                author: None,
                created_at: ts,
                content: content.to_string(),
                extra_json: serde_json::json!({}),
                snippets: Vec::new(),
            }
        }

        let mut cv = make_test_conversation_view();
        cv.messages = vec![
            msg(
                0,
                MessageRole::User,
                "Please help me fix a bug",
                Some(1_000),
            ),
            msg(
                1,
                MessageRole::Agent,
                "# Analysis\n\nI'll look at the code:\n\n```rust\nfn main() {\n    println!(\"hello\");\n}\n```\n\nLet me check.",
                Some(2_000),
            ),
            msg(
                2,
                MessageRole::Tool,
                "File contents: some tool output that is quite long and should be truncated when collapsed",
                Some(3_000),
            ),
            msg(
                3,
                MessageRole::Agent,
                "Found the bug. Here's the fix.",
                Some(4_000),
            ),
            msg(4, MessageRole::System, "System context note", Some(5_000)),
            msg(5, MessageRole::User, "Thanks!", Some(6_000)),
        ];
        cv.convo.started_at = Some(1_000_000);
        cv.convo.ended_at = Some(1_060_000);
        cv.convo.approx_tokens = Some(15_000);
        app.cached_detail = Some(("/path/0".to_string(), cv));
        app
    }

    #[test]
    fn regression_detail_open_sets_messages_tab() {
        let mut app = app_with_cached_conversation();
        let _ = app.update(CassMsg::DetailOpened);
        assert!(app.show_detail_modal);
        assert_eq!(app.detail_tab, DetailTab::Messages);
    }

    #[test]
    fn regression_detail_open_collects_session_hit_lines_for_selected_source() {
        let mut app = CassApp::default();
        let hits = vec![
            SearchHit {
                title: "first".into(),
                snippet: String::new(),
                content: String::new(),
                content_hash: 1,
                score: 0.9,
                agent: "claude_code".into(),
                source_path: "/sessions/shared.jsonl".into(),
                workspace: "/w".into(),
                workspace_original: None,
                created_at: None,
                line_number: Some(2),
                match_type: MatchType::Exact,
                source_id: "local".into(),
                origin_kind: "local".into(),
                origin_host: None,
            },
            SearchHit {
                title: "second".into(),
                snippet: String::new(),
                content: String::new(),
                content_hash: 2,
                score: 0.8,
                agent: "claude_code".into(),
                source_path: "/sessions/shared.jsonl".into(),
                workspace: "/w".into(),
                workspace_original: None,
                created_at: None,
                line_number: Some(5),
                match_type: MatchType::Exact,
                source_id: "local".into(),
                origin_kind: "local".into(),
                origin_host: None,
            },
            SearchHit {
                title: "other".into(),
                snippet: String::new(),
                content: String::new(),
                content_hash: 3,
                score: 0.4,
                agent: "claude_code".into(),
                source_path: "/sessions/other.jsonl".into(),
                workspace: "/w".into(),
                workspace_original: None,
                created_at: None,
                line_number: Some(1),
                match_type: MatchType::Exact,
                source_id: "local".into(),
                origin_kind: "local".into(),
                origin_host: None,
            },
        ];
        app.panes.push(AgentPane {
            agent: "claude_code".into(),
            hits,
            selected: 0,
            total_count: 3,
        });
        app.active_pane = 0;

        let _ = app.update(CassMsg::DetailOpened);

        assert_eq!(app.detail_session_hit_lines, vec![2, 5]);
        assert_eq!(app.detail_session_hit_current, 0);
    }

    #[test]
    fn regression_build_messages_marks_session_hits_and_caches_offsets() {
        let mut app = app_with_cached_conversation();
        app.detail_session_hit_lines = vec![1, 4, 6];
        let hit = make_test_hit();
        let styles = StyleContext::from_options(StyleOptions::default());
        let lines = app.build_messages_lines(&hit, 120, &styles);
        let text: String = lines
            .iter()
            .flat_map(|l| l.spans().iter().map(|s| s.content.as_ref().to_string()))
            .collect();

        assert!(
            text.contains("search hit 1/3"),
            "first contextual hit badge should render"
        );
        assert!(
            text.contains("search hit 2/3"),
            "second contextual hit badge should render"
        );
        assert!(
            text.contains("search hit 3/3"),
            "third contextual hit badge should render"
        );
        assert_eq!(
            app.detail_session_hit_offsets_cache.borrow().len(),
            3,
            "render should capture one offset per contextual hit"
        );
    }

    #[test]
    fn regression_detail_session_hit_navigation_cycles_offsets() {
        let mut app = app_with_cached_conversation();
        app.show_detail_modal = true;
        app.detail_tab = DetailTab::Messages;
        app.detail_session_hit_current = 0;
        *app.detail_session_hit_offsets_cache.borrow_mut() = vec![10, 30, 50];

        let _ = app.update(CassMsg::DetailSessionHitNavigated { forward: true });
        assert_eq!(app.detail_session_hit_current, 1);
        assert_eq!(app.detail_scroll, 27);

        let _ = app.update(CassMsg::DetailSessionHitNavigated { forward: false });
        assert_eq!(app.detail_session_hit_current, 0);
        assert_eq!(app.detail_scroll, 7);
    }

    #[test]
    fn regression_detail_open_cache_hit_uses_cached_conversation_without_reload() {
        let mut app = app_with_cached_conversation();
        // app_with_cached_conversation already aligns hit[0].source_path ("/path/0")
        // with cached_detail key ("/path/0"), so no override needed.

        let cmd = app.update(CassMsg::DetailOpened);

        assert!(
            extract_msg(cmd).is_none(),
            "cache hit should not dispatch detail reload"
        );
        assert!(app.show_detail_modal, "detail modal should open");
        assert!(
            app.loading_context.is_none(),
            "cache hit should not leave detail modal loading state"
        );

        let (cached_path, cached_view) = app
            .cached_detail
            .as_ref()
            .expect("cached detail should remain loaded");
        assert_eq!(cached_path, "/path/0");
        assert_eq!(cached_view.messages.len(), 6);
        assert!(
            cached_view.messages[0].content.contains("fix a bug"),
            "cached conversation should remain intact after open"
        );
    }

    #[test]
    fn regression_detail_open_auto_collapses_tool_system() {
        let mut app = app_with_cached_conversation();
        let _ = app.update(CassMsg::DetailOpened);
        // Tool (index 2) and System (index 4) should be collapsed
        assert!(
            app.collapsed_tools.contains(&2),
            "tool message should be auto-collapsed"
        );
        assert!(
            app.collapsed_tools.contains(&4),
            "system message should be auto-collapsed"
        );
        // User (0, 5) and Agent (1, 3) should NOT be collapsed
        assert!(!app.collapsed_tools.contains(&0));
        assert!(!app.collapsed_tools.contains(&1));
        assert!(!app.collapsed_tools.contains(&3));
        assert!(!app.collapsed_tools.contains(&5));
    }

    #[test]
    fn regression_expand_all_then_collapse_all_roundtrip() {
        let mut app = app_with_cached_conversation();
        let _ = app.update(CassMsg::DetailOpened);
        let initial_collapsed = app.collapsed_tools.len();
        assert!(initial_collapsed > 0, "some should be auto-collapsed");

        let _ = app.update(CassMsg::ToolExpandAll);
        assert!(app.collapsed_tools.is_empty(), "expand all should clear");

        let _ = app.update(CassMsg::ToolCollapseAll);
        assert_eq!(
            app.collapsed_tools.len(),
            initial_collapsed,
            "collapse all should restore same set"
        );
    }

    #[test]
    fn regression_message_navigation_forward_backward_consistent() {
        let mut app = app_with_cached_conversation();
        // Manually set message offsets to simulate rendered state
        *app.detail_message_offsets.borrow_mut() = vec![
            (0, crate::model::types::MessageRole::User),
            (5, crate::model::types::MessageRole::Agent),
            (15, crate::model::types::MessageRole::Tool),
            (20, crate::model::types::MessageRole::Agent),
            (30, crate::model::types::MessageRole::System),
            (35, crate::model::types::MessageRole::User),
        ];
        app.detail_scroll = 0;

        // Jump forward through all messages
        let _ = app.update(CassMsg::DetailMessageJumped {
            forward: true,
            user_only: false,
        });
        assert_eq!(app.detail_scroll, 5);

        let _ = app.update(CassMsg::DetailMessageJumped {
            forward: true,
            user_only: false,
        });
        assert_eq!(app.detail_scroll, 15);

        // Jump backward
        let _ = app.update(CassMsg::DetailMessageJumped {
            forward: false,
            user_only: false,
        });
        assert_eq!(app.detail_scroll, 5);
    }

    #[test]
    fn regression_markdown_gfm_message_content_renders_expected_sections() {
        let app = app_with_cached_conversation();
        let hit = make_test_hit();
        let styles = StyleContext::from_options(StyleOptions::default());
        let lines = app.build_messages_lines(&hit, 120, &styles);
        let text: String = lines
            .iter()
            .flat_map(|l| l.spans().iter().map(|s| s.content.as_ref().to_string()))
            .collect();

        assert!(
            text.contains("Analysis"),
            "markdown heading should render in detail modal output"
        );
        assert!(
            text.contains("fn main()"),
            "fenced code block content should render in detail modal output"
        );
        assert!(
            text.contains("println!"),
            "syntax-highlighted code content should remain visible"
        );
    }

    #[test]
    fn regression_user_only_navigation_skips_non_user() {
        let mut app = app_with_cached_conversation();
        *app.detail_message_offsets.borrow_mut() = vec![
            (0, crate::model::types::MessageRole::User),
            (5, crate::model::types::MessageRole::Agent),
            (15, crate::model::types::MessageRole::Tool),
            (20, crate::model::types::MessageRole::Agent),
            (30, crate::model::types::MessageRole::System),
            (35, crate::model::types::MessageRole::User),
        ];
        app.detail_scroll = 0;

        let _ = app.update(CassMsg::DetailMessageJumped {
            forward: true,
            user_only: true,
        });
        assert_eq!(
            app.detail_scroll, 35,
            "should skip Agent/Tool/System to next User"
        );

        let _ = app.update(CassMsg::DetailMessageJumped {
            forward: false,
            user_only: true,
        });
        assert_eq!(app.detail_scroll, 0, "should jump back to first User");
    }

    #[test]
    fn regression_detail_find_navigation_uses_rendered_match_cache() {
        let mut app = app_with_cached_conversation();
        // app_with_cached_conversation already aligns hit[0] and cached_detail
        // to "/path/0" so DetailOpened takes the cache-hit branch.

        let _ = app.update(CassMsg::DetailOpened);
        let _ = app.update(CassMsg::DetailFindToggled);
        let _ = app.update(CassMsg::DetailFindQueryChanged("bug".to_string()));
        let _ = render_at_degradation(&app, 120, 24, ftui::render::budget::DegradationLevel::Full);

        let cached_matches = app.detail_find_matches_cache.borrow().clone();
        assert!(
            cached_matches.len() >= 2,
            "expected at least two rendered matches for navigation"
        );

        let _ = app.update(CassMsg::DetailFindNavigated { forward: true });

        let find = app
            .detail_find
            .as_ref()
            .expect("detail find state should remain active");
        assert_eq!(
            find.matches, cached_matches,
            "navigation should sync matches from render cache"
        );
        assert_eq!(
            find.current, 1,
            "forward navigation should advance to the next match"
        );
        assert_eq!(
            app.detail_scroll,
            cached_matches[1].saturating_sub(3),
            "navigation should auto-scroll near the current match"
        );
    }

    #[test]
    fn regression_metadata_header_omits_token_metrics() {
        let app = app_with_cached_conversation();
        let hit = make_test_hit();
        let styles = StyleContext::from_options(StyleOptions::default());
        let lines = app.build_detail_header_lines(&hit, 80, &styles);
        let text: String = lines
            .iter()
            .flat_map(|l| l.spans().iter().map(|s| s.content.as_ref().to_string()))
            .collect();
        assert!(
            !text.contains("tok"),
            "header should omit token metrics, got: {text}"
        );
    }

    #[test]
    fn regression_metadata_header_shows_message_counts() {
        let app = app_with_cached_conversation();
        let hit = make_test_hit();
        let styles = StyleContext::from_options(StyleOptions::default());
        let lines = app.build_detail_header_lines(&hit, 80, &styles);
        let text: String = lines
            .iter()
            .flat_map(|l| l.spans().iter().map(|s| s.content.as_ref().to_string()))
            .collect();
        assert!(
            text.contains("6 msgs"),
            "header should show 6 messages, got: {text}"
        );
        assert!(text.contains("u:2"), "header should show 2 user messages");
    }

    #[test]
    fn regression_analytics_tab_shows_overview() {
        let app = app_with_cached_conversation();
        let hit = make_test_hit();
        let styles = StyleContext::from_options(StyleOptions::default());
        let lines = app.build_analytics_lines(&hit, 80, &styles);
        let text: String = lines
            .iter()
            .flat_map(|l| l.spans().iter().map(|s| s.content.as_ref().to_string()))
            .collect();
        assert!(text.contains("Overview"), "should have Overview section");
        assert!(text.contains("15"), "should show token count");
        assert!(
            text.contains("Message Breakdown"),
            "should have breakdown section"
        );
    }

    #[test]
    fn regression_tab_cycling_full_loop() {
        let mut app = CassApp::default();
        app.show_detail_modal = true;
        let tabs = [
            DetailTab::Messages,
            DetailTab::Snippets,
            DetailTab::Raw,
            DetailTab::Json,
            DetailTab::Analytics,
            DetailTab::Messages, // back to start
        ];
        for expected in &tabs {
            assert_eq!(app.detail_tab, *expected);
            let _ = app.update(CassMsg::FocusToggled);
        }
    }

    #[test]
    fn regression_detail_close_clears_focus_trap() {
        let mut app = app_with_hits(3);
        let _ = app.update(CassMsg::DetailOpened);
        assert!(app.show_detail_modal);
        let _ = app.update(CassMsg::DetailClosed);
        assert!(!app.show_detail_modal);
        assert_eq!(app.focus_manager.current(), Some(focus_ids::RESULTS_LIST));
    }

    #[test]
    fn regression_build_messages_populates_offsets() {
        let app = app_with_cached_conversation();
        let hit = make_test_hit();
        let styles = StyleContext::from_options(StyleOptions::default());
        let _ = app.build_messages_lines(&hit, 80, &styles);
        let offsets = app.detail_message_offsets.borrow();
        assert_eq!(offsets.len(), 6, "should have offsets for all 6 messages");
        // Offsets should be monotonically increasing
        for i in 1..offsets.len() {
            assert!(
                offsets[i].0 >= offsets[i - 1].0,
                "offsets should be monotonically increasing"
            );
        }
    }

    #[test]
    fn regression_collapsed_message_renders_truncated() {
        let mut app = app_with_cached_conversation();
        app.collapsed_tools.insert(2); // Collapse tool message (index 2)
        let hit = make_test_hit();
        let styles = StyleContext::from_options(StyleOptions::default());
        let lines = app.build_messages_lines(&hit, 80, &styles);
        // Find the tool message's rendered output — should have collapse indicator
        let text: String = lines
            .iter()
            .flat_map(|l| l.spans().iter().map(|s| s.content.as_ref().to_string()))
            .collect();
        // Should contain the triangle right indicator for collapsed
        assert!(
            text.contains('\u{25b6}'),
            "collapsed message should show \u{25b6} indicator"
        );
    }

    // -- End detail modal regression tests ------------------------------------

    #[test]
    fn analytics_surface_clears_search_regions() {
        let mut app = app_with_hits(3);
        // Render on search surface first to populate regions.
        render_at_degradation(&app, 120, 24, ftui::render::budget::DegradationLevel::Full);
        assert!(app.last_results_inner.borrow().is_some());

        // Switch to analytics.
        let _ = app.update(CassMsg::AnalyticsEntered);
        render_at_degradation(&app, 120, 24, ftui::render::budget::DegradationLevel::Full);
        assert!(
            app.last_results_inner.borrow().is_none(),
            "analytics surface should clear results inner"
        );
        assert!(
            app.last_split_handle_area.borrow().is_none(),
            "analytics surface should clear split handle"
        );
    }

    #[test]
    fn split_handle_absent_prevents_drag() {
        let mut app = app_with_hits(3);
        // Narrow mode: no split handle.
        render_at_degradation(&app, 60, 24, ftui::render::budget::DegradationLevel::Full);

        // Simulate a drag at a position that would be the split handle in dual mode.
        // Since split handle is None, this should be a no-op (no pane_split_drag started).
        let _ = app.update(CassMsg::MouseEvent {
            kind: MouseEventKind::LeftDrag,
            x: 30,
            y: 10,
        });
        assert!(
            app.pane_split_drag.is_none(),
            "drag in narrow mode should not start split drag"
        );
    }

    // =====================================================================
    // 2dccg.9.1 — Pane chrome & focus clarity
    // =====================================================================

    #[test]
    fn split_handle_rendered_in_dual_pane() {
        let app = app_with_hits(3);
        let buf =
            render_at_degradation(&app, 120, 24, ftui::render::budget::DegradationLevel::Full);
        let text = ftui_harness::buffer_to_text(&buf);
        // Dual-pane at 120 cols should render the split handle divider.
        assert!(
            text.contains('\u{2502}'),
            "120-col dual-pane should render vertical divider"
        );
    }

    #[test]
    fn single_pane_has_no_split_handle() {
        let app = app_with_hits(3);
        let _buf =
            render_at_degradation(&app, 60, 24, ftui::render::budget::DegradationLevel::Full);
        // Narrow: single-pane, no split handle area.
        assert!(
            app.last_split_handle_area.borrow().is_none(),
            "60-col narrow should not have split handle"
        );
    }

    #[test]
    fn pane_titles_render_in_output() {
        let app = app_with_hits(3);
        let buf =
            render_at_degradation(&app, 120, 24, ftui::render::budget::DegradationLevel::Full);
        let text = ftui_harness::buffer_to_text(&buf);
        assert!(text.contains("Results"), "should render Results pane title");
        assert!(text.contains("Detail"), "should render Detail pane title");
    }

    // =====================================================================
    // 1mfw3.4.4 — Ultra-narrow fallback
    // =====================================================================

    #[test]
    fn ultra_narrow_threshold() {
        assert!(LayoutBreakpoint::is_ultra_narrow(29, 10));
        assert!(LayoutBreakpoint::is_ultra_narrow(50, 5));
        assert!(LayoutBreakpoint::is_ultra_narrow(10, 3));
        assert!(!LayoutBreakpoint::is_ultra_narrow(30, 6));
        assert!(!LayoutBreakpoint::is_ultra_narrow(80, 24));
    }

    #[test]
    fn ultra_narrow_render_no_panic() {
        use ftui_harness::buffer_to_text;
        // Very small terminal should render fallback message, not panic
        for (w, h) in [(10, 3), (20, 5), (25, 4), (5, 2), (1, 1)] {
            let app = CassApp::default();
            let buf =
                render_at_degradation(&app, w, h, ftui::render::budget::DegradationLevel::Full);
            let text = buffer_to_text(&buf);
            // Should NOT contain search bar or status footer chrome
            assert!(
                !text.contains("cass analytics"),
                "ultra-narrow at {w}x{h} should not show analytics chrome"
            );
        }
    }

    #[test]
    fn ultra_narrow_shows_resize_hint() {
        use ftui_harness::buffer_to_text;
        let app = CassApp::default();
        let buf = render_at_degradation(&app, 25, 5, ftui::render::budget::DegradationLevel::Full);
        let text = buffer_to_text(&buf);
        assert!(
            text.contains("too small") || text.contains("resize"),
            "ultra-narrow should show resize hint, got: {text}"
        );
    }

    #[test]
    fn normal_size_not_ultra_narrow() {
        use ftui_harness::buffer_to_text;
        let app = CassApp::default();
        let buf = render_at_degradation(&app, 80, 24, ftui::render::budget::DegradationLevel::Full);
        let text = buffer_to_text(&buf);
        // Normal terminal should show the app chrome, not the fallback
        assert!(
            text.contains("cass"),
            "normal size should render full UI with app name"
        );
    }

    // =====================================================================
    // 1mfw3.4.3 — Visibility policy
    // =====================================================================

    #[test]
    fn visibility_narrow_hides_theme_and_hints() {
        let v = LayoutBreakpoint::Narrow.visibility_policy();
        assert!(!v.show_theme_in_title);
        assert_eq!(v.footer_hint_slots, 0);
        assert_eq!(v.footer_hint_budget, 0);
    }

    #[test]
    fn visibility_medium_narrow_shows_theme() {
        let v = LayoutBreakpoint::MediumNarrow.visibility_policy();
        assert!(v.show_theme_in_title);
        assert_eq!(v.footer_hint_slots, 2);
        assert_eq!(v.footer_hint_budget, 22);
    }

    #[test]
    fn visibility_wide_full_hints() {
        let v = LayoutBreakpoint::Wide.visibility_policy();
        assert!(v.show_theme_in_title);
        assert_eq!(v.footer_hint_slots, 4);
        assert_eq!(v.footer_hint_budget, 52);
    }

    #[test]
    fn visibility_hint_budget_monotonic() {
        // Budget should increase or stay the same as breakpoint widens.
        let breakpoints = [
            LayoutBreakpoint::Narrow,
            LayoutBreakpoint::MediumNarrow,
            LayoutBreakpoint::Medium,
            LayoutBreakpoint::Wide,
        ];
        let mut prev_budget = 0u16;
        for bp in breakpoints {
            let v = bp.visibility_policy();
            assert!(
                v.footer_hint_budget >= prev_budget,
                "hint budget should be monotonically increasing"
            );
            prev_budget = v.footer_hint_budget;
        }
    }

    #[test]
    fn footer_hint_slots_uses_visibility_policy() {
        // Verify the refactored function delegates to visibility_policy.
        assert_eq!(CassApp::footer_hint_slots(40), 0); // Narrow
        assert_eq!(CassApp::footer_hint_slots(100), 2); // MediumNarrow
        assert_eq!(CassApp::footer_hint_slots(140), 4); // Medium
        assert_eq!(CassApp::footer_hint_slots(200), 4); // Wide
    }

    #[test]
    fn search_bar_shows_theme_at_medium_narrow() {
        use ftui_harness::buffer_to_text;
        let app = CassApp::default();
        let buf =
            render_at_degradation(&app, 100, 24, ftui::render::budget::DegradationLevel::Full);
        let text = buffer_to_text(&buf);
        // MediumNarrow (100 cols) should show theme name in title
        assert!(
            text.contains(app.theme_preset.name()),
            "medium-narrow should show theme name in search bar"
        );
    }

    // =====================================================================
    // 1mfw3.4.7 — Responsive regression suite (size-sweep matrix)
    // =====================================================================

    /// Size matrix covering all breakpoint tiers plus edge cases.
    const SIZE_MATRIX: &[(u16, u16, &str)] = &[
        // Ultra-narrow (fallback)
        (10, 3, "ultra-narrow-tiny"),
        (25, 5, "ultra-narrow-small"),
        // Narrow
        (30, 8, "narrow-min"),
        (60, 24, "narrow-standard"),
        (79, 24, "narrow-max"),
        // MediumNarrow
        (80, 24, "medium-narrow-min"),
        (100, 24, "medium-narrow-mid"),
        (119, 24, "medium-narrow-max"),
        // Medium
        (120, 24, "medium-min"),
        (140, 30, "medium-mid"),
        (159, 24, "medium-max"),
        // Wide
        (160, 24, "wide-min"),
        (200, 40, "wide-standard"),
        (300, 50, "wide-ultra"),
        // Height edge cases
        (120, 6, "medium-min-height"),
        (120, 100, "medium-tall"),
    ];

    #[test]
    fn size_sweep_no_panic() {
        // Every entry in the size matrix must render without panicking.
        for &(w, h, label) in SIZE_MATRIX {
            let app = app_with_hits(5);
            render_at_degradation(&app, w, h, ftui::render::budget::DegradationLevel::Full);
            // If we get here, no panic occurred.
            let _ = label; // suppress unused warning
        }
    }

    #[test]
    fn size_sweep_topology_consistency() {
        // For each non-ultra-narrow size, verify topology matches actual rendering behavior.
        for &(w, h, label) in SIZE_MATRIX {
            if LayoutBreakpoint::is_ultra_narrow(w, h) {
                continue; // ultra-narrow uses fallback, skip topology checks
            }
            // Search surface needs Fixed(5)+Min(1)+Fixed(2)=8 rows minimum
            // to populate hit regions; skip degenerate height entries.
            if h < 8 {
                continue;
            }
            let app = app_with_hits(5);
            render_at_degradation(&app, w, h, ftui::render::budget::DegradationLevel::Full);

            let bp = LayoutBreakpoint::from_width(w);
            let topo = bp.search_topology();

            if topo.dual_pane {
                assert!(
                    app.last_results_inner.borrow().is_some(),
                    "{label}: dual_pane should record results inner"
                );
                assert!(
                    app.last_detail_area.borrow().is_some(),
                    "{label}: dual_pane should record detail area"
                );
                assert!(
                    app.last_split_handle_area.borrow().is_some(),
                    "{label}: dual_pane should record split handle"
                );
            } else {
                // Single pane: only the focused pane is recorded.
                assert!(
                    app.last_split_handle_area.borrow().is_none(),
                    "{label}: single_pane should not record split handle"
                );
            }
        }
    }

    #[test]
    fn size_sweep_analytics_no_panic() {
        // Analytics surface should render cleanly at all sizes.
        for &(w, h, _label) in SIZE_MATRIX {
            let mut app = CassApp::default();
            let _ = app.update(CassMsg::AnalyticsEntered);
            render_at_degradation(&app, w, h, ftui::render::budget::DegradationLevel::Full);
        }
    }

    #[test]
    fn size_sweep_focus_toggle_invariant() {
        // Focus toggle must work correctly at every non-ultra-narrow size.
        for &(w, h, label) in SIZE_MATRIX {
            if LayoutBreakpoint::is_ultra_narrow(w, h) {
                continue;
            }
            let mut app = app_with_hits(3);
            assert_eq!(
                app.focused_region(),
                FocusRegion::Results,
                "{label}: default focus should be Results"
            );

            let _ = app.update(CassMsg::FocusToggled);
            assert_eq!(
                app.focused_region(),
                FocusRegion::Detail,
                "{label}: after toggle, focus should be Detail"
            );

            // Re-render at this size — should not panic in either focus state.
            render_at_degradation(&app, w, h, ftui::render::budget::DegradationLevel::Full);
        }
    }

    #[test]
    fn size_sweep_breakpoint_monotonic() {
        // Breakpoints should be monotonically ordered: wider terminal = wider or equal breakpoint.
        let widths: Vec<u16> = SIZE_MATRIX.iter().map(|&(w, _, _)| w).collect();
        for pair in widths.windows(2) {
            let bp_a = LayoutBreakpoint::from_width(pair[0]);
            let bp_b = LayoutBreakpoint::from_width(pair[1]);
            let rank = |bp: LayoutBreakpoint| -> u8 {
                match bp {
                    LayoutBreakpoint::Narrow => 0,
                    LayoutBreakpoint::MediumNarrow => 1,
                    LayoutBreakpoint::Medium => 2,
                    LayoutBreakpoint::Wide => 3,
                }
            };
            // Note: SIZE_MATRIX is not sorted by width, so we don't assert monotonicity
            // across the matrix. Instead verify each width classifies correctly.
            let _ = (rank(bp_a), rank(bp_b)); // suppress unused
        }
        // Verify the rank function itself is correct for known thresholds.
        let rank = |w: u16| -> u8 {
            match LayoutBreakpoint::from_width(w) {
                LayoutBreakpoint::Narrow => 0,
                LayoutBreakpoint::MediumNarrow => 1,
                LayoutBreakpoint::Medium => 2,
                LayoutBreakpoint::Wide => 3,
            }
        };
        assert!(rank(79) < rank(80));
        assert!(rank(119) < rank(120));
        assert!(rank(159) < rank(160));
    }

    #[test]
    fn size_sweep_visibility_policy_stable() {
        // Visibility policy should be deterministic for a given width.
        for &(w, _, _) in SIZE_MATRIX {
            let bp = LayoutBreakpoint::from_width(w);
            let v1 = bp.visibility_policy();
            let v2 = bp.visibility_policy();
            assert_eq!(
                v1, v2,
                "visibility policy should be deterministic for w={w}"
            );
        }
    }

    // =====================================================================
    // 2noh9.4.10 — Advanced navigation (grouping, timeline jump)
    // =====================================================================

    #[test]
    fn grouping_cycles_through_all_modes() {
        assert_eq!(ResultsGrouping::Agent.next(), ResultsGrouping::Conversation);
        assert_eq!(
            ResultsGrouping::Conversation.next(),
            ResultsGrouping::Workspace
        );
        assert_eq!(ResultsGrouping::Workspace.next(), ResultsGrouping::Flat);
        assert_eq!(ResultsGrouping::Flat.next(), ResultsGrouping::Agent);
    }

    #[test]
    fn grouping_labels_are_distinct() {
        let labels: Vec<&str> = [
            ResultsGrouping::Agent,
            ResultsGrouping::Conversation,
            ResultsGrouping::Workspace,
            ResultsGrouping::Flat,
        ]
        .iter()
        .map(|g| g.label())
        .collect();
        let set: std::collections::HashSet<&&str> = labels.iter().collect();
        assert_eq!(set.len(), 4, "all grouping labels should be unique");
    }

    #[test]
    fn regroup_panes_by_agent() {
        let mut app = CassApp::default();
        let mut h1 = make_hit(1, "/a");
        h1.agent = "claude_code".into();
        let mut h2 = make_hit(2, "/b");
        h2.agent = "codex".into();
        let mut h3 = make_hit(3, "/c");
        h3.agent = "claude_code".into();
        app.results = vec![h1, h2, h3];
        app.grouping_mode = ResultsGrouping::Agent;
        app.regroup_panes();
        assert_eq!(app.panes.len(), 2);
        assert_eq!(app.panes[0].agent, "claude_code");
        assert_eq!(app.panes[0].hits.len(), 2);
        assert_eq!(app.panes[1].agent, "codex");
    }

    #[test]
    fn regroup_panes_flat_creates_single_pane() {
        let mut app = CassApp::default();
        let mut h1 = make_hit(1, "/a");
        h1.agent = "claude_code".into();
        let mut h2 = make_hit(2, "/b");
        h2.agent = "codex".into();
        app.results = vec![h1, h2];
        app.grouping_mode = ResultsGrouping::Flat;
        app.regroup_panes();
        assert_eq!(app.panes.len(), 1, "flat mode should produce one pane");
        assert_eq!(app.panes[0].agent, "All");
        assert_eq!(app.panes[0].hits.len(), 2);
    }

    #[test]
    fn regroup_panes_by_workspace() {
        let mut app = CassApp::default();
        let mut h1 = make_hit(1, "/a");
        h1.workspace = "/home/user/project-a".into();
        let mut h2 = make_hit(2, "/b");
        h2.workspace = "/home/user/project-b".into();
        let mut h3 = make_hit(3, "/c");
        h3.workspace = "/home/user/project-a".into();
        app.results = vec![h1, h2, h3];
        app.grouping_mode = ResultsGrouping::Workspace;
        app.regroup_panes();
        assert_eq!(app.panes.len(), 2);
        assert_eq!(app.panes[0].agent, "project-a");
        assert_eq!(app.panes[0].hits.len(), 2);
        assert_eq!(app.panes[1].agent, "project-b");
    }

    #[test]
    fn regroup_panes_by_conversation() {
        let mut app = CassApp::default();
        // Last path component is used as the conversation key.
        let h1 = make_hit(1, "/sessions/conv-aaa");
        let h2 = make_hit(2, "/sessions/conv-bbb");
        let h3 = make_hit(3, "/sessions/conv-aaa");
        app.results = vec![h1, h2, h3];
        app.grouping_mode = ResultsGrouping::Conversation;
        app.regroup_panes();
        assert_eq!(app.panes.len(), 2);
        assert_eq!(app.panes[0].agent, "conv-aaa");
        assert_eq!(app.panes[0].hits.len(), 2);
        assert_eq!(app.panes[1].agent, "conv-bbb");
    }

    #[test]
    fn grouping_cycled_msg_changes_mode_and_regroups() {
        let mut app = CassApp::default();
        let mut h1 = make_hit(1, "/a");
        h1.agent = "claude_code".into();
        let mut h2 = make_hit(2, "/b");
        h2.agent = "codex".into();
        app.results = vec![h1, h2];
        app.panes.push(AgentPane {
            agent: "claude_code".into(),
            hits: vec![],
            selected: 0,
            total_count: 0,
        });
        let _ = app.update(CassMsg::GroupingCycled);
        assert_eq!(app.grouping_mode, ResultsGrouping::Conversation);
        assert!(app.status.contains("Grouping:"));
    }

    #[test]
    fn timeline_jump_finds_next_day() {
        let mut app = CassApp::default();
        let day1 = 86400 * 19000; // some day
        let day2 = 86400 * 19001; // next day
        let mut hits: Vec<SearchHit> = Vec::new();
        for i in 0..3 {
            let mut h = make_hit(i, &format!("/p/{i}"));
            h.created_at = Some(day1 + i as i64);
            hits.push(h);
        }
        for i in 3..6 {
            let mut h = make_hit(i, &format!("/p/{i}"));
            h.created_at = Some(day2 + i as i64);
            hits.push(h);
        }
        app.panes.push(AgentPane {
            agent: "test".into(),
            total_count: hits.len(),
            hits,
            selected: 0,
        });
        // Jump forward from day1 → should land on index 3 (first of day2)
        let idx = app.timeline_jump_index(true);
        assert_eq!(idx, Some(3));
    }

    #[test]
    fn timeline_jump_finds_prev_day() {
        let mut app = CassApp::default();
        let day1 = 86400 * 19000;
        let day2 = 86400 * 19001;
        let mut hits: Vec<SearchHit> = Vec::new();
        for i in 0..3 {
            let mut h = make_hit(i, &format!("/p/{i}"));
            h.created_at = Some(day1 + i as i64);
            hits.push(h);
        }
        for i in 3..6 {
            let mut h = make_hit(i, &format!("/p/{i}"));
            h.created_at = Some(day2 + i as i64);
            hits.push(h);
        }
        app.panes.push(AgentPane {
            agent: "test".into(),
            total_count: hits.len(),
            hits,
            selected: 4, // in day2
        });
        // Jump backward from day2 → should land on index 0 (first of day1)
        let idx = app.timeline_jump_index(false);
        assert_eq!(idx, Some(0));
    }

    #[test]
    fn timeline_jump_returns_none_at_boundary() {
        let mut app = CassApp::default();
        let day1 = 86400 * 19000;
        let mut hits: Vec<SearchHit> = Vec::new();
        for i in 0..3 {
            let mut h = make_hit(i, &format!("/p/{i}"));
            h.created_at = Some(day1 + i as i64);
            hits.push(h);
        }
        app.panes.push(AgentPane {
            agent: "test".into(),
            total_count: hits.len(),
            hits,
            selected: 0,
        });
        // No previous day
        assert_eq!(app.timeline_jump_index(false), None);
        // No next day
        assert_eq!(app.timeline_jump_index(true), None);
    }

    #[test]
    fn timeline_jumped_msg_moves_selection() {
        let mut app = CassApp::default();
        let day1 = 86400 * 19000;
        let day2 = 86400 * 19001;
        let mut hits: Vec<SearchHit> = Vec::new();
        for i in 0..3 {
            let mut h = make_hit(i, &format!("/p/{i}"));
            h.created_at = Some(day1 + i as i64);
            hits.push(h);
        }
        for i in 3..5 {
            let mut h = make_hit(i, &format!("/p/{i}"));
            h.created_at = Some(day2 + i as i64);
            hits.push(h);
        }
        app.panes.push(AgentPane {
            agent: "test".into(),
            total_count: hits.len(),
            hits,
            selected: 0,
        });
        let _ = app.update(CassMsg::TimelineJumped { forward: true });
        assert_eq!(
            app.panes[0].selected, 3,
            "should jump to first hit of next day"
        );
        assert!(app.status.contains("next day"));
    }

    #[test]
    fn results_title_shows_grouping_mode() {
        let mut app = app_with_hits(3);
        app.grouping_mode = ResultsGrouping::Workspace;
        // Render so render_results_pane is called and title is built.
        render_at_degradation(&app, 120, 24, ftui::render::budget::DegradationLevel::Full);
        // The title itself is local to render_results_pane so we can't read it directly,
        // but we can verify the grouping_mode.label() is non-empty and differs from Agent.
        assert_ne!(app.grouping_mode.label(), "by agent");
        assert_eq!(app.grouping_mode.label(), "by workspace");
    }

    #[test]
    fn regroup_clamps_active_pane() {
        let mut app = CassApp::default();
        let h1 = make_hit(1, "/a");
        app.results = vec![h1];
        app.grouping_mode = ResultsGrouping::Flat;
        app.active_pane = 5; // invalid
        app.regroup_panes();
        assert_eq!(
            app.active_pane, 0,
            "active_pane should be clamped after regroup"
        );
    }

    // =====================================================================
    // 2noh9.4.11 — Undo/redo
    // =====================================================================

    #[test]
    fn undo_history_push_and_pop() {
        let mut hist = UndoHistory::default();
        let e1 = UndoEntry {
            description: "edit 1",
            query: "hello".into(),
            cursor_pos: 5,
            filters: SearchFilters::default(),
            time_preset: TimePreset::All,
            ranking_mode: RankingMode::default(),
            grouping_mode: ResultsGrouping::Agent,
        };
        hist.push(e1);
        assert!(hist.can_undo());
        assert!(!hist.can_redo());

        let current = UndoEntry {
            description: "current",
            query: "world".into(),
            cursor_pos: 5,
            filters: SearchFilters::default(),
            time_preset: TimePreset::All,
            ranking_mode: RankingMode::default(),
            grouping_mode: ResultsGrouping::Agent,
        };
        let restored = hist.pop_undo(current).unwrap();
        assert_eq!(restored.query, "hello");
        assert!(!hist.can_undo());
        assert!(hist.can_redo());
    }

    #[test]
    fn undo_history_redo_after_undo() {
        let mut hist = UndoHistory::default();
        let e1 = UndoEntry {
            description: "edit",
            query: "before".into(),
            cursor_pos: 6,
            filters: SearchFilters::default(),
            time_preset: TimePreset::All,
            ranking_mode: RankingMode::default(),
            grouping_mode: ResultsGrouping::Agent,
        };
        hist.push(e1);

        let current = UndoEntry {
            description: "current",
            query: "after".into(),
            cursor_pos: 5,
            filters: SearchFilters::default(),
            time_preset: TimePreset::All,
            ranking_mode: RankingMode::default(),
            grouping_mode: ResultsGrouping::Agent,
        };
        let _ = hist.pop_undo(current);

        let re_current = UndoEntry {
            description: "re_current",
            query: "before".into(),
            cursor_pos: 6,
            filters: SearchFilters::default(),
            time_preset: TimePreset::All,
            ranking_mode: RankingMode::default(),
            grouping_mode: ResultsGrouping::Agent,
        };
        let redone = hist.pop_redo(re_current).unwrap();
        assert_eq!(redone.query, "after");
    }

    #[test]
    fn undo_history_push_clears_redo() {
        let mut hist = UndoHistory::default();
        let e1 = UndoEntry {
            description: "e1",
            query: "a".into(),
            cursor_pos: 1,
            filters: SearchFilters::default(),
            time_preset: TimePreset::All,
            ranking_mode: RankingMode::default(),
            grouping_mode: ResultsGrouping::Agent,
        };
        hist.push(e1);
        let current = UndoEntry {
            description: "cur",
            query: "b".into(),
            cursor_pos: 1,
            filters: SearchFilters::default(),
            time_preset: TimePreset::All,
            ranking_mode: RankingMode::default(),
            grouping_mode: ResultsGrouping::Agent,
        };
        let _ = hist.pop_undo(current);
        assert!(hist.can_redo());

        // New push clears redo.
        let e2 = UndoEntry {
            description: "e2",
            query: "c".into(),
            cursor_pos: 1,
            filters: SearchFilters::default(),
            time_preset: TimePreset::All,
            ranking_mode: RankingMode::default(),
            grouping_mode: ResultsGrouping::Agent,
        };
        hist.push(e2);
        assert!(!hist.can_redo());
    }

    #[test]
    fn undo_history_respects_max_depth() {
        let mut hist = UndoHistory {
            undo_stack: Vec::new(),
            redo_stack: Vec::new(),
            max_depth: 3,
        };
        for i in 0..5 {
            hist.push(UndoEntry {
                description: "push",
                query: format!("q{i}"),
                cursor_pos: i,
                filters: SearchFilters::default(),
                time_preset: TimePreset::All,
                ranking_mode: RankingMode::default(),
                grouping_mode: ResultsGrouping::Agent,
            });
        }
        assert_eq!(hist.undo_stack.len(), 3);
        assert_eq!(hist.undo_stack[0].query, "q2", "oldest should be evicted");
    }

    #[test]
    fn undo_msg_restores_query_state() {
        let mut app = CassApp::default();
        app.query = "hello".into();
        app.cursor_pos = 5;
        let _ = app.update(CassMsg::QueryCleared);
        assert_eq!(app.query, "");

        let _ = app.update(CassMsg::Undo);
        assert_eq!(app.query, "hello");
        assert_eq!(app.cursor_pos, 5);
    }

    #[test]
    fn redo_msg_restores_after_undo() {
        let mut app = CassApp::default();
        app.query = "test".into();
        app.cursor_pos = 4;
        let _ = app.update(CassMsg::QueryCleared);
        assert_eq!(app.query, "");

        let _ = app.update(CassMsg::Undo);
        assert_eq!(app.query, "test");

        let _ = app.update(CassMsg::Redo);
        assert_eq!(app.query, "");
    }

    #[test]
    fn undo_filter_change_restores_agents() {
        let mut app = CassApp::default();
        assert!(app.filters.agents.is_empty());

        let agents: HashSet<String> = ["claude_code".to_string()].into_iter().collect();
        let _ = app.update(CassMsg::FilterAgentSet(agents));
        assert_eq!(app.filters.agents.len(), 1);

        let _ = app.update(CassMsg::Undo);
        assert!(app.filters.agents.is_empty());
    }

    #[test]
    fn undo_nothing_sets_status() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::Undo);
        assert!(app.status.contains("Nothing to undo"));
    }

    #[test]
    fn redo_nothing_sets_status() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::Redo);
        assert!(app.status.contains("Nothing to redo"));
    }

    #[test]
    fn undo_grouping_cycle_restores_mode() {
        let mut app = CassApp::default();
        assert_eq!(app.grouping_mode, ResultsGrouping::Agent);
        let _ = app.update(CassMsg::GroupingCycled);
        assert_eq!(app.grouping_mode, ResultsGrouping::Conversation);
        let _ = app.update(CassMsg::Undo);
        assert_eq!(app.grouping_mode, ResultsGrouping::Agent);
    }

    #[test]
    fn undo_clear_all_filters_restores_state() {
        let mut app = CassApp::default();
        let agents: HashSet<String> = ["codex".to_string()].into_iter().collect();
        app.filters.agents = agents.clone();
        app.time_preset = TimePreset::Week;

        let _ = app.update(CassMsg::FiltersClearAll);
        assert!(app.filters.agents.is_empty());
        assert_eq!(app.time_preset, TimePreset::All);

        let _ = app.update(CassMsg::Undo);
        assert_eq!(app.filters.agents, agents);
        assert_eq!(app.time_preset, TimePreset::Week);
    }

    #[test]
    fn analytics_selection_wraps_around() {
        let mut app = CassApp::default();
        app.surface = AppSurface::Analytics;
        app.analytics_view = AnalyticsView::Breakdowns;
        let mut data = AnalyticsChartData::default();
        data.agent_tokens = vec![
            ("claude_code".into(), 100.0),
            ("codex".into(), 80.0),
            ("gemini".into(), 50.0),
        ];
        app.analytics_cache = Some(data);
        app.analytics_selection = 0;

        let _ = app.update(CassMsg::AnalyticsSelectionMoved { delta: 1 });
        assert_eq!(app.analytics_selection, 1);
        let _ = app.update(CassMsg::AnalyticsSelectionMoved { delta: 1 });
        assert_eq!(app.analytics_selection, 2);
        let _ = app.update(CassMsg::AnalyticsSelectionMoved { delta: 1 });
        assert_eq!(app.analytics_selection, 0, "should wrap to start");
        let _ = app.update(CassMsg::AnalyticsSelectionMoved { delta: -1 });
        assert_eq!(app.analytics_selection, 2, "should wrap to end");
    }

    #[test]
    fn analytics_enter_on_breakdowns_triggers_drilldown() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::AnalyticsEntered);
        app.analytics_view = AnalyticsView::Breakdowns;
        let mut data = AnalyticsChartData::default();
        data.agent_tokens = vec![("claude_code".into(), 100.0), ("codex".into(), 80.0)];
        app.analytics_cache = Some(data);
        app.analytics_selection = 1;

        let _ = app.update(CassMsg::DetailOpened);
        assert_eq!(app.surface, AppSurface::Search);
        let expected: HashSet<String> = ["codex"].iter().map(|s| s.to_string()).collect();
        assert_eq!(app.filters.agents, expected);
    }

    #[test]
    fn analytics_enter_on_dashboard_is_noop() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::AnalyticsEntered);
        app.analytics_view = AnalyticsView::Dashboard;
        app.analytics_cache = Some(AnalyticsChartData::default());

        let _ = app.update(CassMsg::DetailOpened);
        assert_eq!(app.surface, AppSurface::Analytics);
    }

    #[test]
    fn analytics_view_change_resets_selection() {
        let mut app = CassApp::default();
        app.analytics_selection = 5;
        let _ = app.update(CassMsg::AnalyticsViewChanged(AnalyticsView::Tools));
        assert_eq!(app.analytics_selection, 0);
    }

    #[test]
    fn analytics_left_right_cycles_views() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::AnalyticsEntered);
        assert_eq!(app.analytics_view, AnalyticsView::Dashboard);

        let _ = app.update(CassMsg::CursorMoved { delta: 1 });
        assert_eq!(app.analytics_view, AnalyticsView::Explorer);
        let _ = app.update(CassMsg::CursorMoved { delta: -1 });
        assert_eq!(app.analytics_view, AnalyticsView::Dashboard);
        let _ = app.update(CassMsg::CursorMoved { delta: -1 });
        assert_eq!(app.analytics_view, AnalyticsView::Coverage);
    }

    #[test]
    fn build_drilldown_context_explorer_bucket() {
        let mut app = CassApp::default();
        app.analytics_view = AnalyticsView::Explorer;
        let mut data = AnalyticsChartData::default();
        data.daily_tokens = vec![
            ("2026-02-05".into(), 100.0),
            ("2026-02-06".into(), 200.0),
            ("2026-02-07".into(), 150.0),
        ];
        app.analytics_cache = Some(data);
        app.analytics_selection = 1;

        let ctx = app.build_drilldown_context().expect("should build context");
        assert!(ctx.since_ms.is_some());
        assert!(ctx.until_ms.is_some());
        let since = ctx.since_ms.unwrap();
        let until = ctx.until_ms.unwrap();
        assert_eq!(until - since, 86_400_000);
        assert!(ctx.agent.is_none());
        assert!(ctx.workspace.is_none());
        assert!(ctx.source_filter.is_none());
        assert!(ctx.model.is_none());
    }

    #[test]
    fn build_drilldown_context_tools_agent() {
        let mut app = CassApp::default();
        app.analytics_view = AnalyticsView::Tools;
        let mut data = AnalyticsChartData::default();
        data.tool_rows = vec![
            crate::analytics::ToolRow {
                key: "claude_code".into(),
                tool_call_count: 5000,
                message_count: 500,
                api_tokens_total: 10_000_000,
                tool_calls_per_1k_api_tokens: Some(0.5),
                tool_calls_per_1k_content_tokens: None,
            },
            crate::analytics::ToolRow {
                key: "codex".into(),
                tool_call_count: 3000,
                message_count: 300,
                api_tokens_total: 8_000_000,
                tool_calls_per_1k_api_tokens: Some(0.375),
                tool_calls_per_1k_content_tokens: None,
            },
        ];
        app.analytics_cache = Some(data);
        app.analytics_selection = 1;

        let ctx = app.build_drilldown_context().expect("should build context");
        assert_eq!(ctx.agent.as_deref(), Some("codex"));
        assert!(ctx.workspace.is_none());
        assert!(ctx.source_filter.is_none());
        assert!(ctx.model.is_none());
    }

    #[test]
    fn build_drilldown_context_workspace_breakdown() {
        let mut app = CassApp::default();
        app.analytics_view = AnalyticsView::Breakdowns;
        app.breakdown_tab = BreakdownTab::Workspace;
        let mut data = AnalyticsChartData::default();
        data.workspace_tokens = vec![("/ws/a".into(), 500.0), ("/ws/b".into(), 300.0)];
        app.analytics_cache = Some(data);
        app.analytics_selection = 1;

        let ctx = app.build_drilldown_context().expect("should build context");
        assert_eq!(ctx.workspace.as_deref(), Some("/ws/b"));
        assert!(ctx.agent.is_none());
        assert!(ctx.source_filter.is_none());
        assert!(ctx.model.is_none());
    }

    #[test]
    fn build_drilldown_context_source_breakdown() {
        let mut app = CassApp::default();
        app.analytics_view = AnalyticsView::Breakdowns;
        app.breakdown_tab = BreakdownTab::Source;
        let mut data = AnalyticsChartData::default();
        data.source_tokens = vec![("local".into(), 100.0), ("work-laptop".into(), 80.0)];
        app.analytics_cache = Some(data);
        app.analytics_selection = 1;

        let ctx = app.build_drilldown_context().expect("should build context");
        assert_eq!(
            ctx.source_filter,
            Some(SourceFilter::SourceId("work-laptop".into()))
        );
        assert!(ctx.agent.is_none());
        assert!(ctx.workspace.is_none());
        assert!(ctx.model.is_none());
    }

    #[test]
    fn tools_selectable_count_uses_tool_rows() {
        let mut app = CassApp::default();
        app.analytics_view = AnalyticsView::Tools;
        let mut data = AnalyticsChartData::default();
        data.tool_rows = vec![crate::analytics::ToolRow {
            key: "a".into(),
            tool_call_count: 100,
            message_count: 10,
            api_tokens_total: 1000,
            tool_calls_per_1k_api_tokens: None,
            tool_calls_per_1k_content_tokens: None,
        }];
        app.analytics_cache = Some(data);
        assert_eq!(app.analytics_selectable_count(), 1);
    }

    #[test]
    fn coverage_selectable_count_uses_agents() {
        let mut app = CassApp::default();
        app.analytics_view = AnalyticsView::Coverage;
        let mut data = AnalyticsChartData::default();
        data.agent_tokens = vec![("claude_code".into(), 1000.0), ("codex".into(), 500.0)];
        app.analytics_cache = Some(data);
        assert_eq!(app.analytics_selectable_count(), 2);
    }

    #[test]
    fn build_drilldown_context_coverage_agent() {
        let mut app = CassApp::default();
        app.analytics_view = AnalyticsView::Coverage;
        let mut data = AnalyticsChartData::default();
        data.agent_tokens = vec![
            ("claude_code".into(), 1000.0),
            ("codex".into(), 500.0),
            ("aider".into(), 200.0),
        ];
        app.analytics_cache = Some(data);
        app.analytics_selection = 1;

        let ctx = app.build_drilldown_context().expect("should build context");
        assert_eq!(ctx.agent.as_deref(), Some("codex"));
        assert!(ctx.workspace.is_none());
        assert!(ctx.source_filter.is_none());
        assert!(ctx.model.is_none());
    }

    // -- Explorer keyboard binding tests --

    #[test]
    fn explorer_m_key_cycles_metric_forward() {
        let mut app = CassApp::default();
        app.surface = AppSurface::Analytics;
        app.analytics_view = AnalyticsView::Explorer;
        assert_eq!(app.explorer_metric, ExplorerMetric::ApiTokens);

        let _ = app.update(CassMsg::QueryChanged("m".to_string()));
        assert_eq!(app.explorer_metric, ExplorerMetric::ContentTokens);

        let _ = app.update(CassMsg::QueryChanged("m".to_string()));
        assert_eq!(app.explorer_metric, ExplorerMetric::Messages);
    }

    #[test]
    fn explorer_shift_m_key_cycles_metric_backward() {
        let mut app = CassApp::default();
        app.surface = AppSurface::Analytics;
        app.analytics_view = AnalyticsView::Explorer;
        assert_eq!(app.explorer_metric, ExplorerMetric::ApiTokens);

        // M (shift+m) cycles backward — should wrap to PlanMessages.
        let _ = app.update(CassMsg::QueryChanged("M".to_string()));
        assert_eq!(app.explorer_metric, ExplorerMetric::PlanMessages);
    }

    #[test]
    fn explorer_o_key_cycles_overlay() {
        let mut app = CassApp::default();
        app.surface = AppSurface::Analytics;
        app.analytics_view = AnalyticsView::Explorer;
        assert_eq!(app.explorer_overlay, ExplorerOverlay::None);

        // 'o' in Explorer view cycles overlay (intercepted from OpenInEditor).
        let _ = app.update(CassMsg::OpenInEditor);
        assert_eq!(app.explorer_overlay, ExplorerOverlay::ByAgent);

        let _ = app.update(CassMsg::OpenInEditor);
        assert_eq!(app.explorer_overlay, ExplorerOverlay::ByWorkspace);

        let _ = app.update(CassMsg::OpenInEditor);
        assert_eq!(app.explorer_overlay, ExplorerOverlay::BySource);

        let _ = app.update(CassMsg::OpenInEditor);
        assert_eq!(app.explorer_overlay, ExplorerOverlay::None);
    }

    #[test]
    fn explorer_query_input_suppressed_on_analytics_surface() {
        let mut app = CassApp::default();
        app.surface = AppSurface::Analytics;
        app.analytics_view = AnalyticsView::Dashboard;

        // Non-explorer query input on analytics surface should be suppressed.
        let _ = app.update(CassMsg::QueryChanged("x".to_string()));
        assert!(
            app.query.is_empty(),
            "query should remain empty on analytics surface"
        );
    }

    #[test]
    fn explorer_g_key_cycles_group_by_forward() {
        use crate::analytics::GroupBy;
        let mut app = CassApp::default();
        app.surface = AppSurface::Analytics;
        app.analytics_view = AnalyticsView::Explorer;
        assert_eq!(app.explorer_group_by, GroupBy::Day);
        let _ = app.update(CassMsg::QueryChanged("g".to_string()));
        assert_eq!(app.explorer_group_by, GroupBy::Week);
        let _ = app.update(CassMsg::QueryChanged("g".to_string()));
        assert_eq!(app.explorer_group_by, GroupBy::Month);
        let _ = app.update(CassMsg::QueryChanged("g".to_string()));
        assert_eq!(app.explorer_group_by, GroupBy::Hour);
        let _ = app.update(CassMsg::QueryChanged("g".to_string()));
        assert_eq!(app.explorer_group_by, GroupBy::Day);
    }

    #[test]
    fn explorer_shift_g_key_cycles_group_by_backward() {
        use crate::analytics::GroupBy;
        let mut app = CassApp::default();
        app.surface = AppSurface::Analytics;
        app.analytics_view = AnalyticsView::Explorer;
        assert_eq!(app.explorer_group_by, GroupBy::Day);
        let _ = app.update(CassMsg::QueryChanged("G".to_string()));
        assert_eq!(app.explorer_group_by, GroupBy::Hour);
    }

    #[test]
    fn explorer_group_by_change_invalidates_cache() {
        let mut app = CassApp::default();
        app.surface = AppSurface::Analytics;
        app.analytics_view = AnalyticsView::Explorer;
        // Simulate a cached value.
        app.analytics_cache = Some(AnalyticsChartData::default());
        assert!(app.analytics_cache.is_some());
        let _ = app.update(CassMsg::ExplorerGroupByCycled { forward: true });
        assert!(
            app.analytics_cache.is_none(),
            "cache should be invalidated on group-by change"
        );
    }

    #[test]
    fn explorer_hour_group_by_defaults_to_week_zoom_range() {
        use crate::analytics::GroupBy;
        let mut app = CassApp::default();
        app.surface = AppSurface::Analytics;
        app.analytics_view = AnalyticsView::Explorer;
        app.explorer_zoom = ExplorerZoom::All;
        app.analytics_filters.since_ms = None;
        app.analytics_filters.until_ms = None;

        // Shift+g: Day -> Hour.
        let _ = app.update(CassMsg::ExplorerGroupByCycled { forward: false });
        assert_eq!(app.explorer_group_by, GroupBy::Hour);
        assert_eq!(app.explorer_zoom, ExplorerZoom::Week);
        assert!(
            app.analytics_filters.since_ms.is_some(),
            "hourly mode should default to a bounded 7-day range"
        );
        assert!(
            app.analytics_filters.until_ms.is_none(),
            "hourly default range should end at now"
        );
    }

    #[test]
    fn explorer_hourly_zoom_long_ranges_auto_switch_to_daily() {
        use crate::analytics::GroupBy;
        let mut app = CassApp::default();
        app.surface = AppSurface::Analytics;
        app.analytics_view = AnalyticsView::Explorer;
        app.explorer_group_by = GroupBy::Hour;
        app.explorer_zoom = ExplorerZoom::Week;

        // Week -> Month should fall back to daily granularity.
        let _ = app.update(CassMsg::ExplorerZoomCycled { forward: true });
        assert_eq!(app.explorer_zoom, ExplorerZoom::Month);
        assert_eq!(app.explorer_group_by, GroupBy::Day);

        // Day-range filters should still update for the selected zoom.
        assert!(
            app.analytics_filters.since_ms.is_some(),
            "zoom changes should continue applying time filters"
        );
    }

    #[test]
    fn explorer_hourly_zoom_within_24h_or_7d_keeps_hour_group_by() {
        use crate::analytics::GroupBy;
        let mut app = CassApp::default();
        app.surface = AppSurface::Analytics;
        app.analytics_view = AnalyticsView::Explorer;
        app.explorer_group_by = GroupBy::Hour;
        app.explorer_zoom = ExplorerZoom::Day;

        // Day -> Week should stay hourly.
        let _ = app.update(CassMsg::ExplorerZoomCycled { forward: true });
        assert_eq!(app.explorer_zoom, ExplorerZoom::Week);
        assert_eq!(app.explorer_group_by, GroupBy::Hour);
    }

    #[test]
    fn explorer_z_key_cycles_zoom_forward() {
        let mut app = CassApp::default();
        app.surface = AppSurface::Analytics;
        app.analytics_view = AnalyticsView::Explorer;
        assert_eq!(app.explorer_zoom, ExplorerZoom::All);
        let _ = app.update(CassMsg::QueryChanged("z".to_string()));
        assert_eq!(app.explorer_zoom, ExplorerZoom::Day);
        let _ = app.update(CassMsg::QueryChanged("z".to_string()));
        assert_eq!(app.explorer_zoom, ExplorerZoom::Week);
        let _ = app.update(CassMsg::QueryChanged("z".to_string()));
        assert_eq!(app.explorer_zoom, ExplorerZoom::Month);
        let _ = app.update(CassMsg::QueryChanged("z".to_string()));
        assert_eq!(app.explorer_zoom, ExplorerZoom::Quarter);
        let _ = app.update(CassMsg::QueryChanged("z".to_string()));
        assert_eq!(app.explorer_zoom, ExplorerZoom::All);
    }

    #[test]
    fn explorer_zoom_change_updates_analytics_filters() {
        let mut app = CassApp::default();
        app.surface = AppSurface::Analytics;
        app.analytics_view = AnalyticsView::Explorer;
        app.analytics_cache = Some(AnalyticsChartData::default());
        // Zoom to 7d — should set since_ms and invalidate cache.
        let _ = app.update(CassMsg::ExplorerZoomCycled { forward: true }); // All → Day
        let _ = app.update(CassMsg::ExplorerZoomCycled { forward: true }); // Day → Week
        assert_eq!(app.explorer_zoom, ExplorerZoom::Week);
        assert!(
            app.analytics_filters.since_ms.is_some(),
            "since_ms should be set for Week zoom"
        );
        assert!(
            app.analytics_cache.is_none(),
            "cache should be invalidated on zoom change"
        );
    }

    // -- Analytics UI test suite (2noh9.4.18.11) -----------------------------

    /// Helper to create a CassApp in analytics mode with representative data.
    fn analytics_app_with_data(view: AnalyticsView) -> CassApp {
        let mut app = CassApp::default();
        app.surface = AppSurface::Analytics;
        app.analytics_view = view;

        let mut data = AnalyticsChartData::default();
        // Populate representative fixture data
        data.total_messages = 5000;
        data.total_api_tokens = 1_200_000;
        data.total_tool_calls = 3000;
        data.total_content_tokens = 800_000;
        data.total_plan_messages = 200;
        data.coverage_pct = 85.0;
        data.plan_message_pct = 4.0;
        data.plan_api_token_share = 6.5;
        data.agent_tokens = vec![
            ("claude_code".into(), 600_000.0),
            ("codex".into(), 300_000.0),
            ("aider".into(), 200_000.0),
            ("gemini".into(), 100_000.0),
        ];
        data.agent_messages = vec![
            ("claude_code".into(), 2500.0),
            ("codex".into(), 1500.0),
            ("aider".into(), 700.0),
            ("gemini".into(), 300.0),
        ];
        data.agent_tool_calls = vec![
            ("claude_code".into(), 1800.0),
            ("codex".into(), 800.0),
            ("aider".into(), 300.0),
            ("gemini".into(), 100.0),
        ];
        data.workspace_tokens = vec![("cass".into(), 700_000.0), ("other".into(), 500_000.0)];
        data.workspace_messages = vec![("cass".into(), 3000.0), ("other".into(), 2000.0)];
        data.source_tokens = vec![("local".into(), 900_000.0), ("remote".into(), 300_000.0)];
        data.source_messages = vec![("local".into(), 3500.0), ("remote".into(), 1500.0)];
        data.model_tokens = vec![
            ("claude-opus-4-6".into(), 500_000.0),
            ("claude-sonnet-4-5".into(), 400_000.0),
            ("gpt-4o".into(), 300_000.0),
        ];
        data.daily_tokens = vec![
            ("2026-02-01".into(), 200_000.0),
            ("2026-02-02".into(), 180_000.0),
            ("2026-02-03".into(), 250_000.0),
            ("2026-02-04".into(), 170_000.0),
            ("2026-02-05".into(), 200_000.0),
            ("2026-02-06".into(), 100_000.0),
            ("2026-02-07".into(), 100_000.0),
        ];
        data.daily_messages = vec![
            ("2026-02-01".into(), 800.0),
            ("2026-02-02".into(), 700.0),
            ("2026-02-03".into(), 900.0),
            ("2026-02-04".into(), 600.0),
            ("2026-02-05".into(), 700.0),
            ("2026-02-06".into(), 650.0),
            ("2026-02-07".into(), 650.0),
        ];
        data.daily_content_tokens = data.daily_tokens.clone();
        data.daily_tool_calls = vec![
            ("2026-02-01".into(), 500.0),
            ("2026-02-02".into(), 400.0),
            ("2026-02-03".into(), 600.0),
            ("2026-02-04".into(), 350.0),
            ("2026-02-05".into(), 450.0),
            ("2026-02-06".into(), 350.0),
            ("2026-02-07".into(), 350.0),
        ];
        data.daily_plan_messages = vec![
            ("2026-02-01".into(), 30.0),
            ("2026-02-02".into(), 25.0),
            ("2026-02-03".into(), 40.0),
            ("2026-02-04".into(), 20.0),
            ("2026-02-05".into(), 35.0),
            ("2026-02-06".into(), 25.0),
            ("2026-02-07".into(), 25.0),
        ];
        data.heatmap_days = vec![
            ("2026-02-01".into(), 0.8),
            ("2026-02-02".into(), 0.6),
            ("2026-02-03".into(), 1.0),
            ("2026-02-04".into(), 0.5),
            ("2026-02-05".into(), 0.7),
            ("2026-02-06".into(), 0.4),
            ("2026-02-07".into(), 0.3),
        ];
        data.session_scatter = vec![
            crate::analytics::SessionScatterPoint {
                source_id: "local".into(),
                source_path: "/sessions/a.jsonl".into(),
                message_count: 12,
                api_tokens_total: 3200,
            },
            crate::analytics::SessionScatterPoint {
                source_id: "local".into(),
                source_path: "/sessions/b.jsonl".into(),
                message_count: 9,
                api_tokens_total: 1800,
            },
            crate::analytics::SessionScatterPoint {
                source_id: "remote-ci".into(),
                source_path: "/sessions/c.jsonl".into(),
                message_count: 22,
                api_tokens_total: 7100,
            },
        ];
        data.agent_plan_messages = vec![
            ("claude_code".into(), 120.0),
            ("codex".into(), 50.0),
            ("aider".into(), 30.0),
        ];
        app.analytics_cache = Some(data);
        app
    }

    #[test]
    fn analytics_render_all_subviews_no_panic_80x24() {
        for &view in AnalyticsView::all() {
            let app = analytics_app_with_data(view);
            let buf =
                render_at_degradation(&app, 80, 24, ftui::render::budget::DegradationLevel::Full);
            let text = ftui_harness::buffer_to_text(&buf);
            assert!(
                !text.trim().is_empty(),
                "{:?} view at 80x24 should render non-empty content",
                view
            );
        }
    }

    #[test]
    fn analytics_render_all_subviews_no_panic_120x40() {
        for &view in AnalyticsView::all() {
            let app = analytics_app_with_data(view);
            let buf =
                render_at_degradation(&app, 120, 40, ftui::render::budget::DegradationLevel::Full);
            let text = ftui_harness::buffer_to_text(&buf);
            assert!(
                !text.trim().is_empty(),
                "{:?} view at 120x40 should render non-empty content",
                view
            );
        }
    }

    #[test]
    fn analytics_render_empty_data_no_panic() {
        // All views should survive with empty AnalyticsChartData.
        for &view in AnalyticsView::all() {
            let mut app = CassApp::default();
            app.surface = AppSurface::Analytics;
            app.analytics_view = view;
            app.analytics_cache = Some(AnalyticsChartData::default());
            let buf =
                render_at_degradation(&app, 80, 24, ftui::render::budget::DegradationLevel::Full);
            let text = ftui_harness::buffer_to_text(&buf);
            assert!(
                !text.trim().is_empty(),
                "{:?} view with empty data should render without panic",
                view
            );
        }
    }

    #[test]
    fn analytics_render_no_cache_no_panic() {
        // All views should survive without any analytics_cache (loading state).
        for &view in AnalyticsView::all() {
            let mut app = CassApp::default();
            app.surface = AppSurface::Analytics;
            app.analytics_view = view;
            app.analytics_cache = None;
            let buf =
                render_at_degradation(&app, 80, 24, ftui::render::budget::DegradationLevel::Full);
            let text = ftui_harness::buffer_to_text(&buf);
            assert!(
                !text.trim().is_empty(),
                "{:?} view with no cache should render without panic",
                view
            );
        }
    }

    #[test]
    fn analytics_dashboard_render_shows_kpi_labels() {
        let app = analytics_app_with_data(AnalyticsView::Dashboard);
        let buf =
            render_at_degradation(&app, 120, 40, ftui::render::budget::DegradationLevel::Full);
        let text = ftui_harness::buffer_to_text(&buf);
        // Dashboard KPI tiles should include recognizable metric labels.
        assert!(
            text.contains("Messages")
                || text.contains("messages")
                || text.contains("5,000")
                || text.contains("5.0K"),
            "Dashboard should display message-related KPI, got:\n{text}"
        );
    }

    #[test]
    fn analytics_explorer_render_shows_metric_label() {
        let app = analytics_app_with_data(AnalyticsView::Explorer);
        let buf =
            render_at_degradation(&app, 120, 40, ftui::render::budget::DegradationLevel::Full);
        let text = ftui_harness::buffer_to_text(&buf);
        // Explorer header should show the current metric.
        assert!(
            text.contains("API Tokens") || text.contains("Api") || text.contains("Tokens"),
            "Explorer should show metric label, got:\n{text}"
        );
    }

    #[test]
    fn analytics_explorer_render_shows_scatter_panel_when_space_allows() {
        let app = analytics_app_with_data(AnalyticsView::Explorer);
        let buf =
            render_at_degradation(&app, 160, 40, ftui::render::budget::DegradationLevel::Full);
        let text = ftui_harness::buffer_to_text(&buf);
        assert!(
            text.contains("session tokens vs messages"),
            "Explorer should render scatter panel at wide size, got:\n{text}"
        );
    }

    #[test]
    fn analytics_explorer_render_compact_hides_scatter_panel() {
        let app = analytics_app_with_data(AnalyticsView::Explorer);
        let buf = render_at_degradation(&app, 48, 24, ftui::render::budget::DegradationLevel::Full);
        let text = ftui_harness::buffer_to_text(&buf);
        assert!(
            !text.contains("session tokens vs messages"),
            "Explorer should hide scatter panel at compact size, got:\n{text}"
        );
    }

    #[test]
    fn analytics_render_degradation_levels_no_panic() {
        use ftui::render::budget::DegradationLevel;
        // Skeleton/EssentialOnly may intentionally suppress all content — just
        // assert no panic for those. Full through NoStyling should produce
        // visible output.
        let visible_levels = [
            DegradationLevel::Full,
            DegradationLevel::SimpleBorders,
            DegradationLevel::NoStyling,
        ];
        let suppress_levels = [DegradationLevel::EssentialOnly, DegradationLevel::Skeleton];
        for &view in AnalyticsView::all() {
            for &level in &visible_levels {
                let app = analytics_app_with_data(view);
                let buf = render_at_degradation(&app, 80, 24, level);
                let text = ftui_harness::buffer_to_text(&buf);
                assert!(
                    !text.trim().is_empty(),
                    "{:?} at degradation {:?} should render visible content",
                    view,
                    level
                );
            }
            // Just ensure no panic at extreme degradation.
            for &level in &suppress_levels {
                let app = analytics_app_with_data(view);
                let _ = render_at_degradation(&app, 80, 24, level);
            }
        }
    }

    #[test]
    fn analytics_render_perf_guard() {
        // All analytics subviews rendering at 120x40 should complete within a generous budget.
        // This is a catastrophic regression detector, not a micro-benchmark.
        let start = std::time::Instant::now();
        for &view in AnalyticsView::all() {
            let app = analytics_app_with_data(view);
            let _ =
                render_at_degradation(&app, 120, 40, ftui::render::budget::DegradationLevel::Full);
        }
        let elapsed = start.elapsed();
        // All views should render within 2 seconds total (very generous).
        assert!(
            elapsed.as_millis() < 2000,
            "rendering all analytics views took {:?} — exceeds 2s budget",
            elapsed
        );
    }

    #[test]
    fn analytics_navigation_full_cycle_through_all_views() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::AnalyticsEntered);
        assert_eq!(app.surface, AppSurface::Analytics);
        assert_eq!(app.analytics_view, AnalyticsView::Dashboard);

        // Cycle forward through all visible views using CursorMoved (← → keys)
        let expected = [
            AnalyticsView::Explorer,
            AnalyticsView::Heatmap,
            AnalyticsView::Breakdowns,
            AnalyticsView::Tools,
            AnalyticsView::Plans,
            AnalyticsView::Coverage,
            AnalyticsView::Dashboard, // wraps around
        ];
        for expected_view in expected {
            let _ = app.update(CassMsg::CursorMoved { delta: 1 });
            assert_eq!(
                app.analytics_view, expected_view,
                "forward cycle should reach {:?}",
                expected_view
            );
        }
    }

    #[test]
    fn analytics_navigation_backward_cycle() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::AnalyticsEntered);

        // Go backward from Dashboard -> Coverage
        let _ = app.update(CassMsg::CursorMoved { delta: -1 });
        assert_eq!(app.analytics_view, AnalyticsView::Coverage);

        let _ = app.update(CassMsg::CursorMoved { delta: -1 });
        assert_eq!(app.analytics_view, AnalyticsView::Plans);
    }

    #[test]
    fn analytics_selection_per_view_with_data() {
        // Views with selectable data should accept selection changes.
        let selectable_views = [
            AnalyticsView::Explorer,
            AnalyticsView::Heatmap,
            AnalyticsView::Breakdowns,
            AnalyticsView::Tools,
            AnalyticsView::Plans,
            AnalyticsView::Coverage,
        ];
        for view in selectable_views {
            let mut app = analytics_app_with_data(view);
            let count = app.analytics_selectable_count();
            if count > 0 {
                let _ = app.update(CassMsg::AnalyticsSelectionMoved { delta: 1 });
                assert_eq!(
                    app.analytics_selection, 1,
                    "{:?} view should allow selection movement",
                    view
                );
            }
        }
    }

    #[test]
    fn analytics_drilldown_from_each_selectable_view() {
        let views_with_drilldown = [
            AnalyticsView::Heatmap,
            AnalyticsView::Breakdowns,
            AnalyticsView::Tools,
            AnalyticsView::Plans,
            AnalyticsView::Coverage,
        ];
        for view in views_with_drilldown {
            let app = analytics_app_with_data(view);
            if app.analytics_selectable_count() > 0 {
                let ctx = app.build_drilldown_context();
                assert!(
                    ctx.is_some(),
                    "{:?} with data should produce a drilldown context",
                    view
                );
            }
        }
    }

    #[test]
    fn analytics_filter_persistence_across_view_changes() {
        let mut app = analytics_app_with_data(AnalyticsView::Dashboard);
        // Set a filter
        app.analytics_filters.agents.insert("claude_code".into());
        let _ = app.update(CassMsg::CursorMoved { delta: 1 }); // → Explorer
        assert!(
            app.analytics_filters.agents.contains("claude_code"),
            "agent filter should persist across view changes"
        );
        let _ = app.update(CassMsg::CursorMoved { delta: 1 }); // → Heatmap
        assert!(
            app.analytics_filters.agents.contains("claude_code"),
            "agent filter should persist across multiple view changes"
        );
    }

    #[test]
    fn analytics_view_change_resets_selection_to_zero() {
        let mut app = analytics_app_with_data(AnalyticsView::Explorer);
        // Move selection forward
        let _ = app.update(CassMsg::AnalyticsSelectionMoved { delta: 3 });
        assert!(app.analytics_selection > 0);
        // Change view — selection should reset
        let _ = app.update(CassMsg::CursorMoved { delta: 1 });
        assert_eq!(
            app.analytics_selection, 0,
            "selection should reset on view change"
        );
    }

    // -- Performance guardrail tests (2noh9.5.6) -----------------------------

    /// Budget: single render of any surface must complete within this many ms.
    /// This is intentionally generous (catches catastrophic regressions, not
    /// micro-optimizations).
    const PERF_RENDER_SINGLE_BUDGET_MS: u128 = 200;
    /// Budget: rendering all key screens sequentially (search + all analytics).
    const PERF_RENDER_ALL_SCREENS_BUDGET_MS: u128 = 2000;
    /// Budget: a single ftui Buffer at 120x40 must not exceed this many cells.
    /// (120 * 40 = 4800 cells; a 2x safety margin → 9600 is extreme, real
    /// buffers should match exactly.)
    const PERF_BUFFER_CELL_BUDGET: usize = 120 * 40;

    #[test]
    fn perf_guard_search_surface_render_time() {
        let app = app_with_hits(10);
        let start = std::time::Instant::now();
        let _ = render_at_degradation(&app, 120, 40, ftui::render::budget::DegradationLevel::Full);
        let elapsed = start.elapsed();
        assert!(
            elapsed.as_millis() < PERF_RENDER_SINGLE_BUDGET_MS,
            "search surface render took {:?} — exceeds {}ms budget",
            elapsed,
            PERF_RENDER_SINGLE_BUDGET_MS
        );
    }

    #[test]
    fn perf_guard_detail_surface_render_time() {
        let mut app = app_with_hits(5);
        app.focus_manager.focus(focus_ids::DETAIL_PANE);
        let start = std::time::Instant::now();
        let _ = render_at_degradation(&app, 120, 40, ftui::render::budget::DegradationLevel::Full);
        let elapsed = start.elapsed();
        assert!(
            elapsed.as_millis() < PERF_RENDER_SINGLE_BUDGET_MS,
            "detail surface render took {:?} — exceeds {}ms budget",
            elapsed,
            PERF_RENDER_SINGLE_BUDGET_MS
        );
    }

    #[test]
    fn perf_guard_all_screens_sequential() {
        // Render: default search + detail focus + all 8 analytics views = 10 renders.
        let start = std::time::Instant::now();

        // Search surface
        let app = app_with_hits(10);
        let _ = render_at_degradation(&app, 120, 40, ftui::render::budget::DegradationLevel::Full);

        // Detail focus
        let mut detail_app = app_with_hits(5);
        detail_app.focus_manager.focus(focus_ids::DETAIL_PANE);
        let _ = render_at_degradation(
            &detail_app,
            120,
            40,
            ftui::render::budget::DegradationLevel::Full,
        );

        // All 8 analytics views with data
        for &view in AnalyticsView::all() {
            let analytics = analytics_app_with_data(view);
            let _ = render_at_degradation(
                &analytics,
                120,
                40,
                ftui::render::budget::DegradationLevel::Full,
            );
        }

        let elapsed = start.elapsed();
        assert!(
            elapsed.as_millis() < PERF_RENDER_ALL_SCREENS_BUDGET_MS,
            "rendering all 10 screens took {:?} — exceeds {}ms budget",
            elapsed,
            PERF_RENDER_ALL_SCREENS_BUDGET_MS
        );
    }

    #[test]
    fn perf_guard_buffer_text_within_bounds() {
        // Verify rendered text fits expected bounds (no runaway content).
        let app = app_with_hits(5);
        let buf =
            render_at_degradation(&app, 120, 40, ftui::render::budget::DegradationLevel::Full);
        let text = ftui_harness::buffer_to_text(&buf);
        // At 120x40 (4800 cells), text length should not wildly exceed
        // the cell count (accounting for newlines and trailing spaces).
        assert!(
            text.len() < PERF_BUFFER_CELL_BUDGET * 2,
            "rendered text {} chars exceeds 2x cell budget {}",
            text.len(),
            PERF_BUFFER_CELL_BUDGET * 2
        );
    }

    #[test]
    fn perf_guard_repeated_render_deterministic_timing() {
        // Rendering the same state 5 times should not show increasing cost
        // (would indicate a leak or accumulating state).
        let app = app_with_hits(10);
        let mut times_ms = Vec::with_capacity(5);
        for _ in 0..5 {
            let start = std::time::Instant::now();
            let _ =
                render_at_degradation(&app, 120, 40, ftui::render::budget::DegradationLevel::Full);
            times_ms.push(start.elapsed().as_millis());
        }
        // Last render should not be >3x the first (generous margin for CI variability).
        let first = times_ms[0].max(1);
        let last = times_ms[4];
        assert!(
            last <= first * 3,
            "render cost grew from {}ms to {}ms over 5 iterations — possible leak",
            first,
            last
        );
    }

    // -- Markdown theming profiling (2dccg.3.4) ------------------------------

    /// Realistic markdown content for profiling (moderate complexity).
    const MARKDOWN_PROFILE_CONTENT: &str = "\
# Authentication Module Refactor

## Summary
Refactored the auth module to use **JWT tokens** with `refresh_token` rotation.

### Changes
- Replaced session cookies with signed JWTs
- Added `HMAC-SHA256` signature verification
- Implemented sliding window rate limiting

```rust
fn verify_token(token: &str) -> Result<Claims> {
    let key = load_signing_key()?;
    decode::<Claims>(token, &key, &Validation::default())
}
```

> **Note**: Migration requires updating all API clients to send
> Bearer tokens instead of cookies.

| Endpoint | Old Auth | New Auth |
|----------|----------|----------|
| `/api/users` | Cookie | JWT |
| `/api/admin` | Cookie+CSRF | JWT+Role |
| `/webhook` | API Key | JWT+Scope |

1. Deploy auth service first
2. Run migration script: `./scripts/migrate_sessions.sh`
3. Verify with `curl -H 'Authorization: Bearer ...'`

---

See also: [RFC-2847](https://internal/rfc/2847) for the full design doc.
";

    fn make_markdown_messages(count: usize) -> Vec<crate::model::types::Message> {
        (0..count)
            .map(|i| crate::model::types::Message {
                id: Some(i as i64),
                idx: i as i64,
                role: if i % 2 == 0 {
                    MessageRole::User
                } else {
                    MessageRole::Agent
                },
                author: Some("test".into()),
                created_at: Some(1_700_000_000 + i as i64 * 60),
                content: MARKDOWN_PROFILE_CONTENT.to_string(),
                extra_json: serde_json::json!({}),
                snippets: Vec::new(),
            })
            .collect()
    }

    fn app_with_markdown_detail(msg_count: usize) -> CassApp {
        use std::path::PathBuf;

        let mut app = app_with_hits(3);
        let messages = make_markdown_messages(msg_count);
        let cv = ConversationView {
            convo: crate::model::types::Conversation {
                id: Some(1),
                agent_slug: "claude_code".to_string(),
                workspace: Some(PathBuf::from("/projects/test")),
                external_id: Some("conv-md-profile".to_string()),
                title: Some("Markdown Profiling".to_string()),
                source_path: PathBuf::from("/test/md_session.jsonl"),
                started_at: Some(1_700_000_000),
                ended_at: Some(1_700_003_600),
                approx_tokens: Some(4096),
                metadata_json: serde_json::json!({}),
                messages: Vec::new(),
                source_id: "local".to_string(),
                origin_host: None,
            },
            messages,
            workspace: None,
        };
        app.cached_detail = Some(("/test/md_session.jsonl".to_string(), cv));
        app
    }

    /// Budget: MarkdownRenderer construction must be negligible (<1ms).
    #[test]
    fn perf_profile_markdown_renderer_construction() {
        let styles = StyleContext::from_options(StyleOptions::default());
        let start = std::time::Instant::now();
        for _ in 0..100 {
            let theme = styles.markdown_theme();
            let _renderer = MarkdownRenderer::new(theme);
        }
        let elapsed = start.elapsed();
        let per_call_us = elapsed.as_micros() / 100;
        assert!(
            per_call_us < 1000,
            "MarkdownRenderer::new() averaged {per_call_us}us — should be <1000us"
        );
    }

    /// Budget: Rendering moderate markdown (<5ms per message).
    #[test]
    fn perf_profile_markdown_render_per_message() {
        let styles = StyleContext::from_options(StyleOptions::default());
        let renderer = MarkdownRenderer::new(styles.markdown_theme());
        let start = std::time::Instant::now();
        for _ in 0..50 {
            let _rendered = renderer.render(MARKDOWN_PROFILE_CONTENT);
        }
        let elapsed = start.elapsed();
        let per_render_us = elapsed.as_micros() / 50;
        assert!(
            per_render_us < 5000,
            "markdown render averaged {per_render_us}us — should be <5000us for moderate content"
        );
    }

    /// Budget: is_likely_markdown detection is cheap (<100us).
    #[test]
    fn perf_profile_markdown_detection() {
        let start = std::time::Instant::now();
        for _ in 0..1000 {
            let _det = is_likely_markdown(MARKDOWN_PROFILE_CONTENT);
        }
        let elapsed = start.elapsed();
        let per_call_us = elapsed.as_micros() / 1000;
        assert!(
            per_call_us < 100,
            "is_likely_markdown averaged {per_call_us}us — should be <100us"
        );
    }

    /// Budget: build_messages_lines with 10 markdown messages < 50ms.
    #[test]
    fn perf_profile_build_messages_lines_markdown() {
        let app = app_with_markdown_detail(10);
        let hit = make_test_hit();
        let styles = StyleContext::from_options(StyleOptions::default());

        let start = std::time::Instant::now();
        let lines = app.build_messages_lines(&hit, 120, &styles);
        let elapsed = start.elapsed();

        assert!(!lines.is_empty(), "should produce rendered markdown lines");
        assert!(
            elapsed.as_millis() < 50,
            "build_messages_lines (10 md messages) took {:?} — should be <50ms",
            elapsed
        );
    }

    /// Budget: build_messages_lines with plain text (no markdown) < 10ms.
    #[test]
    fn perf_profile_build_messages_lines_plain_text() {
        use std::path::PathBuf;

        let mut app = app_with_hits(3);
        let plain_messages: Vec<crate::model::types::Message> = (0..10)
            .map(|i| crate::model::types::Message {
                id: Some(i),
                idx: i,
                role: MessageRole::User,
                author: Some("test".into()),
                created_at: Some(1_700_000_000),
                content: "This is a plain text message without any markdown syntax.\nIt has multiple lines.\nBut no headings, code blocks, or formatting."
                    .to_string(),
                extra_json: serde_json::json!({}),
                snippets: Vec::new(),
            })
            .collect();
        let cv = ConversationView {
            convo: crate::model::types::Conversation {
                id: Some(1),
                agent_slug: "claude_code".into(),
                workspace: Some(PathBuf::from("/test")),
                external_id: None,
                title: Some("Plain Text Conv".into()),
                source_path: PathBuf::from("/test/plain.jsonl"),
                started_at: Some(1_700_000_000),
                ended_at: None,
                approx_tokens: None,
                metadata_json: serde_json::json!({}),
                messages: Vec::new(),
                source_id: "local".into(),
                origin_host: None,
            },
            messages: plain_messages,
            workspace: None,
        };
        app.cached_detail = Some(("/test/plain.jsonl".into(), cv));

        let hit = make_test_hit();
        let styles = StyleContext::from_options(StyleOptions::default());

        let start = std::time::Instant::now();
        let lines = app.build_messages_lines(&hit, 120, &styles);
        let elapsed = start.elapsed();

        assert!(!lines.is_empty());
        assert!(
            elapsed.as_millis() < 10,
            "build_messages_lines (10 plain messages) took {:?} — should be <10ms",
            elapsed
        );
    }

    /// Full detail pane render with markdown content stays within budget.
    #[test]
    fn perf_profile_detail_pane_render_with_markdown() {
        let app = app_with_markdown_detail(10);
        let start = std::time::Instant::now();
        let _ = render_at_degradation(&app, 120, 40, ftui::render::budget::DegradationLevel::Full);
        let elapsed = start.elapsed();
        assert!(
            elapsed.as_millis() < PERF_RENDER_SINGLE_BUDGET_MS,
            "detail pane with 10 md messages took {:?} — exceeds {}ms budget",
            elapsed,
            PERF_RENDER_SINGLE_BUDGET_MS
        );
    }

    /// Repeated renders of markdown detail pane don't show growing cost.
    #[test]
    fn perf_profile_markdown_no_accumulation() {
        let app = app_with_markdown_detail(10);
        let mut times = Vec::with_capacity(5);
        for _ in 0..5 {
            let start = std::time::Instant::now();
            let _ =
                render_at_degradation(&app, 120, 40, ftui::render::budget::DegradationLevel::Full);
            times.push(start.elapsed().as_millis());
        }
        let first = times[0].max(1);
        let last = times[4];
        assert!(
            last <= first * 3,
            "markdown render cost grew from {}ms to {}ms — possible leak",
            first,
            last
        );
    }

    /// Theme toggle correctly invalidates markdown rendering (new colors).
    #[test]
    fn perf_profile_theme_switch_invalidates_markdown() {
        use ftui::Model;

        let mut app = app_with_markdown_detail(3);
        let hit = make_test_hit();

        // Render with dark theme
        let dark_styles = StyleContext::from_options(StyleOptions::default());
        let dark_lines = app.build_messages_lines(&hit, 120, &dark_styles);

        // Switch to light
        let _ = app.update(CassMsg::ThemeToggled);
        let mut light_options = StyleOptions::default();
        light_options.preset = UiThemePreset::Light;
        let light_styles = StyleContext::from_options(light_options);
        let light_lines = app.build_messages_lines(&hit, 120, &light_styles);

        // Lines should have different styles (different theme colors)
        let dark_h1_fg = markdown_span_fg_for_text(&dark_lines, "Authentication");
        let light_h1_fg = markdown_span_fg_for_text(&light_lines, "Authentication");

        assert!(
            dark_h1_fg.is_some(),
            "dark theme heading should have fg color"
        );
        assert!(
            light_h1_fg.is_some(),
            "light theme heading should have fg color"
        );
        assert_ne!(
            dark_h1_fg, light_h1_fg,
            "theme switch should produce different heading colors: dark={dark_h1_fg:?} light={light_h1_fg:?}"
        );
    }

    /// Markdown theming overhead relative to plain text rendering is acceptable.
    #[test]
    fn perf_profile_markdown_vs_plain_overhead_ratio() {
        let styles = StyleContext::from_options(StyleOptions::default());
        let renderer = MarkdownRenderer::new(styles.markdown_theme());

        // Benchmark markdown
        let md_start = std::time::Instant::now();
        for _ in 0..20 {
            let _r = renderer.render(MARKDOWN_PROFILE_CONTENT);
        }
        let md_us = md_start.elapsed().as_micros();

        // Benchmark plain text equivalent (same length, split to lines)
        let plain_content = "x".repeat(MARKDOWN_PROFILE_CONTENT.len());
        let plain_start = std::time::Instant::now();
        for _ in 0..20 {
            let _lines: Vec<&str> = plain_content.lines().collect();
        }
        let plain_us = plain_start.elapsed().as_micros().max(1);

        // Markdown rendering should not be more than 1000x slower than
        // a simple line split — generous bound for parser overhead.
        let ratio = md_us / plain_us;
        assert!(
            ratio < 1000,
            "markdown/plain ratio = {}x — overhead is excessive (md={}us plain={}us)",
            ratio,
            md_us,
            plain_us
        );
    }

    // -- Animation state tests (2noh9.4.14) ---------------------------------

    #[test]
    fn animation_state_default_enabled() {
        let anim = AnimationState::default();
        assert!(anim.enabled);
        assert!((anim.focus_flash_progress() - 1.0).abs() < 0.01);
    }

    #[test]
    fn animation_state_disabled_snaps() {
        let mut anim = AnimationState::new(false);
        anim.trigger_focus_flash();
        anim.tick(std::time::Duration::from_millis(1));
        assert!((anim.focus_flash_progress() - 1.0).abs() < 0.01);
    }

    #[test]
    fn animation_focus_flash_converges() {
        let mut anim = AnimationState::new(true);
        anim.trigger_focus_flash();
        assert!(anim.focus_flash_progress() < 0.1);
        for _ in 0..60 {
            anim.tick(std::time::Duration::from_millis(16));
        }
        assert!(anim.focus_flash_progress() > 0.9);
    }

    #[test]
    fn animation_reveal_stagger() {
        let mut anim = AnimationState::new(true);
        anim.start_reveal(5);
        assert!(anim.reveal_active);
        assert_eq!(anim.reveal_springs.len(), 5);
        assert!(anim.reveal_progress(0) < 0.1);
        for _ in 0..60 {
            anim.tick(std::time::Duration::from_millis(16));
        }
        for i in 0..5 {
            assert!(anim.reveal_progress(i) > 0.9, "item {i} should be revealed");
        }
    }

    #[test]
    fn animation_modal_open_close() {
        let mut anim = AnimationState::new(true);
        assert!(anim.modal_progress() < 0.1);
        anim.open_modal();
        for _ in 0..60 {
            anim.tick(std::time::Duration::from_millis(16));
        }
        assert!(anim.modal_progress() > 0.9);
        anim.close_modal();
        for _ in 0..60 {
            anim.tick(std::time::Duration::from_millis(16));
        }
        assert!(anim.modal_progress() < 0.1);
    }

    #[test]
    fn animation_panel_ratio() {
        let mut anim = AnimationState::new(true);
        assert!((anim.panel_ratio_value() - 0.7).abs() < 0.01);
        anim.set_panel_ratio(0.5);
        for _ in 0..60 {
            anim.tick(std::time::Duration::from_millis(16));
        }
        assert!(
            (anim.panel_ratio_value() - 0.5).abs() < 0.05,
            "panel ratio should converge to 0.5, got {}",
            anim.panel_ratio_value()
        );
    }

    #[test]
    fn animation_peek_badge() {
        let mut anim = AnimationState::new(true);
        assert!(anim.peek_badge_progress() < 0.1);
        anim.show_peek_badge();
        for _ in 0..60 {
            anim.tick(std::time::Duration::from_millis(16));
        }
        assert!(anim.peek_badge_progress() > 0.9);
        anim.hide_peek_badge();
        for _ in 0..60 {
            anim.tick(std::time::Duration::from_millis(16));
        }
        assert!(anim.peek_badge_progress() < 0.1);
    }

    #[test]
    fn animation_disabled_reveal_returns_1() {
        let anim = AnimationState::new(false);
        assert!((anim.reveal_progress(0) - 1.0).abs() < 0.01);
        assert!((anim.reveal_progress(99) - 1.0).abs() < 0.01);
    }

    #[test]
    fn animation_clear_reveal_resets_state() {
        let mut anim = AnimationState::new(true);
        anim.start_reveal(8);
        assert!(anim.reveal_active);
        assert!(!anim.reveal_springs.is_empty());
        anim.clear_reveal();
        assert!(!anim.reveal_active);
        assert!(anim.reveal_springs.is_empty());
    }

    #[test]
    fn search_completed_large_result_set_starts_reveal_sequence() {
        let mut app = CassApp::default();
        let hits: Vec<SearchHit> = (0..RESULTS_REVEAL_MIN_HITS)
            .map(|i| make_hit(i as u64, &format!("/reveal/{i}")))
            .collect();
        let _ = app.update(CassMsg::SearchCompleted {
            generation: app.search_generation,
            hits,
            elapsed_ms: 7,
            suggestions: Vec::new(),
            wildcard_fallback: false,
            append: false,
        });
        assert!(
            app.anim.reveal_active,
            "large result sets should trigger reveal"
        );
        assert_eq!(
            app.anim.reveal_springs.len(),
            RESULTS_REVEAL_MIN_HITS.min(anim_config::MAX_ANIMATED_ITEMS)
        );
        assert!(
            app.reveal_anim_start.is_some(),
            "reveal start timestamp should be recorded"
        );
    }

    #[test]
    fn search_completed_small_result_set_clears_reveal_sequence() {
        let mut app = CassApp::default();
        app.anim.start_reveal(10);
        app.reveal_anim_start = Some(Instant::now());

        let hits: Vec<SearchHit> = (0..RESULTS_REVEAL_MIN_HITS.saturating_sub(1))
            .map(|i| make_hit(i as u64, &format!("/small/{i}")))
            .collect();
        let _ = app.update(CassMsg::SearchCompleted {
            generation: app.search_generation,
            hits,
            elapsed_ms: 6,
            suggestions: Vec::new(),
            wildcard_fallback: false,
            append: false,
        });
        assert!(
            !app.anim.reveal_active,
            "small result sets should not keep reveal animation active"
        );
        assert!(
            app.anim.reveal_springs.is_empty(),
            "small result sets should clear reveal springs"
        );
        assert!(
            app.reveal_anim_start.is_none(),
            "small result sets should clear reveal start timestamp"
        );
    }

    #[test]
    fn results_reveal_affects_full_mode_but_is_suppressed_when_degraded() {
        use ftui::render::budget::DegradationLevel;

        let mut full_app = app_with_hits(8);
        // Keep this test deterministic even when CASS_DISABLE_ANIMATIONS=1 leaks into env.
        full_app.anim.enabled = true;
        // results_reveal_motion_enabled checks self.results.len(), so populate it
        full_app.results = full_app.panes[0].hits.clone();
        full_app.anim.start_reveal(8);
        let full_early = ftui_harness::buffer_to_text(&render_at_degradation(
            &full_app,
            120,
            24,
            DegradationLevel::Full,
        ));
        for _ in 0..60 {
            full_app.anim.tick(std::time::Duration::from_millis(16));
        }
        let full_late = ftui_harness::buffer_to_text(&render_at_degradation(
            &full_app,
            120,
            24,
            DegradationLevel::Full,
        ));
        assert_ne!(
            full_early, full_late,
            "full mode should reflect reveal progress over time"
        );

        let mut degraded_app = app_with_hits(8);
        // Keep this test deterministic even when CASS_DISABLE_ANIMATIONS=1 leaks into env.
        degraded_app.anim.enabled = true;
        degraded_app.results = degraded_app.panes[0].hits.clone();
        degraded_app.anim.start_reveal(8);
        let degraded_early = ftui_harness::buffer_to_text(&render_at_degradation(
            &degraded_app,
            120,
            24,
            DegradationLevel::SimpleBorders,
        ));
        for _ in 0..60 {
            degraded_app.anim.tick(std::time::Duration::from_millis(16));
        }
        let degraded_late = ftui_harness::buffer_to_text(&render_at_degradation(
            &degraded_app,
            120,
            24,
            DegradationLevel::SimpleBorders,
        ));
        assert_eq!(
            degraded_early, degraded_late,
            "degraded mode should suppress reveal animation for deterministic output"
        );
    }

    #[test]
    fn focus_flash_glyph_only_renders_when_motion_policy_allows() {
        use ftui::render::budget::DegradationLevel;

        let mut app = app_with_hits(8);
        app.anim.trigger_focus_flash();

        let full = ftui_harness::buffer_to_text(&render_at_degradation(
            &app,
            120,
            24,
            DegradationLevel::Full,
        ));
        assert!(
            full.contains('\u{2726}'),
            "full mode should render focus-flash cue in selected row"
        );

        let degraded = ftui_harness::buffer_to_text(&render_at_degradation(
            &app,
            120,
            24,
            DegradationLevel::SimpleBorders,
        ));
        assert!(
            !degraded.contains('\u{2726}'),
            "degraded mode should suppress focus-flash cue"
        );
    }

    // =========================================================================
    // 2dccg.9.4 — Animation stress + performance guardrail tests
    // =========================================================================

    #[test]
    fn reveal_springs_capped_at_max_animated_items() {
        let mut anim = AnimationState::new(true);
        anim.start_reveal(500);
        assert_eq!(
            anim.reveal_springs.len(),
            anim_config::MAX_ANIMATED_ITEMS,
            "reveal springs should be capped at MAX_ANIMATED_ITEMS={} even for 500 hits",
            anim_config::MAX_ANIMATED_ITEMS
        );
    }

    #[test]
    fn reveal_not_triggered_below_min_hits() {
        let app = app_with_hits(RESULTS_REVEAL_MIN_HITS - 1);
        let enabled = app.results_reveal_motion_enabled(
            ftui::render::budget::DegradationLevel::Full,
            RESULTS_REVEAL_MIN_HITS - 1,
        );
        assert!(
            !enabled,
            "reveal should not trigger below {RESULTS_REVEAL_MIN_HITS} hits"
        );
    }

    #[test]
    fn reveal_not_triggered_above_max_hits() {
        let app = app_with_hits(10);
        let enabled = app.results_reveal_motion_enabled(
            ftui::render::budget::DegradationLevel::Full,
            RESULTS_REVEAL_MAX_HITS + 1,
        );
        assert!(
            !enabled,
            "reveal should not trigger above {RESULTS_REVEAL_MAX_HITS} hits"
        );
    }

    #[test]
    fn reveal_enabled_within_hit_range() {
        let app = app_with_hits(10);
        assert!(
            app.results_reveal_motion_enabled(
                ftui::render::budget::DegradationLevel::Full,
                RESULTS_REVEAL_MIN_HITS,
            ),
            "reveal should trigger at exactly MIN_HITS"
        );
        assert!(
            app.results_reveal_motion_enabled(
                ftui::render::budget::DegradationLevel::Full,
                RESULTS_REVEAL_MAX_HITS,
            ),
            "reveal should trigger at exactly MAX_HITS"
        );
    }

    #[test]
    fn heavy_result_render_no_panic_with_animation() {
        use ftui::render::budget::DegradationLevel;

        let mut app = app_with_hits(200);
        app.anim.start_reveal(200);
        // Render at full degradation — animation active
        let _buf = render_at_degradation(&app, 120, 24, DegradationLevel::Full);
        // Tick forward and render again
        app.anim.tick(std::time::Duration::from_millis(50));
        let _buf = render_at_degradation(&app, 120, 24, DegradationLevel::Full);
        // Should not panic even with 200 hits + reveal animation
    }

    #[test]
    fn animation_disabled_env_snaps_springs() {
        let mut anim = AnimationState::new(false);
        anim.start_reveal(10);
        // Disabled animations should still allow start_reveal
        // but tick should snap everything instantly
        anim.tick(std::time::Duration::from_millis(16));
        assert!(
            !anim.reveal_active,
            "disabled animations should snap reveal to complete"
        );
        // Focus flash should also snap
        anim.trigger_focus_flash();
        anim.tick(std::time::Duration::from_millis(16));
        assert!(
            (anim.focus_flash_progress() - 1.0).abs() < 0.01,
            "disabled animations should snap focus flash to settled"
        );
    }

    #[test]
    fn focus_flash_disabled_returns_zero_intensity() {
        let mut app = app_with_hits(8);
        // Trigger flash then check intensity with disabled animation
        app.anim.trigger_focus_flash();
        // Even with flash triggered, disabled anim should return 0
        app.anim.enabled = false;
        let intensity =
            app.results_focus_flash_intensity(ftui::render::budget::DegradationLevel::Full, true);
        assert!(
            intensity < 0.01,
            "disabled animation should return zero flash intensity"
        );
    }

    #[test]
    fn focus_flash_zero_when_not_focused() {
        let app = app_with_hits(8);
        let intensity = app.results_focus_flash_intensity(
            ftui::render::budget::DegradationLevel::Full,
            false, // not focused
        );
        assert!(
            intensity < 0.01,
            "unfocused results should return zero flash intensity"
        );
    }

    // =========================================================================
    // Help Overlay Tests (bead 2noh9.3.7)
    // =========================================================================

    fn test_app() -> CassApp {
        CassApp::default()
    }

    #[test]
    fn help_toggle_opens_and_closes() {
        let mut app = test_app();
        assert!(!app.show_help);
        assert!(!app.has_seen_help);
        let _ = app.update(CassMsg::HelpToggled);
        assert!(app.show_help);
        assert!(app.has_seen_help);
        assert_eq!(app.help_scroll, 0);
        let _ = app.update(CassMsg::HelpToggled);
        assert!(!app.show_help);
        assert!(
            app.has_seen_help,
            "closing help should not forget seen state"
        );
    }

    #[test]
    fn help_seen_state_persists_after_help_closed() {
        let mut app = test_app();
        let _ = app.update(CassMsg::HelpToggled); // open
        let _ = app.update(CassMsg::HelpToggled); // close

        let state = app.capture_persisted_state();
        assert!(state.has_seen_help);
    }

    #[test]
    fn help_scroll_increments_and_clamps() {
        let mut app = test_app();
        let _ = app.update(CassMsg::HelpToggled);
        assert_eq!(app.help_scroll, 0);
        let _ = app.update(CassMsg::HelpScrolled { delta: 5 });
        assert_eq!(app.help_scroll, 5);
        let _ = app.update(CassMsg::HelpScrolled { delta: -10 });
        // Should clamp to 0 not go negative
        assert_eq!(app.help_scroll, 0);
    }

    #[test]
    fn help_pin_toggle() {
        let mut app = test_app();
        assert!(!app.help_pinned);
        let _ = app.update(CassMsg::HelpPinToggled);
        assert!(app.help_pinned);
        let _ = app.update(CassMsg::HelpPinToggled);
        assert!(!app.help_pinned);
    }

    #[test]
    fn help_toggle_resets_scroll() {
        let mut app = test_app();
        let _ = app.update(CassMsg::HelpToggled);
        let _ = app.update(CassMsg::HelpScrolled { delta: 20 });
        assert_eq!(app.help_scroll, 20);
        // Close and reopen — scroll should reset to 0
        let _ = app.update(CassMsg::HelpToggled);
        let _ = app.update(CassMsg::HelpToggled);
        assert_eq!(app.help_scroll, 0);
    }

    #[test]
    fn help_esc_closes_overlay() {
        let mut app = test_app();
        let _ = app.update(CassMsg::HelpToggled);
        assert!(app.show_help);
        let _ = app.update(CassMsg::QuitRequested);
        assert!(!app.show_help);
    }

    #[test]
    fn help_overlay_render_no_panic_80x24() {
        let mut app = test_app();
        let _ = app.update(CassMsg::HelpToggled);
        render_at_degradation(&app, 80, 24, ftui::render::budget::DegradationLevel::Full);
    }

    #[test]
    fn help_overlay_render_no_panic_120x40() {
        let mut app = test_app();
        let _ = app.update(CassMsg::HelpToggled);
        render_at_degradation(&app, 120, 40, ftui::render::budget::DegradationLevel::Full);
    }

    #[test]
    fn help_overlay_render_narrow_no_panic() {
        let mut app = test_app();
        let _ = app.update(CassMsg::HelpToggled);
        // Very narrow — should not panic, just potentially skip rendering
        render_at_degradation(&app, 30, 10, ftui::render::budget::DegradationLevel::Full);
    }

    #[test]
    fn help_overlay_contains_shortcut_keys() {
        let mut app = test_app();
        let _ = app.update(CassMsg::HelpToggled);
        // Use a tall viewport (200 rows) so all help sections are visible
        let buf =
            render_at_degradation(&app, 120, 200, ftui::render::budget::DegradationLevel::Full);
        let text = ftui_harness::buffer_to_text(&buf);
        // Help content should include key shortcuts from shortcuts.rs
        assert!(
            text.contains(shortcuts::HELP),
            "Help text should contain F1 shortcut"
        );
        assert!(
            text.contains("Search"),
            "Help text should contain 'Search' section"
        );
        assert!(
            text.contains("Navigation"),
            "Help text should contain 'Navigation' section"
        );
        assert!(
            text.contains("Filters"),
            "Help text should contain 'Filters' section"
        );
    }

    #[test]
    fn help_overlay_shows_pinned_indicator() {
        let mut app = test_app();
        let _ = app.update(CassMsg::HelpToggled);
        let _ = app.update(CassMsg::HelpPinToggled);
        let buf =
            render_at_degradation(&app, 120, 60, ftui::render::budget::DegradationLevel::Full);
        let text = ftui_harness::buffer_to_text(&buf);
        assert!(
            text.contains("pinned"),
            "Pinned help should show 'pinned' in title or body"
        );
    }

    #[test]
    fn help_overlay_scroll_changes_visible_content() {
        let mut app = test_app();
        let _ = app.update(CassMsg::HelpToggled);
        let buf_top =
            render_at_degradation(&app, 120, 30, ftui::render::budget::DegradationLevel::Full);
        let text_top = ftui_harness::buffer_to_text(&buf_top);

        let _ = app.update(CassMsg::HelpScrolled { delta: 30 });
        let buf_scrolled =
            render_at_degradation(&app, 120, 30, ftui::render::budget::DegradationLevel::Full);
        let text_scrolled = ftui_harness::buffer_to_text(&buf_scrolled);

        // After scrolling, content should be different
        assert_ne!(
            text_top, text_scrolled,
            "Scrolled help content should differ from top"
        );
    }

    #[test]
    fn help_build_lines_contains_all_sections() {
        let app = test_app();
        let styles = StyleContext::from_options(StyleOptions {
            preset: UiThemePreset::Dark,
            ..StyleOptions::default()
        });
        let lines = app.build_help_lines(&styles);
        let text: String = lines
            .iter()
            .map(|l: &ftui::text::Line| l.to_plain_text())
            .collect::<Vec<_>>()
            .join("\n");

        for section in [
            "Data Locations",
            "Updates",
            "Search",
            "Surfaces",
            "Filters",
            "Sources",
            "Modes",
            "Context",
            "Navigation",
            "Actions",
            "States",
        ] {
            assert!(
                text.contains(section),
                "Help lines should contain section: {section}"
            );
        }
    }

    #[test]
    fn help_build_lines_references_shortcuts() {
        let app = test_app();
        let styles = StyleContext::from_options(StyleOptions {
            preset: UiThemePreset::Dark,
            ..StyleOptions::default()
        });
        let lines = app.build_help_lines(&styles);
        let text: String = lines
            .iter()
            .map(|l: &ftui::text::Line| l.to_plain_text())
            .collect::<Vec<_>>()
            .join("\n");

        // Must reference actual shortcut constants
        assert!(text.contains(shortcuts::HELP), "Should reference F1");
        assert!(
            text.contains(shortcuts::FILTER_AGENT),
            "Should reference F3"
        );
        assert!(
            text.contains(shortcuts::CONTEXT_WINDOW),
            "Should reference F7"
        );
        assert!(text.contains(shortcuts::EDITOR), "Should reference F8");
        assert!(text.contains(shortcuts::RANKING), "Should reference F12");
        assert!(text.contains(shortcuts::TAB_FOCUS), "Should reference Tab");
        assert!(
            text.contains(shortcuts::VIM_NAV),
            "Should reference vim nav"
        );
        assert!(
            text.contains(shortcuts::STATS_BAR),
            "Should reference stats bar shortcut"
        );
        assert!(
            text.contains(shortcuts::SURFACE_ANALYTICS),
            "Should reference analytics surface shortcut"
        );
        assert!(
            text.contains(shortcuts::COPY),
            "Should reference copy snippet"
        );
        assert!(
            text.contains(shortcuts::COPY_PATH),
            "Should reference copy path"
        );
        assert!(
            text.contains(shortcuts::COPY_CONTENT),
            "Should reference copy content"
        );
        assert!(
            text.contains("clear agent filter"),
            "Filters section should describe Shift+F3 behavior accurately"
        );
    }

    // =========================================================================
    // Macro recording/playback tests
    // =========================================================================

    #[test]
    fn macro_recording_toggle_starts_recording() {
        let mut app = CassApp::default();
        assert!(app.macro_recorder.is_none());

        let _ = app.update(CassMsg::MacroRecordingToggled);
        assert!(app.macro_recorder.is_some());
        assert!(app.status.contains("Recording"));
    }

    #[test]
    fn macro_recording_toggle_stops_and_saves() {
        let mut app = CassApp::default();

        // Start recording.
        let _ = app.update(CassMsg::MacroRecordingToggled);
        assert!(app.macro_recorder.is_some());

        // Simulate some key events by recording directly.
        if let Some(ref mut rec) = app.macro_recorder {
            rec.record_event(ftui::Event::Key(ftui::KeyEvent {
                code: ftui::KeyCode::Char('h'),
                modifiers: ftui::Modifiers::empty(),
                kind: ftui::KeyEventKind::Press,
            }));
            rec.record_event(ftui::Event::Key(ftui::KeyEvent {
                code: ftui::KeyCode::Char('i'),
                modifiers: ftui::Modifiers::empty(),
                kind: ftui::KeyEventKind::Press,
            }));
        }

        // Stop recording.
        let _ = app.update(CassMsg::MacroRecordingToggled);
        assert!(app.macro_recorder.is_none());
        // Status should indicate save (or failure if dir doesn't exist in test env).
        assert!(
            app.status.contains("Macro saved") || app.status.contains("Recording"),
            "status: {}",
            app.status
        );
    }

    #[test]
    fn macro_default_state_is_none() {
        let app = CassApp::default();
        assert!(app.macro_recorder.is_none());
        assert!(app.macro_playback.is_none());
        assert!(!app.macro_redact_paths);
    }

    #[test]
    fn alt_m_maps_to_macro_recording_toggled() {
        use crate::ui::ftui_adapter::{Event, KeyCode, KeyEvent, Modifiers};
        let event = Event::Key(KeyEvent {
            code: KeyCode::Char('m'),
            modifiers: Modifiers::ALT,
            kind: ftui::KeyEventKind::Press,
        });
        let msg = CassMsg::from(event);
        assert!(matches!(msg, CassMsg::MacroRecordingToggled));
    }

    #[test]
    fn macro_playback_processes_events_on_tick() {
        use ftui::runtime::input_macro::{MacroMetadata, MacroPlayback};
        use ftui::runtime::{InputMacro, TimedEvent};
        use std::time::Duration;

        let mut app = CassApp::default();

        // Create a simple macro with one key event at 0ms delay.
        let events = vec![TimedEvent::new(
            ftui::Event::Key(ftui::KeyEvent {
                code: ftui::KeyCode::Char('x'),
                modifiers: ftui::Modifiers::CTRL,
                kind: ftui::KeyEventKind::Press,
            }),
            Duration::from_millis(0),
        )];
        let metadata = MacroMetadata {
            name: "test".to_string(),
            terminal_size: (80, 24),
            total_duration: Duration::from_millis(0),
        };
        let input_macro = InputMacro::new(events, metadata);
        app.macro_playback = Some(MacroPlayback::new(input_macro));

        // One tick should advance playback and emit the event as a message.
        let cmd = app.update(CassMsg::Tick);
        // After tick, playback should be done (0ms macro completes immediately).
        assert!(app.macro_playback.is_none());
        // The cmd should contain batch with messages.
        assert!(!matches!(cmd, ftui::Cmd::None));
    }

    #[test]
    fn macro_recording_indicator_in_status_line() {
        let mut app = CassApp::default();

        // Start recording.
        let _ = app.update(CassMsg::MacroRecordingToggled);

        // The rec_tag logic in view uses macro_recorder.is_some().
        assert!(app.macro_recorder.is_some());
    }

    // =========================================================================
    // FocusGraph navigation tests (bead 2noh9.3.16)
    // =========================================================================

    #[test]
    fn focus_graph_initialized_with_nodes() {
        let app = CassApp::default();
        let g = app.focus_manager.graph();
        // 3 primary + 8 modal nodes = 11
        assert!(g.node_count() >= 11, "got {}", g.node_count());
        assert!(g.get(focus_ids::SEARCH_BAR).is_some());
        assert!(g.get(focus_ids::RESULTS_LIST).is_some());
        assert!(g.get(focus_ids::DETAIL_PANE).is_some());
        assert!(g.get(focus_ids::COMMAND_PALETTE).is_some());
    }

    #[test]
    fn focus_graph_default_focuses_results() {
        let app = CassApp::default();
        assert_eq!(app.focus_manager.current(), Some(focus_ids::RESULTS_LIST));
        assert_eq!(app.focused_region(), FocusRegion::Results);
    }

    #[test]
    fn focus_toggle_cycles_through_nodes() {
        let mut app = CassApp::default();
        // Default: RESULTS_LIST
        assert_eq!(app.focus_manager.current(), Some(focus_ids::RESULTS_LIST));

        // Tab (focus_next) → DETAIL_PANE
        let _ = app.update(CassMsg::FocusToggled);
        assert_eq!(app.focus_manager.current(), Some(focus_ids::DETAIL_PANE));
        assert_eq!(app.focused_region(), FocusRegion::Detail);

        // Tab again → SEARCH_BAR (wraps)
        let _ = app.update(CassMsg::FocusToggled);
        assert_eq!(app.focus_manager.current(), Some(focus_ids::SEARCH_BAR));

        // Tab again → RESULTS_LIST
        let _ = app.update(CassMsg::FocusToggled);
        assert_eq!(app.focus_manager.current(), Some(focus_ids::RESULTS_LIST));
    }

    #[test]
    fn focus_directional_navigates_graph() {
        let mut app = CassApp::default();
        // Start at RESULTS_LIST, go right → DETAIL_PANE
        let _ = app.update(CassMsg::FocusDirectional {
            direction: FocusDirection::Right,
        });
        assert_eq!(app.focus_manager.current(), Some(focus_ids::DETAIL_PANE));

        // Go left → RESULTS_LIST
        let _ = app.update(CassMsg::FocusDirectional {
            direction: FocusDirection::Left,
        });
        assert_eq!(app.focus_manager.current(), Some(focus_ids::RESULTS_LIST));

        // Go up → SEARCH_BAR
        let _ = app.update(CassMsg::FocusDirectional {
            direction: FocusDirection::Up,
        });
        assert_eq!(app.focus_manager.current(), Some(focus_ids::SEARCH_BAR));
    }

    #[test]
    fn modal_push_trap_confines_focus() {
        let mut app = CassApp::default();
        assert!(!app.focus_manager.is_trapped());

        // Open palette → should trap focus
        let _ = app.update(CassMsg::PaletteOpened);
        assert!(app.focus_manager.is_trapped());
        assert_eq!(
            app.focus_manager.current(),
            Some(focus_ids::COMMAND_PALETTE)
        );

        // Tab should NOT escape the trap (only palette node in group)
        let _ = app.update(CassMsg::FocusToggled);
        assert_eq!(
            app.focus_manager.current(),
            Some(focus_ids::COMMAND_PALETTE)
        );
    }

    #[test]
    fn modal_pop_trap_restores_focus() {
        let mut app = CassApp::default();
        // Start focused on RESULTS_LIST
        assert_eq!(app.focus_manager.current(), Some(focus_ids::RESULTS_LIST));

        // Open palette
        let _ = app.update(CassMsg::PaletteOpened);
        assert!(app.focus_manager.is_trapped());

        // Close palette via Esc (QuitRequested)
        let _ = app.update(CassMsg::QuitRequested);
        assert!(!app.focus_manager.is_trapped());
        // Focus restored to RESULTS_LIST
        assert_eq!(app.focus_manager.current(), Some(focus_ids::RESULTS_LIST));
    }

    #[test]
    fn nested_modals_stack_traps() {
        let mut app = CassApp::default();

        // Open help
        let _ = app.update(CassMsg::HelpToggled);
        assert!(app.focus_manager.is_trapped());

        // Close help
        let _ = app.update(CassMsg::HelpToggled);
        assert!(!app.focus_manager.is_trapped());
    }

    #[test]
    fn detail_closed_pops_trap_and_restores() {
        let mut app = CassApp::default();
        app.results = vec![SearchHit {
            title: String::new(),
            snippet: "test".into(),
            content: "test".into(),
            content_hash: 0,
            score: 1.0,
            source_path: "/tmp/test".into(),
            agent: "test".into(),
            workspace: "/tmp".into(),
            workspace_original: None,
            created_at: None,
            line_number: Some(0),
            match_type: Default::default(),
            source_id: "local".into(),
            origin_kind: "local".into(),
            origin_host: None,
        }];
        app.panes = vec![AgentPane {
            agent: "test".into(),
            hits: app.results.clone(),
            selected: 0,
            total_count: 1,
        }];

        // Directly open the detail modal (DetailOpened in non-Query modes
        // applies the input filter, so we set modal state directly).
        app.show_detail_modal = true;
        app.focus_manager.push_trap(focus_ids::GROUP_DETAIL_MODAL);
        app.focus_manager.focus(focus_ids::DETAIL_MODAL);
        assert!(app.show_detail_modal);

        // Close detail
        let _ = app.update(CassMsg::DetailClosed);
        assert!(!app.show_detail_modal);
        assert_eq!(app.focused_region(), FocusRegion::Results);
    }

    #[test]
    fn focus_graph_has_directional_edges() {
        let app = CassApp::default();
        let g = app.focus_manager.graph();
        // SearchBar Down → ResultsList
        assert_eq!(
            g.navigate(focus_ids::SEARCH_BAR, NavDirection::Down),
            Some(focus_ids::RESULTS_LIST)
        );
        // ResultsList Right → DetailPane
        assert_eq!(
            g.navigate(focus_ids::RESULTS_LIST, NavDirection::Right),
            Some(focus_ids::DETAIL_PANE)
        );
        // DetailPane Left → ResultsList
        assert_eq!(
            g.navigate(focus_ids::DETAIL_PANE, NavDirection::Left),
            Some(focus_ids::RESULTS_LIST)
        );
    }

    // =========================================================================
    // 2dccg.11.2 — Interaction state machine and event routing tests
    // =========================================================================

    #[test]
    fn palette_visible_survives_selection_moved() {
        use super::super::test_log::{Category, TestLogger};

        let log = TestLogger::new("11.2.palette_state_resilience");
        let mut app = app_with_hits(5);

        let _ = app.update(CassMsg::PaletteOpened);
        log.step_start(Category::Interaction, r#""palette opened""#.to_string());
        assert!(app.command_palette.is_visible());

        // SelectionMoved dispatched while palette is open should not crash or close palette
        let _ = app.update(CassMsg::SelectionMoved { delta: 1 });

        if app.command_palette.is_visible() {
            log.pass(
                Category::Interaction,
                r#""palette remains visible after selection move""#.to_string(),
            );
        } else {
            log.fail(
                Category::Interaction,
                r#""palette closed unexpectedly after selection move""#.to_string(),
            );
        }
        assert!(
            app.command_palette.is_visible(),
            "palette should remain visible during selection events"
        );
    }

    #[test]
    fn modal_dismiss_order_help_then_palette() {
        let mut app = CassApp::default();

        // Open help, then palette
        let _ = app.update(CassMsg::HelpToggled);
        assert!(app.show_help);

        let _ = app.update(CassMsg::PaletteOpened);
        assert!(app.command_palette.is_visible());

        // Close palette first (top of stack)
        let _ = app.update(CassMsg::PaletteClosed);
        assert!(
            !app.command_palette.is_visible(),
            "palette should close first"
        );
        assert!(app.show_help, "help should remain open");

        // Next toggle closes help
        let _ = app.update(CassMsg::HelpToggled);
        assert!(!app.show_help, "help should close second");
    }

    #[test]
    fn theme_change_during_palette_preserves_palette_state() {
        let mut app = app_with_hits(5);
        let _ = app.update(CassMsg::PaletteOpened);
        app.palette_state.selected = 2;

        let _ = app.update(CassMsg::ThemeToggled);

        assert!(
            app.command_palette.is_visible(),
            "palette should remain visible after theme toggle"
        );
        assert_eq!(
            app.palette_state.selected, 2,
            "palette selection should be preserved after theme toggle"
        );
    }

    #[test]
    fn focus_region_transitions_are_deterministic() {
        use super::super::test_log::{Category, TestLogger};

        let log = TestLogger::new("11.2.focus_determinism");
        let mut app = app_with_hits(5);

        // Verify deterministic focus transitions
        let sequence = [
            (
                CassMsg::FocusToggled,
                FocusRegion::Detail,
                "toggle to detail",
            ),
            (
                CassMsg::FocusToggled,
                FocusRegion::Results,
                "toggle back to results",
            ),
        ];

        for (msg, expected, label) in sequence {
            let _ = app.update(msg);
            let actual = app.focused_region();
            if actual == expected {
                log.pass(
                    Category::Interaction,
                    format!(r#""{label}: got {actual:?}""#),
                );
            } else {
                log.fail(
                    Category::Interaction,
                    format!(
                        r#"{{"msg":"{label}","expected":"{expected:?}","actual":"{actual:?}"}}"#
                    ),
                );
            }
            assert_eq!(actual, expected, "focus transition: {label}");
        }
    }

    #[test]
    fn rapid_density_cycling_is_idempotent_after_full_cycle() {
        let mut app = CassApp::default();
        let initial = app.density_mode;

        // Full cycle: Cozy → Spacious → Compact → Cozy
        for _ in 0..3 {
            let _ = app.update(CassMsg::DensityModeCycled);
        }
        assert_eq!(
            app.density_mode, initial,
            "3 density cycles should return to initial state"
        );

        // Double full cycle
        for _ in 0..6 {
            let _ = app.update(CassMsg::DensityModeCycled);
        }
        assert_eq!(
            app.density_mode, initial,
            "6 density cycles should return to initial state"
        );
    }

    #[test]
    fn search_mode_cycling_returns_to_initial() {
        let mut app = CassApp::default();
        let initial_mode = app.search_mode;

        // SearchModeCycled should cycle through all modes and return
        // Count how many variants exist by cycling until we return
        let mut count = 0;
        loop {
            let _ = app.update(CassMsg::SearchModeCycled);
            count += 1;
            if app.search_mode == initial_mode || count > 10 {
                break;
            }
        }
        assert_eq!(
            app.search_mode, initial_mode,
            "search mode should cycle back to initial after {count} steps"
        );
        assert!(
            count <= 10,
            "search mode cycle should complete within 10 steps"
        );
    }

    #[test]
    fn filter_clear_all_resets_all_filter_state() {
        let mut app = CassApp::default();

        // Set various filters
        let mut agents = std::collections::HashSet::new();
        agents.insert("claude_code".to_string());
        let _ = app.update(CassMsg::FilterAgentSet(agents));
        let _ = app.update(CassMsg::TimePresetCycled); // All → Today

        // Clear all
        let _ = app.update(CassMsg::FiltersClearAll);

        assert!(
            app.filters.agents.is_empty(),
            "agents filter should be cleared"
        );
        assert_eq!(
            app.time_preset,
            TimePreset::All,
            "time preset should reset to All"
        );
    }

    // =========================================================================
    // Inspector Overlay Tests
    // =========================================================================

    #[test]
    fn inspector_toggle_opens_and_closes() {
        let mut app = CassApp::default();
        assert!(!app.show_inspector);

        let _ = app.update(CassMsg::InspectorToggled);
        assert!(app.show_inspector);
        assert!(app.inspector_state.is_active());

        let _ = app.update(CassMsg::InspectorToggled);
        assert!(!app.show_inspector);
        assert!(!app.inspector_state.is_active());
    }

    #[test]
    fn inspector_tab_cycles_through_all_tabs() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::InspectorToggled);
        assert_eq!(app.inspector_tab, InspectorTab::Timing);

        let _ = app.update(CassMsg::InspectorTabCycled);
        assert_eq!(app.inspector_tab, InspectorTab::Layout);

        let _ = app.update(CassMsg::InspectorTabCycled);
        assert_eq!(app.inspector_tab, InspectorTab::HitRegions);

        let _ = app.update(CassMsg::InspectorTabCycled);
        assert_eq!(app.inspector_tab, InspectorTab::Resize);

        let _ = app.update(CassMsg::InspectorTabCycled);
        assert_eq!(app.inspector_tab, InspectorTab::Diff);

        let _ = app.update(CassMsg::InspectorTabCycled);
        assert_eq!(app.inspector_tab, InspectorTab::Budget);

        let _ = app.update(CassMsg::InspectorTabCycled);
        assert_eq!(app.inspector_tab, InspectorTab::Timeline);

        let _ = app.update(CassMsg::InspectorTabCycled);
        assert_eq!(app.inspector_tab, InspectorTab::Timing);
    }

    #[test]
    fn inspector_esc_closes_overlay() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::InspectorToggled);
        assert!(app.show_inspector);

        let _ = app.update(CassMsg::QuitRequested);
        assert!(!app.show_inspector);
    }

    #[test]
    fn inspector_does_not_block_other_keys() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::InspectorToggled);
        assert!(app.show_inspector);

        // Help toggle should still work (inspector is non-blocking)
        let _ = app.update(CassMsg::HelpToggled);
        assert!(app.show_help);
    }

    #[test]
    fn inspector_off_by_default() {
        let app = CassApp::default();
        assert!(!app.show_inspector);
        assert_eq!(app.inspector_tab, InspectorTab::Timing);
        assert!(!app.inspector_state.is_active());
    }

    #[test]
    fn frame_timing_stats_basic() {
        let mut stats = FrameTimingStats::default();
        assert_eq!(stats.fps(), 0.0);
        assert_eq!(stats.avg_us(), 0);
        assert_eq!(stats.p95_us(), 0);
        assert_eq!(stats.last_us(), 0);

        // Simulate recording frames
        stats.record_frame(); // first frame: no delta
        std::thread::sleep(std::time::Duration::from_millis(1));
        let dt = stats.record_frame();
        assert!(dt.is_some());
        assert!(dt.unwrap() > 0);
        assert_eq!(stats.frame_times_us.len(), 1);
        assert!(stats.fps() > 0.0);
    }

    #[test]
    fn frame_timing_ring_buffer_caps_at_capacity() {
        let mut stats = FrameTimingStats::default();
        // Manually push 130 values (capacity is 120)
        for i in 0..130 {
            stats.frame_times_us.push_back(i * 100);
        }
        // Ring buffer should trim to capacity
        while stats.frame_times_us.len() > stats.capacity {
            stats.frame_times_us.pop_front();
        }
        assert!(stats.frame_times_us.len() <= 120);
    }

    #[test]
    fn inspector_render_does_not_panic_small_terminal() {
        use crate::ui::style_system::StyleOptions;
        let app = CassApp::default();
        let styles = StyleContext::from_options(StyleOptions::default());
        let mut pool = ftui::GraphemePool::new();
        let mut frame = ftui::Frame::new(10, 5, &mut pool);
        let area = Rect::new(0, 0, 10, 5);
        // Should not panic — auto-disables in small terminals
        app.render_inspector_overlay(&mut frame, area, &styles);
    }

    #[test]
    fn inspector_render_does_not_panic_normal_terminal() {
        use crate::ui::style_system::StyleOptions;
        let mut app = CassApp::default();
        app.show_inspector = true;
        let styles = StyleContext::from_options(StyleOptions::default());
        let mut pool = ftui::GraphemePool::new();
        let mut frame = ftui::Frame::new(120, 40, &mut pool);
        let area = Rect::new(0, 0, 120, 40);
        app.render_inspector_overlay(&mut frame, area, &styles);
    }

    #[test]
    fn inspector_tab_labels_are_unique() {
        let labels: Vec<&str> = [
            InspectorTab::Timing,
            InspectorTab::Layout,
            InspectorTab::HitRegions,
        ]
        .iter()
        .map(|t| t.label())
        .collect();
        let unique: HashSet<&str> = labels.iter().copied().collect();
        assert_eq!(labels.len(), unique.len());
    }

    #[test]
    fn ctrl_shift_i_maps_to_inspector_toggled() {
        use crate::ui::ftui_adapter::{Event, KeyCode, KeyEvent, Modifiers};
        let event = Event::Key(KeyEvent {
            code: KeyCode::Char('i'),
            modifiers: Modifiers::CTRL | Modifiers::SHIFT,
            kind: ftui::KeyEventKind::Press,
        });
        let msg = CassMsg::from(event);
        assert!(matches!(msg, CassMsg::InspectorToggled));
    }

    // =========================================================================
    // Theme Editor Tests
    // =========================================================================

    #[test]
    fn theme_editor_opens_and_closes() {
        let mut app = CassApp::default();
        assert!(!app.show_theme_editor);
        assert!(app.theme_editor.is_none());

        let _ = app.update(CassMsg::ThemeEditorOpened);
        assert!(app.show_theme_editor);
        assert!(app.theme_editor.is_some());

        let _ = app.update(CassMsg::ThemeEditorClosed);
        assert!(!app.show_theme_editor);
        assert!(app.theme_editor.is_none());
    }

    #[test]
    fn theme_editor_navigation_moves_selection() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::ThemeEditorOpened);

        let editor = app.theme_editor.as_ref().unwrap();
        assert_eq!(editor.selected, 0);

        let _ = app.update(CassMsg::ThemeEditorMoved { delta: 1 });
        assert_eq!(app.theme_editor.as_ref().unwrap().selected, 1);

        let _ = app.update(CassMsg::ThemeEditorMoved { delta: 1 });
        assert_eq!(app.theme_editor.as_ref().unwrap().selected, 2);

        let _ = app.update(CassMsg::ThemeEditorMoved { delta: -1 });
        assert_eq!(app.theme_editor.as_ref().unwrap().selected, 1);
    }

    #[test]
    fn theme_editor_navigation_clamps_at_boundaries() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::ThemeEditorOpened);

        // At top, moving up stays at 0
        let _ = app.update(CassMsg::ThemeEditorMoved { delta: -1 });
        assert_eq!(app.theme_editor.as_ref().unwrap().selected, 0);

        // Move to last slot
        for _ in 0..30 {
            let _ = app.update(CassMsg::ThemeEditorMoved { delta: 1 });
        }
        let n = ThemeColorSlot::ALL.len();
        assert_eq!(app.theme_editor.as_ref().unwrap().selected, n - 1);
    }

    #[test]
    fn theme_editor_navigation_blocked_while_editing() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::ThemeEditorOpened);

        let _ = app.update(CassMsg::ThemeEditorEditStarted);
        assert!(app.theme_editor.as_ref().unwrap().editing);

        // Moving while editing should be a no-op
        let _ = app.update(CassMsg::ThemeEditorMoved { delta: 1 });
        assert_eq!(app.theme_editor.as_ref().unwrap().selected, 0);
    }

    #[test]
    fn theme_editor_edit_start_and_cancel() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::ThemeEditorOpened);

        let _ = app.update(CassMsg::ThemeEditorEditStarted);
        assert!(app.theme_editor.as_ref().unwrap().editing);

        let _ = app.update(CassMsg::ThemeEditorEditCancelled);
        assert!(!app.theme_editor.as_ref().unwrap().editing);
        assert!(app.theme_editor.as_ref().unwrap().hex_buffer.is_empty());
    }

    #[test]
    fn theme_editor_edit_commit_sets_override() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::ThemeEditorOpened);

        // Start editing Primary (index 0)
        let _ = app.update(CassMsg::ThemeEditorEditStarted);
        let _ = app.update(CassMsg::ThemeEditorHexChanged("#ff0000".into()));
        assert_eq!(app.theme_editor.as_ref().unwrap().hex_buffer, "#ff0000");

        let _ = app.update(CassMsg::ThemeEditorEditCommitted);
        let editor = app.theme_editor.as_ref().unwrap();
        assert!(!editor.editing);
        assert_eq!(editor.overrides.primary.as_deref(), Some("#ff0000"));
    }

    #[test]
    fn theme_editor_edit_commit_empty_clears_override() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::ThemeEditorOpened);

        // First set a value
        let _ = app.update(CassMsg::ThemeEditorEditStarted);
        let _ = app.update(CassMsg::ThemeEditorHexChanged("#ff0000".into()));
        let _ = app.update(CassMsg::ThemeEditorEditCommitted);

        // Now commit with empty string to clear it
        let _ = app.update(CassMsg::ThemeEditorEditStarted);
        let _ = app.update(CassMsg::ThemeEditorHexChanged("".into()));
        let _ = app.update(CassMsg::ThemeEditorEditCommitted);

        let editor = app.theme_editor.as_ref().unwrap();
        assert!(editor.overrides.primary.is_none());
    }

    #[test]
    fn theme_editor_hex_change_only_when_editing() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::ThemeEditorOpened);

        // Not in editing mode — hex change should be ignored
        let _ = app.update(CassMsg::ThemeEditorHexChanged("#aabbcc".into()));
        assert!(app.theme_editor.as_ref().unwrap().hex_buffer.is_empty());
    }

    #[test]
    fn theme_editor_slot_clear() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::ThemeEditorOpened);

        // Set a value first
        let _ = app.update(CassMsg::ThemeEditorEditStarted);
        let _ = app.update(CassMsg::ThemeEditorHexChanged("#00ff00".into()));
        let _ = app.update(CassMsg::ThemeEditorEditCommitted);
        assert!(
            app.theme_editor
                .as_ref()
                .unwrap()
                .overrides
                .primary
                .is_some()
        );

        // Clear it
        let _ = app.update(CassMsg::ThemeEditorSlotCleared);
        assert!(
            app.theme_editor
                .as_ref()
                .unwrap()
                .overrides
                .primary
                .is_none()
        );
    }

    #[test]
    fn theme_editor_preset_cycling() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::ThemeEditorOpened);

        let initial = app.theme_editor.as_ref().unwrap().base_preset;
        let _ = app.update(CassMsg::ThemeEditorPresetCycled);
        let after = app.theme_editor.as_ref().unwrap().base_preset;
        assert_ne!(initial, after);
    }

    #[test]
    fn theme_editor_esc_closes() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::ThemeEditorOpened);
        assert!(app.show_theme_editor);

        let _ = app.update(CassMsg::QuitRequested);
        assert!(!app.show_theme_editor);
    }

    #[test]
    fn theme_editor_off_by_default() {
        let app = CassApp::default();
        assert!(!app.show_theme_editor);
        assert!(app.theme_editor.is_none());
    }

    #[test]
    fn theme_editor_to_config_round_trip() {
        let mut state = ThemeEditorState::new(style_system::UiThemePreset::default());
        ThemeColorSlot::Accent.set(&mut state.overrides, Some("#abc123".into()));

        let config = state.to_config();
        assert_eq!(config.colors.accent.as_deref(), Some("#abc123"));
        assert_eq!(config.base_preset, Some(state.base_preset));
    }

    #[test]
    fn theme_color_slot_all_has_19_entries() {
        assert_eq!(ThemeColorSlot::ALL.len(), 19);
    }

    #[test]
    fn theme_color_slot_labels_are_unique() {
        let labels: Vec<&str> = ThemeColorSlot::ALL.iter().map(|s| s.label()).collect();
        let unique: HashSet<&str> = labels.iter().copied().collect();
        assert_eq!(labels.len(), unique.len());
    }

    #[test]
    fn theme_color_slot_get_set_round_trip() {
        let mut overrides = style_system::ThemeColorOverrides::default();
        for slot in &ThemeColorSlot::ALL {
            assert!(slot.get(&overrides).is_none());
            slot.set(&mut overrides, Some("#facade".into()));
            assert_eq!(slot.get(&overrides), Some("#facade"));
            slot.set(&mut overrides, None);
            assert!(slot.get(&overrides).is_none());
        }
    }

    #[test]
    fn theme_editor_render_does_not_panic_small_terminal() {
        use crate::ui::style_system::StyleOptions;
        let app = CassApp::default();
        let styles = StyleContext::from_options(StyleOptions::default());
        let mut pool = ftui::GraphemePool::new();
        let mut frame = ftui::Frame::new(10, 5, &mut pool);
        let area = Rect::new(0, 0, 10, 5);
        app.render_theme_editor_overlay(&mut frame, area, &styles);
    }

    #[test]
    fn theme_editor_render_does_not_panic_normal_terminal() {
        use crate::ui::style_system::StyleOptions;
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::ThemeEditorOpened);
        let styles = StyleContext::from_options(StyleOptions::default());
        let mut pool = ftui::GraphemePool::new();
        let mut frame = ftui::Frame::new(120, 40, &mut pool);
        let area = Rect::new(0, 0, 120, 40);
        app.render_theme_editor_overlay(&mut frame, area, &styles);
    }

    #[test]
    fn ctrl_shift_t_maps_to_theme_editor_opened() {
        use crate::ui::ftui_adapter::{Event, KeyCode, KeyEvent, Modifiers};
        let event = Event::Key(KeyEvent {
            code: KeyCode::Char('t'),
            modifiers: Modifiers::CTRL | Modifiers::SHIFT,
            kind: ftui::KeyEventKind::Press,
        });
        let msg = CassMsg::from(event);
        assert!(matches!(msg, CassMsg::ThemeEditorOpened));
    }

    #[test]
    fn theme_editor_import_loads_saved_config() {
        let tmp = tempfile::TempDir::new().unwrap();
        let theme_dir = tmp.path().join("coding-agent-search");
        std::fs::create_dir_all(&theme_dir).unwrap();
        let theme_path = theme_dir.join("theme.json");
        let config_json =
            r##"{"version":1,"base_preset":"catppuccin","colors":{"accent":"#ff00ff"}}"##;
        std::fs::write(&theme_path, config_json).unwrap();

        // Load config directly (ThemeEditorOpened handler uses dirs::data_dir which
        // we can't override in unit tests, so test the config loading logic directly).
        let cfg = style_system::ThemeConfig::load_from_path(&theme_path).unwrap();
        let mut state = ThemeEditorState::new(style_system::UiThemePreset::Dark);
        if let Some(preset) = cfg.base_preset {
            state.base_preset = preset;
        }
        state.overrides = cfg.colors;

        assert_eq!(state.base_preset, style_system::UiThemePreset::Catppuccin);
        assert_eq!(state.overrides.accent.as_deref(), Some("#ff00ff"));
    }

    #[test]
    fn theme_editor_export_applies_preset_to_main() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::ThemeEditorOpened);

        // Cycle preset in editor
        let _ = app.update(CassMsg::ThemeEditorPresetCycled);
        let editor_preset = app.theme_editor.as_ref().unwrap().base_preset;
        // The main preset should not change until export
        assert_ne!(app.theme_preset, editor_preset);

        // Export (will try to save to disk — may fail in test env, but
        // we're testing the preset-apply logic, not file I/O).
        let _ = app.update(CassMsg::ThemeEditorExported);
        // After export, the main preset should match the editor preset.
        assert_eq!(app.theme_preset, editor_preset);
    }

    // =========================================================================
    // Sources management tests (2noh9.4.9)
    // =========================================================================

    #[test]
    fn sources_entered_switches_surface() {
        let mut app = CassApp::default();
        assert_eq!(app.surface, AppSurface::Search);

        let _ = app.update(CassMsg::SourcesEntered);
        assert_eq!(app.surface, AppSurface::Sources);
        assert_eq!(app.view_stack, vec![AppSurface::Search]);
    }

    #[test]
    fn sources_esc_pops_back_to_search() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::SourcesEntered);
        assert_eq!(app.surface, AppSurface::Sources);

        let _ = app.update(CassMsg::ViewStackPopped);
        assert_eq!(app.surface, AppSurface::Search);
    }

    #[test]
    fn sources_quit_requested_pops_back() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::SourcesEntered);
        assert_eq!(app.surface, AppSurface::Sources);

        // QuitRequested emits ViewStackPopped as a command.
        // In tests, manually dispatch the second message.
        let _ = app.update(CassMsg::QuitRequested);
        let _ = app.update(CassMsg::ViewStackPopped);
        assert_eq!(app.surface, AppSurface::Search);
    }

    #[test]
    fn sources_selection_wraps() {
        let mut app = CassApp::default();
        app.sources_view.items = vec![
            SourcesViewItem {
                name: "local".into(),
                kind: crate::sources::SourceKind::Local,
                host: None,
                schedule: "always".into(),
                path_count: 0,
                last_sync: None,
                last_result: "n/a".into(),
                files_synced: 0,
                bytes_transferred: 0,
                busy: false,
                doctor_summary: None,
                error: None,
            },
            SourcesViewItem {
                name: "laptop".into(),
                kind: crate::sources::SourceKind::Ssh,
                host: Some("user@laptop".into()),
                schedule: "daily".into(),
                path_count: 2,
                last_sync: None,
                last_result: "never".into(),
                files_synced: 0,
                bytes_transferred: 0,
                busy: false,
                doctor_summary: None,
                error: None,
            },
        ];
        app.sources_view.selected = 0;

        let _ = app.update(CassMsg::SourcesSelectionMoved { delta: 1 });
        assert_eq!(app.sources_view.selected, 1);

        let _ = app.update(CassMsg::SourcesSelectionMoved { delta: 1 });
        assert_eq!(app.sources_view.selected, 0); // wraps

        let _ = app.update(CassMsg::SourcesSelectionMoved { delta: -1 });
        assert_eq!(app.sources_view.selected, 1); // wraps backward
    }

    #[test]
    fn sources_sync_requested_marks_busy() {
        let mut app = CassApp::default();
        app.sources_view.items = vec![SourcesViewItem {
            name: "laptop".into(),
            kind: crate::sources::SourceKind::Ssh,
            host: Some("user@laptop".into()),
            schedule: "manual".into(),
            path_count: 1,
            last_sync: None,
            last_result: "never".into(),
            files_synced: 0,
            bytes_transferred: 0,
            busy: false,
            doctor_summary: None,
            error: None,
        }];

        let _ = app.update(CassMsg::SourceSyncRequested("laptop".into()));
        assert!(app.sources_view.items[0].busy);
        assert!(app.sources_view.status.contains("Syncing"));
    }

    #[test]
    fn sources_sync_completed_clears_busy() {
        let mut app = CassApp::default();
        app.sources_view.items = vec![SourcesViewItem {
            name: "laptop".into(),
            kind: crate::sources::SourceKind::Ssh,
            host: Some("user@laptop".into()),
            schedule: "manual".into(),
            path_count: 1,
            last_sync: None,
            last_result: "never".into(),
            files_synced: 0,
            bytes_transferred: 0,
            busy: true,
            doctor_summary: None,
            error: None,
        }];

        let _ = app.update(CassMsg::SourceSyncCompleted {
            source_name: "laptop".into(),
            message: "Synced 42 files".into(),
        });
        assert!(!app.sources_view.items[0].busy);
        assert_eq!(app.sources_view.status, "Synced 42 files");
    }

    #[test]
    fn sources_doctor_completed_sets_summary() {
        let mut app = CassApp::default();
        app.sources_view.items = vec![SourcesViewItem {
            name: "laptop".into(),
            kind: crate::sources::SourceKind::Ssh,
            host: Some("user@laptop".into()),
            schedule: "manual".into(),
            path_count: 1,
            last_sync: None,
            last_result: "never".into(),
            files_synced: 0,
            bytes_transferred: 0,
            busy: true,
            doctor_summary: None,
            error: None,
        }];

        let _ = app.update(CassMsg::SourceDoctorCompleted {
            source_name: "laptop".into(),
            passed: 3,
            warnings: 1,
            failed: 0,
        });
        assert!(!app.sources_view.items[0].busy);
        assert_eq!(app.sources_view.items[0].doctor_summary, Some((3, 1, 0)));
        assert!(app.sources_view.status.contains("3 pass"));
    }

    #[test]
    fn sources_view_renders_without_panic() {
        let mut app = CassApp::default();
        app.surface = AppSurface::Sources;
        app.sources_view.items = vec![SourcesViewItem {
            name: "local".into(),
            kind: crate::sources::SourceKind::Local,
            host: None,
            schedule: "always".into(),
            path_count: 0,
            last_sync: None,
            last_result: "n/a".into(),
            files_synced: 0,
            bytes_transferred: 0,
            busy: false,
            doctor_summary: None,
            error: None,
        }];
        let mut pool = ftui::GraphemePool::new();
        let mut frame = ftui::Frame::new(80, 24, &mut pool);
        app.view(&mut frame);
        // No panic = pass.
    }

    #[test]
    fn sources_key_suppresses_query_input() {
        let mut app = CassApp::default();
        app.surface = AppSurface::Sources;

        // Typing a random char should not modify the query.
        let _ = app.update(CassMsg::QueryChanged("x".into()));
        assert!(app.query.is_empty());
    }

    #[test]
    fn sources_entered_idempotent() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::SourcesEntered);
        let _ = app.update(CassMsg::SourcesEntered);
        // Should not double-push onto view stack.
        assert_eq!(app.view_stack.len(), 1);
        assert_eq!(app.surface, AppSurface::Sources);
    }

    #[test]
    fn sources_from_analytics_stacks_correctly() {
        let mut app = CassApp::default();
        let _ = app.update(CassMsg::AnalyticsEntered);
        assert_eq!(app.surface, AppSurface::Analytics);

        let _ = app.update(CassMsg::SourcesEntered);
        assert_eq!(app.surface, AppSurface::Sources);
        assert_eq!(
            app.view_stack,
            vec![AppSurface::Search, AppSurface::Analytics]
        );

        let _ = app.update(CassMsg::ViewStackPopped);
        assert_eq!(app.surface, AppSurface::Analytics);

        let _ = app.update(CassMsg::ViewStackPopped);
        assert_eq!(app.surface, AppSurface::Search);
    }

    // -----------------------------------------------------------------------
    // BOCPD resize coalescer configuration (1mfw3.2.2)
    // -----------------------------------------------------------------------

    #[test]
    fn bocpd_coalescer_config_defaults_are_sane() {
        use ftui::runtime::bocpd::BocpdConfig;
        use ftui::runtime::resize_coalescer::CoalescerConfig;

        let bocpd = BocpdConfig::responsive();
        let config = CoalescerConfig::default()
            .with_bocpd_config(bocpd.clone())
            .with_logging(true);

        // BOCPD is enabled
        assert!(config.enable_bocpd);
        assert!(config.bocpd_config.is_some());
        assert!(config.enable_logging);

        // Responsive preset uses lower thresholds for faster detection
        assert!(
            bocpd.mu_steady_ms < 200.0,
            "responsive should be faster than default"
        );
        assert!(
            bocpd.mu_burst_ms < 20.0,
            "responsive burst should be faster"
        );
        assert!(
            bocpd.hazard_lambda < 50.0,
            "responsive expects more frequent changepoints"
        );
        assert!(bocpd.steady_threshold < 0.3);
        assert!(bocpd.burst_threshold < 0.7);
    }

    #[test]
    fn bocpd_coalescer_config_respects_env_disable() {
        use ftui::runtime::bocpd::BocpdConfig;
        use ftui::runtime::resize_coalescer::CoalescerConfig;

        // Simulate CASS_BOCPD=0 logic
        let bocpd_disabled = true;

        let config = if bocpd_disabled {
            CoalescerConfig::default()
        } else {
            let bocpd = BocpdConfig::responsive().with_logging(true);
            CoalescerConfig::default()
                .with_bocpd_config(bocpd)
                .with_logging(true)
        };

        assert!(
            !config.enable_bocpd,
            "BOCPD should be disabled when env says so"
        );
        assert!(config.bocpd_config.is_none());
        assert!(!config.enable_logging);
    }

    #[test]
    fn bocpd_coalescer_timing_thresholds_are_bounded() {
        use ftui::runtime::resize_coalescer::CoalescerConfig;

        let config = CoalescerConfig::default();

        // Steady delay ≤ burst delay ≤ hard deadline
        assert!(config.steady_delay_ms <= config.burst_delay_ms);
        assert!(config.burst_delay_ms <= config.hard_deadline_ms);

        // Hard deadline bounded to prevent UI freezes
        assert!(
            config.hard_deadline_ms <= 200,
            "hard deadline should not exceed 200ms"
        );

        // Burst enter rate > exit rate (hysteresis)
        assert!(config.burst_enter_rate > config.burst_exit_rate);
    }

    #[test]
    fn evidence_sink_config_writes_to_data_dir() {
        use ftui::runtime::evidence_sink::{EvidenceSinkConfig, EvidenceSinkDestination};

        let data_dir = std::path::PathBuf::from("/tmp/cass-test");
        let evidence_path = data_dir.join("resize_evidence.jsonl");

        let config = EvidenceSinkConfig {
            enabled: true,
            destination: EvidenceSinkDestination::file(&evidence_path),
            flush_on_write: false,
        };

        assert!(config.enabled);
        // Verify destination is a file path
        assert!(
            matches!(&config.destination, EvidenceSinkDestination::File(_)),
            "expected file destination"
        );
        if let EvidenceSinkDestination::File(p) = &config.destination {
            assert_eq!(p, &evidence_path);
        }
    }

    // -- Evidence snapshots (1mfw3.2.3) -----------------------------------

    #[test]
    fn evidence_snapshots_default_is_empty() {
        let evidence = EvidenceSnapshots::default();
        assert!(evidence.resize.is_none());
        assert!(evidence.diff.is_none());
        assert!(evidence.budget.is_none());
        assert!(!evidence.has_any());
    }

    #[test]
    fn evidence_snapshots_has_any_detects_resize() {
        let mut evidence = EvidenceSnapshots::default();
        assert!(!evidence.has_any());
        // After refresh, still None if no runtime has emitted anything
        evidence.refresh();
        // has_any depends on what the global singletons hold
        // In test context there's no runtime, so they remain None
    }

    #[test]
    fn evidence_regime_label_none_returns_dash() {
        let evidence = EvidenceSnapshots::default();
        assert_eq!(evidence.resize_regime_label(), "\u{2014}");
    }

    #[test]
    fn evidence_degradation_label_none_returns_dash() {
        let evidence = EvidenceSnapshots::default();
        assert_eq!(evidence.degradation_label(), "\u{2014}");
    }

    #[test]
    fn evidence_snapshots_in_cass_app_default() {
        let app = CassApp::default();
        assert!(!app.evidence.has_any());
        assert_eq!(app.evidence.resize_regime_label(), "\u{2014}");
        assert_eq!(app.evidence.degradation_label(), "\u{2014}");
    }

    #[test]
    fn evidence_refresh_is_error_tolerant() {
        // Calling refresh when no runtime is active should not panic
        let mut evidence = EvidenceSnapshots::default();
        evidence.refresh();
        evidence.refresh();
        evidence.refresh();
        // No panic = success; evidence stays None with no runtime
    }

    // -- Resize evidence summary (1mfw3.2.4) --------------------------------

    fn make_resize_snapshot(
        event_idx: u64,
        regime: ftui::runtime::resize_coalescer::Regime,
    ) -> ftui::runtime::evidence_telemetry::ResizeDecisionSnapshot {
        ftui::runtime::evidence_telemetry::ResizeDecisionSnapshot {
            event_idx,
            action: "apply",
            dt_ms: 16.6,
            event_rate: 60.0,
            regime,
            pending_size: None,
            applied_size: Some((120, 40)),
            time_since_render_ms: 8.3,
            bocpd: None,
        }
    }

    fn make_budget_snapshot(
        degradation: ftui::render::budget::DegradationLevel,
    ) -> ftui::runtime::evidence_telemetry::BudgetDecisionSnapshot {
        ftui::runtime::evidence_telemetry::BudgetDecisionSnapshot {
            frame_idx: 1,
            decision: ftui::render::budget::BudgetDecision::Hold,
            controller_decision: ftui::render::budget::BudgetDecision::Hold,
            degradation_before: ftui::render::budget::DegradationLevel::Full,
            degradation_after: degradation,
            frame_time_us: 5000.0,
            budget_us: 16666.0,
            pid_output: 0.3,
            e_value: 1.0,
            frames_observed: 100,
            frames_since_change: 50,
            in_warmup: false,
            conformal: None,
        }
    }

    #[test]
    fn resize_evidence_summary_default_has_no_data() {
        let summary = ResizeEvidenceSummary::default();
        assert!(!summary.has_data());
        assert_eq!(summary.history_len(), 0);
        assert_eq!(summary.regime, "\u{2014}");
        assert_eq!(summary.degradation, "\u{2014}");
        assert_eq!(summary.budget_us, 0.0);
        assert_eq!(summary.frame_time_us, 0.0);
        assert!(summary.applied_size.is_none());
        assert!(summary.bocpd_p_burst.is_none());
    }

    #[test]
    fn resize_evidence_summary_update_from_resize() {
        let mut summary = ResizeEvidenceSummary::default();
        let resize = Some(make_resize_snapshot(
            1,
            ftui::runtime::resize_coalescer::Regime::Steady,
        ));
        summary.update_from_raw(&resize, &None);
        assert!(summary.has_data());
        assert_eq!(summary.regime, "Steady");
        assert_eq!(summary.applied_size, Some((120, 40)));
        assert_eq!(summary.history_len(), 1);
    }

    #[test]
    fn resize_evidence_summary_update_from_budget() {
        let mut summary = ResizeEvidenceSummary::default();
        let budget = Some(make_budget_snapshot(
            ftui::render::budget::DegradationLevel::SimpleBorders,
        ));
        summary.update_from_raw(&None, &budget);
        assert!(summary.has_data());
        assert_eq!(summary.degradation, "SimpleBorders");
        assert_eq!(summary.budget_us, 16666.0);
        assert_eq!(summary.frame_time_us, 5000.0);
        assert_eq!(summary.pid_output, 0.3);
        assert!(!summary.in_warmup);
        assert_eq!(summary.frames_observed, 100);
    }

    #[test]
    fn resize_evidence_summary_deduplicates_by_event_idx() {
        let mut summary = ResizeEvidenceSummary::default();
        let resize = Some(make_resize_snapshot(
            1,
            ftui::runtime::resize_coalescer::Regime::Burst,
        ));
        summary.update_from_raw(&resize, &None);
        summary.update_from_raw(&resize, &None);
        assert_eq!(summary.history_len(), 1);
        let resize2 = Some(make_resize_snapshot(
            2,
            ftui::runtime::resize_coalescer::Regime::Burst,
        ));
        summary.update_from_raw(&resize2, &None);
        assert_eq!(summary.history_len(), 2);
    }

    #[test]
    fn resize_evidence_summary_ring_buffer_evicts() {
        let mut summary = ResizeEvidenceSummary::default();
        for i in 1..=(RESIZE_HISTORY_CAPACITY + 5) as u64 {
            let resize = Some(make_resize_snapshot(
                i,
                ftui::runtime::resize_coalescer::Regime::Steady,
            ));
            summary.update_from_raw(&resize, &None);
        }
        assert_eq!(summary.history_len(), RESIZE_HISTORY_CAPACITY);
        assert_eq!(summary.recent_resizes.front().unwrap().event_idx, 6);
    }

    #[test]
    fn resize_evidence_summary_burst_regime() {
        let mut summary = ResizeEvidenceSummary::default();
        let resize = Some(make_resize_snapshot(
            1,
            ftui::runtime::resize_coalescer::Regime::Burst,
        ));
        summary.update_from_raw(&resize, &None);
        assert_eq!(summary.regime, "Burst");
        assert_eq!(summary.recent_resizes.back().unwrap().regime, "Burst");
    }

    #[test]
    fn resize_evidence_summary_with_bocpd() {
        use ftui::runtime::bocpd::{BocpdEvidence, BocpdRegime};
        let mut summary = ResizeEvidenceSummary::default();
        let resize = Some(ftui::runtime::evidence_telemetry::ResizeDecisionSnapshot {
            event_idx: 1,
            action: "defer",
            dt_ms: 5.0,
            event_rate: 200.0,
            regime: ftui::runtime::resize_coalescer::Regime::Burst,
            pending_size: Some((80, 24)),
            applied_size: None,
            time_since_render_ms: 2.0,
            bocpd: Some(BocpdEvidence {
                p_burst: 0.85,
                log_bayes_factor: 2.1,
                observation_ms: 5.0,
                regime: BocpdRegime::Burst,
                likelihood_steady: 0.01,
                likelihood_burst: 0.99,
                expected_run_length: 3.5,
                run_length_variance: 1.2,
                run_length_mode: 3,
                run_length_p95: 7,
                run_length_tail_mass: 0.001,
                recommended_delay_ms: Some(50),
                hard_deadline_forced: None,
                observation_count: 42,
                timestamp: std::time::Instant::now(),
            }),
        });
        summary.update_from_raw(&resize, &None);
        assert_eq!(summary.bocpd_p_burst, Some(0.85));
        assert_eq!(summary.bocpd_delay_ms, Some(50));
        assert_eq!(summary.history_len(), 1);
        assert_eq!(
            summary.recent_resizes.back().unwrap().bocpd_p_burst,
            Some(0.85)
        );
    }

    #[test]
    fn resize_evidence_summary_all_degradation_levels() {
        use ftui::render::budget::DegradationLevel;
        let cases = [
            (DegradationLevel::Full, "Full"),
            (DegradationLevel::SimpleBorders, "SimpleBorders"),
            (DegradationLevel::NoStyling, "NoStyling"),
            (DegradationLevel::EssentialOnly, "EssentialOnly"),
            (DegradationLevel::Skeleton, "Skeleton"),
            (DegradationLevel::SkipFrame, "SkipFrame"),
        ];
        for (level, expected) in cases {
            let mut summary = ResizeEvidenceSummary::default();
            let budget = Some(make_budget_snapshot(level));
            summary.update_from_raw(&None, &budget);
            assert_eq!(
                summary.degradation, expected,
                "DegradationLevel::{expected}"
            );
        }
    }

    // -- Inspector Resize tab rendering (1mfw3.2.5) -------------------------

    #[test]
    fn inspector_resize_tab_label() {
        assert_eq!(InspectorTab::Resize.label(), "Resize");
    }

    #[test]
    fn inspector_resize_tab_cycles_correctly() {
        assert_eq!(InspectorTab::HitRegions.next(), InspectorTab::Resize);
        assert_eq!(InspectorTab::Resize.next(), InspectorTab::Diff);
        assert_eq!(InspectorTab::Diff.next(), InspectorTab::Budget);
        assert_eq!(InspectorTab::Budget.next(), InspectorTab::Timeline);
        assert_eq!(InspectorTab::Timeline.next(), InspectorTab::Timing);
    }

    #[test]
    fn inspector_budget_overrun_detected() {
        use ftui::render::budget::{BudgetDecision, DegradationLevel};
        let mut app = CassApp::default();
        app.show_inspector = true;
        app.inspector_tab = InspectorTab::Budget;
        app.evidence.budget = Some(ftui::runtime::evidence_telemetry::BudgetDecisionSnapshot {
            frame_idx: 100,
            decision: BudgetDecision::Hold,
            controller_decision: BudgetDecision::Hold,
            degradation_before: DegradationLevel::Full,
            degradation_after: DegradationLevel::Full,
            frame_time_us: 20000.0,
            budget_us: 16000.0,
            pid_output: 0.4,
            e_value: 2.0,
            frames_observed: 50,
            frames_since_change: 30,
            in_warmup: false,
            conformal: None,
        });
        let b = app.evidence.budget.as_ref().unwrap();
        assert!(b.frame_time_us > b.budget_us, "overrun detected");
        assert!(b.pid_output > 0.1, "pressure increasing");
    }

    #[test]
    fn inspector_budget_degradation_warning() {
        use ftui::render::budget::{BudgetDecision, DegradationLevel};
        let mut app = CassApp::default();
        app.show_inspector = true;
        app.inspector_tab = InspectorTab::Budget;
        app.evidence.budget = Some(ftui::runtime::evidence_telemetry::BudgetDecisionSnapshot {
            frame_idx: 200,
            decision: BudgetDecision::Degrade,
            controller_decision: BudgetDecision::Degrade,
            degradation_before: DegradationLevel::Full,
            degradation_after: DegradationLevel::SimpleBorders,
            frame_time_us: 25000.0,
            budget_us: 16000.0,
            pid_output: 0.8,
            e_value: 25.0,
            frames_observed: 80,
            frames_since_change: 0,
            in_warmup: false,
            conformal: None,
        });
        let b = app.evidence.budget.as_ref().unwrap();
        assert!(
            b.degradation_after as u8 > b.degradation_before as u8,
            "degrading"
        );
        assert!(b.e_value > 20.0, "e-value critical");
    }

    #[test]
    fn inspector_budget_healthy_state() {
        use ftui::render::budget::{BudgetDecision, DegradationLevel};
        let mut app = CassApp::default();
        app.evidence.budget = Some(ftui::runtime::evidence_telemetry::BudgetDecisionSnapshot {
            frame_idx: 300,
            decision: BudgetDecision::Hold,
            controller_decision: BudgetDecision::Hold,
            degradation_before: DegradationLevel::Full,
            degradation_after: DegradationLevel::Full,
            frame_time_us: 8000.0,
            budget_us: 16000.0,
            pid_output: -0.2,
            e_value: 0.3,
            frames_observed: 200,
            frames_since_change: 150,
            in_warmup: false,
            conformal: None,
        });
        let b = app.evidence.budget.as_ref().unwrap();
        assert!(b.frame_time_us < b.budget_us, "within budget");
        assert!(b.e_value < 0.5, "healthy zone");
        assert!(b.pid_output < -0.1, "pressure decreasing");
    }

    #[test]
    fn inspector_budget_conformal_risk() {
        use ftui::render::budget::{BudgetDecision, DegradationLevel};
        let mut app = CassApp::default();
        app.evidence.budget = Some(ftui::runtime::evidence_telemetry::BudgetDecisionSnapshot {
            frame_idx: 400,
            decision: BudgetDecision::Hold,
            controller_decision: BudgetDecision::Hold,
            degradation_before: DegradationLevel::Full,
            degradation_after: DegradationLevel::Full,
            frame_time_us: 15000.0,
            budget_us: 16000.0,
            pid_output: 0.05,
            e_value: 1.5,
            frames_observed: 100,
            frames_since_change: 50,
            in_warmup: false,
            conformal: Some(ftui::runtime::evidence_telemetry::ConformalSnapshot {
                bucket_key: "alt:Full:medium".to_string(),
                sample_count: 42,
                upper_us: 18000.0,
                risk: true,
            }),
        });
        let b = app.evidence.budget.as_ref().unwrap();
        assert!(b.conformal.as_ref().unwrap().risk, "conformal risk flagged");
    }

    #[test]
    fn inspector_resize_tab_reachable() {
        let mut app = CassApp::default();
        app.show_inspector = true;
        app.inspector_tab = InspectorTab::Resize;
        // Verify the evidence summary is accessible
        assert!(!app.evidence.summary.has_data());
        assert_eq!(app.evidence.summary.regime, "\u{2014}");
    }

    #[test]
    fn inspector_resize_tab_with_evidence() {
        let mut app = CassApp::default();
        app.show_inspector = true;
        app.inspector_tab = InspectorTab::Resize;
        // Feed in some evidence data
        let resize = Some(make_resize_snapshot(
            1,
            ftui::runtime::resize_coalescer::Regime::Steady,
        ));
        let budget = Some(make_budget_snapshot(
            ftui::render::budget::DegradationLevel::Full,
        ));
        app.evidence.summary.update_from_raw(&resize, &budget);
        assert!(app.evidence.summary.has_data());
        assert_eq!(app.evidence.summary.regime, "Steady");
        assert_eq!(app.evidence.summary.degradation, "Full");
    }

    #[test]
    fn inspector_diff_tab_label() {
        assert_eq!(InspectorTab::Diff.label(), "Diff");
    }

    #[test]
    fn inspector_diff_with_dirty_rows_strategy() {
        let mut app = CassApp::default();
        app.show_inspector = true;
        app.inspector_tab = InspectorTab::Diff;
        app.evidence.diff = Some(ftui::runtime::evidence_telemetry::DiffDecisionSnapshot {
            event_idx: 1,
            screen_mode: "Fullscreen".to_string(),
            cols: 120,
            rows: 40,
            evidence: ftui::render::diff_strategy::StrategyEvidence {
                strategy: ftui::render::diff_strategy::DiffStrategy::DirtyRows,
                cost_full: 500.0,
                cost_dirty: 150.0,
                cost_redraw: 800.0,
                posterior_mean: 0.15,
                posterior_variance: 0.01,
                alpha: 3.0,
                beta: 17.0,
                dirty_rows: 6,
                total_rows: 40,
                total_cells: 4800,
                guard_reason: "",
                hysteresis_applied: false,
                hysteresis_ratio: 0.0,
            },
            span_count: 3,
            span_coverage_pct: 0.65,
            max_span_len: 45,
            scan_cost_estimate: 200,
            fallback_reason: String::new(),
            tile_used: true,
            tile_fallback: String::new(),
            strategy_used: ftui::render::diff_strategy::DiffStrategy::DirtyRows,
        });
        let d = app.evidence.diff.as_ref().unwrap();
        assert!(
            d.evidence.cost_dirty < d.evidence.cost_full,
            "DirtyRows cheapest"
        );
        assert!(d.evidence.posterior_mean < 0.5, "low change rate");
    }

    #[test]
    fn inspector_diff_full_redraw_flagged() {
        let mut app = CassApp::default();
        app.show_inspector = true;
        app.inspector_tab = InspectorTab::Diff;
        app.evidence.diff = Some(ftui::runtime::evidence_telemetry::DiffDecisionSnapshot {
            event_idx: 2,
            screen_mode: "Fullscreen".to_string(),
            cols: 80,
            rows: 24,
            evidence: ftui::render::diff_strategy::StrategyEvidence {
                strategy: ftui::render::diff_strategy::DiffStrategy::FullRedraw,
                cost_full: 400.0,
                cost_dirty: 380.0,
                cost_redraw: 300.0,
                posterior_mean: 0.85,
                posterior_variance: 0.02,
                alpha: 17.0,
                beta: 3.0,
                dirty_rows: 20,
                total_rows: 24,
                total_cells: 1920,
                guard_reason: "",
                hysteresis_applied: false,
                hysteresis_ratio: 0.0,
            },
            span_count: 1,
            span_coverage_pct: 1.0,
            max_span_len: 1920,
            scan_cost_estimate: 1920,
            fallback_reason: String::new(),
            tile_used: false,
            tile_fallback: "too many dirty rows".to_string(),
            strategy_used: ftui::render::diff_strategy::DiffStrategy::FullRedraw,
        });
        let d = app.evidence.diff.as_ref().unwrap();
        assert!(d.evidence.posterior_mean > 0.5, "high change rate");
        assert!(
            matches!(
                d.strategy_used,
                ftui::render::diff_strategy::DiffStrategy::FullRedraw
            ),
            "full redraw selected"
        );
    }

    // -- Timeline event feed tests (1mfw3.3.6) ---------------------------

    #[test]
    fn timeline_buffer_starts_empty() {
        let buf = TimelineBuffer::new();
        assert!(buf.is_empty());
        assert_eq!(buf.len(), 0);
    }

    #[test]
    fn timeline_captures_resize_event() {
        let mut buf = TimelineBuffer::new();
        let resize = Some(ftui::runtime::evidence_telemetry::ResizeDecisionSnapshot {
            event_idx: 1,
            action: "apply",
            dt_ms: 50.0,
            event_rate: 2.0,
            regime: ftui::runtime::resize_coalescer::Regime::Steady,
            pending_size: None,
            applied_size: Some((120, 40)),
            bocpd: None,
            time_since_render_ms: 0.0,
        });
        buf.update_from_snapshots(&resize, &None, &None);
        assert_eq!(buf.len(), 1);
        let event = buf.recent().next().unwrap();
        assert_eq!(event.kind, TimelineEventKind::Resize);
        assert!(event.summary.contains("apply"));
    }

    #[test]
    fn timeline_deduplicates_by_frame_idx() {
        let mut buf = TimelineBuffer::new();
        let resize = Some(ftui::runtime::evidence_telemetry::ResizeDecisionSnapshot {
            event_idx: 5,
            action: "apply",
            dt_ms: 50.0,
            event_rate: 2.0,
            regime: ftui::runtime::resize_coalescer::Regime::Steady,
            pending_size: None,
            applied_size: Some((80, 24)),
            bocpd: None,
            time_since_render_ms: 0.0,
        });
        buf.update_from_snapshots(&resize, &None, &None);
        buf.update_from_snapshots(&resize, &None, &None);
        assert_eq!(buf.len(), 1, "same event_idx should not duplicate");
    }

    #[test]
    fn timeline_ring_buffer_evicts() {
        let mut buf = TimelineBuffer::new();
        for i in 1..=(TIMELINE_CAPACITY + 5) {
            let resize = Some(ftui::runtime::evidence_telemetry::ResizeDecisionSnapshot {
                event_idx: i as u64,
                action: "apply",
                dt_ms: 10.0,
                event_rate: 1.0,
                regime: ftui::runtime::resize_coalescer::Regime::Steady,
                pending_size: None,
                applied_size: Some((80, 24)),
                bocpd: None,
                time_since_render_ms: 0.0,
            });
            buf.update_from_snapshots(&resize, &None, &None);
        }
        assert_eq!(buf.len(), TIMELINE_CAPACITY, "should cap at capacity");
    }

    #[test]
    fn timeline_captures_all_event_kinds() {
        let mut buf = TimelineBuffer::new();
        let resize = Some(ftui::runtime::evidence_telemetry::ResizeDecisionSnapshot {
            event_idx: 1,
            action: "apply",
            dt_ms: 50.0,
            event_rate: 2.0,
            regime: ftui::runtime::resize_coalescer::Regime::Steady,
            pending_size: None,
            applied_size: Some((120, 40)),
            bocpd: None,
            time_since_render_ms: 0.0,
        });
        let diff = Some(ftui::runtime::evidence_telemetry::DiffDecisionSnapshot {
            event_idx: 2,
            screen_mode: "Fullscreen".to_string(),
            cols: 120,
            rows: 40,
            evidence: ftui::render::diff_strategy::StrategyEvidence {
                strategy: ftui::render::diff_strategy::DiffStrategy::DirtyRows,
                cost_full: 500.0,
                cost_dirty: 150.0,
                cost_redraw: 800.0,
                posterior_mean: 0.15,
                posterior_variance: 0.01,
                alpha: 3.0,
                beta: 17.0,
                dirty_rows: 6,
                total_rows: 40,
                total_cells: 4800,
                guard_reason: "",
                hysteresis_applied: false,
                hysteresis_ratio: 0.0,
            },
            span_count: 3,
            span_coverage_pct: 0.65,
            max_span_len: 45,
            scan_cost_estimate: 200,
            fallback_reason: String::new(),
            tile_used: true,
            tile_fallback: String::new(),
            strategy_used: ftui::render::diff_strategy::DiffStrategy::DirtyRows,
        });
        let budget = Some(ftui::runtime::evidence_telemetry::BudgetDecisionSnapshot {
            frame_idx: 3,
            decision: ftui::render::budget::BudgetDecision::Hold,
            controller_decision: ftui::render::budget::BudgetDecision::Hold,
            degradation_before: ftui::render::budget::DegradationLevel::Full,
            degradation_after: ftui::render::budget::DegradationLevel::Full,
            frame_time_us: 10000.0,
            budget_us: 16000.0,
            pid_output: 0.0,
            e_value: 0.5,
            frames_observed: 100,
            frames_since_change: 50,
            in_warmup: false,
            conformal: None,
        });
        buf.update_from_snapshots(&resize, &diff, &budget);
        assert_eq!(buf.len(), 3);
        let kinds: Vec<_> = buf.recent().map(|e| e.kind).collect();
        assert!(kinds.contains(&TimelineEventKind::Resize));
        assert!(kinds.contains(&TimelineEventKind::DiffStrategy));
        assert!(kinds.contains(&TimelineEventKind::BudgetChange));
    }

    #[test]
    fn timeline_tab_label() {
        assert_eq!(InspectorTab::Timeline.label(), "Log");
    }

    #[test]
    fn timeline_tab_empty_evidence() {
        let app = CassApp::default();
        assert!(app.evidence.timeline.is_empty());
    }

    #[test]
    fn inspector_budget_tab_label() {
        assert_eq!(InspectorTab::Budget.label(), "Budget");
    }

    #[test]
    fn inspector_diff_tab_no_evidence() {
        let app = CassApp::default();
        assert!(app.evidence.diff.is_none());
    }

    #[test]
    fn inspector_budget_tab_no_evidence() {
        let app = CassApp::default();
        assert!(app.evidence.budget.is_none());
    }

    // -----------------------------------------------------------------------
    // Responsive inspector sizing tests (1mfw3.3.3)
    // -----------------------------------------------------------------------

    #[test]
    fn inspector_short_labels_are_single_char() {
        let tabs = [
            InspectorTab::Timing,
            InspectorTab::Layout,
            InspectorTab::HitRegions,
            InspectorTab::Resize,
            InspectorTab::Diff,
            InspectorTab::Budget,
            InspectorTab::Timeline,
        ];
        for tab in &tabs {
            assert_eq!(tab.short_label().len(), 1, "{:?}", tab);
        }
    }

    #[test]
    fn inspector_short_labels_are_unique() {
        let labels: Vec<&str> = [
            InspectorTab::Timing,
            InspectorTab::Layout,
            InspectorTab::HitRegions,
            InspectorTab::Resize,
            InspectorTab::Diff,
            InspectorTab::Budget,
            InspectorTab::Timeline,
        ]
        .iter()
        .map(|t| t.short_label())
        .collect();
        let unique: HashSet<&str> = labels.iter().copied().collect();
        assert_eq!(labels.len(), unique.len());
    }

    #[test]
    fn inspector_render_narrow_does_not_panic() {
        use crate::ui::style_system::StyleOptions;
        let mut app = CassApp::default();
        app.show_inspector = true;
        let styles = StyleContext::from_options(StyleOptions::default());
        let mut pool = ftui::GraphemePool::new();
        // Narrow terminal: 60w × 25h → overlay_w=42
        let mut frame = ftui::Frame::new(60, 25, &mut pool);
        let area = Rect::new(0, 0, 60, 25);
        app.render_inspector_overlay(&mut frame, area, &styles);
    }

    #[test]
    fn inspector_render_medium_does_not_panic() {
        use crate::ui::style_system::StyleOptions;
        let mut app = CassApp::default();
        app.show_inspector = true;
        let styles = StyleContext::from_options(StyleOptions::default());
        let mut pool = ftui::GraphemePool::new();
        // MediumNarrow terminal: 100w × 35h → overlay_w=56
        let mut frame = ftui::Frame::new(100, 35, &mut pool);
        let area = Rect::new(0, 0, 100, 35);
        app.render_inspector_overlay(&mut frame, area, &styles);
    }

    #[test]
    fn inspector_render_short_height_does_not_panic() {
        use crate::ui::style_system::StyleOptions;
        let mut app = CassApp::default();
        app.show_inspector = true;
        let styles = StyleContext::from_options(StyleOptions::default());
        let mut pool = ftui::GraphemePool::new();
        // Short terminal: 120w × 15h → overlay_h=10
        let mut frame = ftui::Frame::new(120, 15, &mut pool);
        let area = Rect::new(0, 0, 120, 15);
        app.render_inspector_overlay(&mut frame, area, &styles);
    }

    #[test]
    fn inspector_auto_disables_tiny_terminal() {
        use crate::ui::style_system::StyleOptions;
        let mut app = CassApp::default();
        app.show_inspector = true;
        let styles = StyleContext::from_options(StyleOptions::default());
        let mut pool = ftui::GraphemePool::new();
        // Tiny: 18w × 4h → overlay_w < 20, should auto-disable
        let mut frame = ftui::Frame::new(18, 4, &mut pool);
        let area = Rect::new(0, 0, 18, 4);
        app.render_inspector_overlay(&mut frame, area, &styles);
        // No panic = success (overlay is silently skipped)
    }

    // -----------------------------------------------------------------------
    // Cockpit regression tests (1mfw3.3.4)
    // -----------------------------------------------------------------------

    /// Helper: builds an app with all evidence populated for regression testing.
    fn app_with_full_evidence() -> CassApp {
        use ftui::render::budget::{BudgetDecision, DegradationLevel};
        let mut app = CassApp::default();
        app.show_inspector = true;

        // Budget evidence
        app.evidence.budget = Some(ftui::runtime::evidence_telemetry::BudgetDecisionSnapshot {
            frame_idx: 100,
            decision: BudgetDecision::Hold,
            controller_decision: BudgetDecision::Hold,
            degradation_before: DegradationLevel::Full,
            degradation_after: DegradationLevel::Full,
            frame_time_us: 14000.0,
            budget_us: 16000.0,
            pid_output: 0.05,
            e_value: 1.5,
            frames_observed: 200,
            frames_since_change: 50,
            in_warmup: false,
            conformal: None,
        });

        // Diff evidence
        app.evidence.diff = Some(ftui::runtime::evidence_telemetry::DiffDecisionSnapshot {
            event_idx: 5,
            screen_mode: "Fullscreen".to_string(),
            cols: 120,
            rows: 40,
            evidence: ftui::render::diff_strategy::StrategyEvidence {
                strategy: ftui::render::diff_strategy::DiffStrategy::DirtyRows,
                cost_full: 500.0,
                cost_dirty: 150.0,
                cost_redraw: 800.0,
                posterior_mean: 0.2,
                posterior_variance: 0.01,
                alpha: 4.0,
                beta: 16.0,
                dirty_rows: 5,
                total_rows: 40,
                total_cells: 4800,
                guard_reason: "",
                hysteresis_applied: false,
                hysteresis_ratio: 0.0,
            },
            span_count: 3,
            span_coverage_pct: 0.6,
            max_span_len: 40,
            scan_cost_estimate: 200,
            fallback_reason: String::new(),
            tile_used: true,
            tile_fallback: String::new(),
            strategy_used: ftui::render::diff_strategy::DiffStrategy::DirtyRows,
        });

        // Resize evidence
        let resize = Some(make_resize_snapshot(
            1,
            ftui::runtime::resize_coalescer::Regime::Steady,
        ));
        let budget_ref = app.evidence.budget.clone();
        app.evidence.summary.update_from_raw(&resize, &budget_ref);
        app.evidence.resize = resize;

        // Feed timeline
        app.evidence.timeline.update_from_snapshots(
            &app.evidence.resize,
            &app.evidence.diff,
            &app.evidence.budget,
        );

        app
    }

    /// Dimensions matrix: (width, height, description)
    const REGRESSION_SIZES: &[(u16, u16, &str)] = &[
        (40, 12, "narrow-short"),
        (60, 25, "narrow-normal"),
        (80, 30, "medium_narrow"),
        (100, 35, "medium_narrow-tall"),
        (120, 40, "medium"),
        (160, 50, "wide"),
        (200, 60, "ultra_wide"),
        (40, 8, "narrow-tiny_height"),
        (120, 12, "medium-short"),
    ];

    #[test]
    fn cockpit_all_tabs_no_panic_no_evidence() {
        use crate::ui::style_system::StyleOptions;
        let styles = StyleContext::from_options(StyleOptions::default());
        let all_tabs = [
            InspectorTab::Timing,
            InspectorTab::Layout,
            InspectorTab::HitRegions,
            InspectorTab::Resize,
            InspectorTab::Diff,
            InspectorTab::Budget,
            InspectorTab::Timeline,
        ];
        for &(w, h, desc) in REGRESSION_SIZES {
            for tab in &all_tabs {
                let mut app = CassApp::default();
                app.show_inspector = true;
                app.inspector_tab = *tab;
                let mut pool = ftui::GraphemePool::new();
                let mut frame = ftui::Frame::new(w, h, &mut pool);
                let area = Rect::new(0, 0, w, h);
                app.render_inspector_overlay(&mut frame, area, &styles);
                // No panic = pass. Tag for diagnosis:
                let _ = (desc, tab.label());
            }
        }
    }

    #[test]
    fn cockpit_all_tabs_no_panic_with_evidence() {
        use crate::ui::style_system::StyleOptions;
        let styles = StyleContext::from_options(StyleOptions::default());
        let all_tabs = [
            InspectorTab::Timing,
            InspectorTab::Layout,
            InspectorTab::HitRegions,
            InspectorTab::Resize,
            InspectorTab::Diff,
            InspectorTab::Budget,
            InspectorTab::Timeline,
        ];
        for &(w, h, desc) in REGRESSION_SIZES {
            for tab in &all_tabs {
                let mut app = app_with_full_evidence();
                app.inspector_tab = *tab;
                let mut pool = ftui::GraphemePool::new();
                let mut frame = ftui::Frame::new(w, h, &mut pool);
                let area = Rect::new(0, 0, w, h);
                app.render_inspector_overlay(&mut frame, area, &styles);
                let _ = (desc, tab.label());
            }
        }
    }

    #[test]
    fn cockpit_all_tabs_no_panic_cockpit_mode() {
        use crate::ui::style_system::StyleOptions;
        let styles = StyleContext::from_options(StyleOptions::default());
        let all_tabs = [
            InspectorTab::Timing,
            InspectorTab::Layout,
            InspectorTab::HitRegions,
            InspectorTab::Resize,
            InspectorTab::Diff,
            InspectorTab::Budget,
            InspectorTab::Timeline,
        ];
        for &(w, h, _desc) in REGRESSION_SIZES {
            for tab in &all_tabs {
                let mut app = app_with_full_evidence();
                app.inspector_tab = *tab;
                app.cockpit.enabled = true;
                let mut pool = ftui::GraphemePool::new();
                let mut frame = ftui::Frame::new(w, h, &mut pool);
                let area = Rect::new(0, 0, w, h);
                app.render_inspector_overlay(&mut frame, area, &styles);
            }
        }
    }

    #[test]
    fn cockpit_degradation_levels_no_panic() {
        use crate::ui::style_system::StyleOptions;
        use ftui::render::budget::{BudgetDecision, DegradationLevel};
        let styles = StyleContext::from_options(StyleOptions::default());
        let levels = [
            (DegradationLevel::Full, DegradationLevel::Full),
            (DegradationLevel::Full, DegradationLevel::SimpleBorders),
            (DegradationLevel::SimpleBorders, DegradationLevel::NoStyling),
            (DegradationLevel::SimpleBorders, DegradationLevel::NoStyling),
            (DegradationLevel::EssentialOnly, DegradationLevel::Skeleton),
        ];
        for (before, after) in &levels {
            let mut app = app_with_full_evidence();
            app.inspector_tab = InspectorTab::Budget;
            let b = app.evidence.budget.as_mut().unwrap();
            b.degradation_before = *before;
            b.degradation_after = *after;
            b.decision = BudgetDecision::Degrade;
            let mut pool = ftui::GraphemePool::new();
            let mut frame = ftui::Frame::new(120, 40, &mut pool);
            let area = Rect::new(0, 0, 120, 40);
            app.render_inspector_overlay(&mut frame, area, &styles);
        }
    }

    #[test]
    fn cockpit_partial_evidence_diff_only() {
        use crate::ui::style_system::StyleOptions;
        let styles = StyleContext::from_options(StyleOptions::default());
        let mut app = CassApp::default();
        app.show_inspector = true;
        app.inspector_tab = InspectorTab::Diff;
        app.evidence.diff = Some(ftui::runtime::evidence_telemetry::DiffDecisionSnapshot {
            event_idx: 1,
            screen_mode: "Fullscreen".to_string(),
            cols: 80,
            rows: 24,
            evidence: ftui::render::diff_strategy::StrategyEvidence {
                strategy: ftui::render::diff_strategy::DiffStrategy::DirtyRows,
                cost_full: 500.0,
                cost_dirty: 150.0,
                cost_redraw: 800.0,
                posterior_mean: 0.15,
                posterior_variance: 0.01,
                alpha: 3.0,
                beta: 17.0,
                dirty_rows: 6,
                total_rows: 24,
                total_cells: 1920,
                guard_reason: "",
                hysteresis_applied: false,
                hysteresis_ratio: 0.0,
            },
            span_count: 2,
            span_coverage_pct: 0.5,
            max_span_len: 30,
            scan_cost_estimate: 100,
            fallback_reason: String::new(),
            tile_used: false,
            tile_fallback: String::new(),
            strategy_used: ftui::render::diff_strategy::DiffStrategy::DirtyRows,
        });
        // No budget or resize evidence — only diff
        let mut pool = ftui::GraphemePool::new();
        let mut frame = ftui::Frame::new(120, 40, &mut pool);
        let area = Rect::new(0, 0, 120, 40);
        app.render_inspector_overlay(&mut frame, area, &styles);
        // Switch to Budget tab (no evidence) — should still render gracefully
        app.inspector_tab = InspectorTab::Budget;
        let mut pool2 = ftui::GraphemePool::new();
        let mut frame2 = ftui::Frame::new(120, 40, &mut pool2);
        app.render_inspector_overlay(&mut frame2, area, &styles);
    }

    #[test]
    fn cockpit_partial_evidence_budget_only() {
        use crate::ui::style_system::StyleOptions;
        use ftui::render::budget::{BudgetDecision, DegradationLevel};
        let styles = StyleContext::from_options(StyleOptions::default());
        let mut app = CassApp::default();
        app.show_inspector = true;
        app.inspector_tab = InspectorTab::Budget;
        app.evidence.budget = Some(ftui::runtime::evidence_telemetry::BudgetDecisionSnapshot {
            frame_idx: 10,
            decision: BudgetDecision::Hold,
            controller_decision: BudgetDecision::Hold,
            degradation_before: DegradationLevel::Full,
            degradation_after: DegradationLevel::Full,
            frame_time_us: 10000.0,
            budget_us: 16000.0,
            pid_output: 0.0,
            e_value: 0.5,
            frames_observed: 10,
            frames_since_change: 5,
            in_warmup: true,
            conformal: None,
        });
        let mut pool = ftui::GraphemePool::new();
        let mut frame = ftui::Frame::new(120, 40, &mut pool);
        let area = Rect::new(0, 0, 120, 40);
        app.render_inspector_overlay(&mut frame, area, &styles);
        // Switch to Diff tab (no evidence)
        app.inspector_tab = InspectorTab::Diff;
        let mut pool2 = ftui::GraphemePool::new();
        let mut frame2 = ftui::Frame::new(120, 40, &mut pool2);
        app.render_inspector_overlay(&mut frame2, area, &styles);
    }

    #[test]
    fn cockpit_tab_cycling_preserves_render() {
        use crate::ui::style_system::StyleOptions;
        let styles = StyleContext::from_options(StyleOptions::default());
        let mut app = app_with_full_evidence();
        // Cycle through all 7 tabs and render at each step
        for _ in 0..7 {
            let mut pool = ftui::GraphemePool::new();
            let mut frame = ftui::Frame::new(120, 40, &mut pool);
            let area = Rect::new(0, 0, 120, 40);
            app.render_inspector_overlay(&mut frame, area, &styles);
            let _ = app.update(CassMsg::InspectorTabCycled);
        }
        // Should be back to Timing
        assert_eq!(app.inspector_tab, InspectorTab::Timing);
    }

    #[test]
    fn cockpit_conformal_edge_cases() {
        use crate::ui::style_system::StyleOptions;
        use ftui::render::budget::{BudgetDecision, DegradationLevel};
        let styles = StyleContext::from_options(StyleOptions::default());
        // Test with conformal prediction data
        let mut app = app_with_full_evidence();
        app.inspector_tab = InspectorTab::Budget;
        let b = app.evidence.budget.as_mut().unwrap();
        b.conformal = Some(ftui::runtime::evidence_telemetry::ConformalSnapshot {
            bucket_key: "alt:Full:medium".to_string(),
            sample_count: 50,
            upper_us: 25000.0,
            risk: true,
        });
        b.e_value = 25.0;
        b.decision = BudgetDecision::Degrade;
        b.degradation_before = DegradationLevel::Full;
        b.degradation_after = DegradationLevel::SimpleBorders;
        let mut pool = ftui::GraphemePool::new();
        let mut frame = ftui::Frame::new(120, 40, &mut pool);
        let area = Rect::new(0, 0, 120, 40);
        app.render_inspector_overlay(&mut frame, area, &styles);
    }

    #[test]
    fn cockpit_extreme_values_no_panic() {
        use crate::ui::style_system::StyleOptions;
        let styles = StyleContext::from_options(StyleOptions::default());
        let mut app = app_with_full_evidence();
        app.inspector_tab = InspectorTab::Budget;
        let b = app.evidence.budget.as_mut().unwrap();
        b.frame_time_us = f64::MAX;
        b.budget_us = f64::MIN_POSITIVE;
        b.pid_output = -999.0;
        b.e_value = f64::INFINITY;
        b.frames_observed = u32::MAX;
        b.frames_since_change = u32::MAX;
        let mut pool = ftui::GraphemePool::new();
        let mut frame = ftui::Frame::new(120, 40, &mut pool);
        let area = Rect::new(0, 0, 120, 40);
        app.render_inspector_overlay(&mut frame, area, &styles);
    }

    // -----------------------------------------------------------------------
    // Cockpit mode tests (1mfw3.3.2)
    // -----------------------------------------------------------------------

    #[test]
    fn cockpit_disabled_by_default() {
        let app = CassApp::default();
        assert!(!app.cockpit.enabled);
        assert_eq!(app.inspector_tab, InspectorTab::Timing);
    }

    #[test]
    fn cockpit_toggle_switches_to_diff_tab() {
        let mut app = CassApp::default();
        app.show_inspector = true;
        let _ = app.update(CassMsg::CockpitModeToggled);
        assert!(app.cockpit.enabled);
        assert_eq!(app.inspector_tab, InspectorTab::Diff);
    }

    #[test]
    fn cockpit_toggle_off_returns_to_timing() {
        let mut app = CassApp::default();
        app.show_inspector = true;
        let _ = app.update(CassMsg::CockpitModeToggled);
        assert!(app.cockpit.enabled);
        let _ = app.update(CassMsg::CockpitModeToggled);
        assert!(!app.cockpit.enabled);
        assert_eq!(app.inspector_tab, InspectorTab::Timing);
    }

    #[test]
    fn cockpit_c_key_toggles_when_inspector_visible() {
        let mut app = CassApp::default();
        app.show_inspector = true;
        // Simulate 'c' keypress (which generates QueryChanged("c"))
        let _ = app.update(CassMsg::QueryChanged("c".to_string()));
        assert!(app.cockpit.enabled);
        assert_eq!(app.inspector_tab, InspectorTab::Diff);
    }

    #[test]
    fn cockpit_m_key_cycles_mode_when_inspector_visible() {
        let mut app = CassApp::default();
        app.show_inspector = true;
        let before = format!("{:?}", app.inspector_state);
        let _ = app.update(CassMsg::QueryChanged("m".to_string()));
        // inspector_state should have changed (mode cycled)
        assert_ne!(before, format!("{:?}", app.inspector_state));
    }

    #[test]
    fn cockpit_tab_cycles_tabs_when_inspector_visible() {
        let mut app = CassApp::default();
        app.show_inspector = true;
        assert_eq!(app.inspector_tab, InspectorTab::Timing);
        // Tab key maps to FocusToggled; inspector intercepts it for tab cycling
        let _ = app.update(CassMsg::FocusToggled);
        assert_eq!(app.inspector_tab, InspectorTab::Layout);
    }

    #[test]
    fn cockpit_state_starts_empty() {
        let app = CassApp::default();
        assert!(!app.cockpit.has_any_data());
    }

    #[test]
    fn cockpit_sync_populates_budget_contract() {
        let mut app = CassApp::default();
        // Manually set evidence summary to simulate telemetry data
        app.evidence.summary.frames_observed = 42;
        app.evidence.summary.budget_us = 16666.0;
        app.evidence.summary.frame_time_us = 12000.0;
        app.evidence.sync_cockpit(&mut app.cockpit);
        assert!(app.cockpit.budget.has_data());
        assert_eq!(app.cockpit.budget.frames_observed, 42);
        assert!(!app.cockpit.budget.is_over_budget());
    }

    #[test]
    fn cockpit_sync_without_evidence_uses_defaults() {
        let mut app = CassApp::default();
        app.evidence.sync_cockpit(&mut app.cockpit);
        // No raw evidence → resize regime is em dash (no data)
        assert!(!app.cockpit.resize.has_data());
        // No frames observed → budget has no data
        assert!(!app.cockpit.budget.has_data());
    }

    // -----------------------------------------------------------------------
    // Deterministic resize storm tests (1mfw3.2.6)
    // -----------------------------------------------------------------------

    #[test]
    fn cockpit_topology_narrow_overlay_compact() {
        use crate::ui::data::CockpitMode;
        let t = LayoutBreakpoint::Narrow.cockpit_topology(CockpitMode::Overlay);
        assert!(t.use_short_labels);
        assert!(!t.show_mode_indicator);
        assert!(!t.show_footer_hint);
        assert_eq!(t.overlay_max_w, 42);
        assert_eq!(t.overlay_max_h, 10);
        assert_eq!(t.max_timeline_events, 3);
    }

    #[test]
    fn cockpit_topology_expanded_grows() {
        use crate::ui::data::CockpitMode;
        let ov = LayoutBreakpoint::Narrow.cockpit_topology(CockpitMode::Overlay);
        let ex = LayoutBreakpoint::Narrow.cockpit_topology(CockpitMode::Expanded);
        assert!(ex.overlay_max_h > ov.overlay_max_h);
        assert!(ex.max_timeline_events > ov.max_timeline_events);
    }

    #[test]
    fn cockpit_topology_wide_expanded_largest() {
        use crate::ui::data::CockpitMode;
        let t = LayoutBreakpoint::Wide.cockpit_topology(CockpitMode::Expanded);
        assert_eq!(t.overlay_max_w, 72);
        assert_eq!(t.overlay_max_h, 30);
        assert_eq!(t.max_timeline_events, 18);
    }

    #[test]
    fn cockpit_topology_minimums_consistent() {
        use crate::ui::data::CockpitMode;
        for bp in [
            LayoutBreakpoint::Narrow,
            LayoutBreakpoint::MediumNarrow,
            LayoutBreakpoint::Medium,
            LayoutBreakpoint::Wide,
        ] {
            for mode in [CockpitMode::Overlay, CockpitMode::Expanded] {
                let t = bp.cockpit_topology(mode);
                assert_eq!(t.overlay_min_w, 20);
                assert_eq!(t.overlay_min_h, 6);
                assert!(t.overlay_max_w >= t.overlay_min_w);
                assert!(t.overlay_max_h >= t.overlay_min_h);
            }
        }
    }

    #[test]
    fn cockpit_expand_toggle_msg() {
        use crate::ui::data::CockpitMode;
        let mut app = CassApp::default();
        app.show_inspector = true;
        app.cockpit.enabled = true;
        assert_eq!(app.cockpit.mode, CockpitMode::Overlay);
        let _ = app.update(CassMsg::CockpitExpandToggled);
        assert_eq!(app.cockpit.mode, CockpitMode::Expanded);
        let _ = app.update(CassMsg::CockpitExpandToggled);
        assert_eq!(app.cockpit.mode, CockpitMode::Overlay);
    }

    #[test]
    fn cockpit_e_key_expands() {
        use crate::ui::data::CockpitMode;
        let mut app = CassApp::default();
        app.show_inspector = true;
        app.cockpit.enabled = true;
        let _ = app.update(CassMsg::QueryChanged("e".to_string()));
        assert_eq!(app.cockpit.mode, CockpitMode::Expanded);
    }

    #[test]
    fn cockpit_expand_preserves_tab() {
        use crate::ui::data::CockpitMode;
        let mut app = CassApp::default();
        app.show_inspector = true;
        app.cockpit.enabled = true;
        app.inspector_tab = InspectorTab::Budget;
        let _ = app.update(CassMsg::CockpitExpandToggled);
        assert_eq!(app.cockpit.mode, CockpitMode::Expanded);
        assert_eq!(app.inspector_tab, InspectorTab::Budget);
    }

    // -----------------------------------------------------------------------
    // Deterministic resize storm tests (1mfw3.2.6)
    // -----------------------------------------------------------------------

    fn storm_coalescer_config() -> ftui::runtime::resize_coalescer::CoalescerConfig {
        ftui::runtime::resize_coalescer::CoalescerConfig {
            steady_delay_ms: 16,
            burst_delay_ms: 40,
            hard_deadline_ms: 100,
            burst_enter_rate: 10.0,
            burst_exit_rate: 5.0,
            cooldown_frames: 3,
            rate_window_size: 8,
            enable_logging: true,
            enable_bocpd: false,
            bocpd_config: None,
        }
    }

    #[test]
    fn resize_storm_steady_single_event() {
        use ftui::runtime::resize_coalescer::{CoalesceAction, ResizeCoalescer};
        let config = storm_coalescer_config();
        let mut c = ResizeCoalescer::new(config, (80, 24));
        let base = Instant::now();

        // Single resize event — should show placeholder immediately
        let action = c.handle_resize_at(100, 40, base);
        assert!(
            matches!(action, CoalesceAction::ShowPlaceholder),
            "first resize should show placeholder"
        );

        // After steady_delay_ms, tick should apply
        let apply_time = base + Duration::from_millis(20);
        let action = c.tick_at(apply_time);
        assert!(
            matches!(
                action,
                CoalesceAction::ApplyResize {
                    width: 100,
                    height: 40,
                    ..
                }
            ),
            "expected ApplyResize(100, 40), got {action:?}"
        );
        assert_eq!(c.last_applied(), (100, 40));
    }

    #[test]
    fn resize_storm_burst_latest_wins() {
        use ftui::runtime::resize_coalescer::{CoalesceAction, Regime, ResizeCoalescer};
        let config = storm_coalescer_config();
        let mut c = ResizeCoalescer::new(config, (80, 24));
        let base = Instant::now();

        // Rapid-fire 15 resizes at 10ms spacing — should trigger burst
        for i in 0..15u64 {
            let w = 80 + (i as u16);
            let h = 24 + (i as u16);
            let t = base + Duration::from_millis(i * 10);
            let _ = c.handle_resize_at(w, h, t);
        }
        // Should be in burst regime
        assert_eq!(
            c.regime(),
            Regime::Burst,
            "expected Burst after rapid events"
        );

        // Tick well past hard_deadline to force apply
        let late = base + Duration::from_millis(250);
        let action = c.tick_at(late);
        if let CoalesceAction::ApplyResize { width, height, .. } = action {
            // Latest size should be (94, 38) — last event: 80+14=94, 24+14=38
            assert_eq!(
                (width, height),
                (94, 38),
                "latest-wins: expected final size"
            );
        }
        assert_eq!(c.last_applied(), (94, 38));
    }

    #[test]
    fn resize_storm_oscillating_pattern() {
        use ftui::runtime::resize_coalescer::ResizeCoalescer;
        let config = storm_coalescer_config();
        let mut c = ResizeCoalescer::new(config, (80, 24));
        let base = Instant::now();

        // Alternate between two sizes at varying rates
        // Fast oscillation → burst, then slow down
        let pattern: Vec<(u16, u16, u64)> = vec![
            (100, 40, 10),
            (80, 24, 10),
            (100, 40, 10),
            (80, 24, 10),
            (100, 40, 10),
            (80, 24, 10),
            (100, 40, 10),
            (80, 24, 10),
        ];

        let mut elapsed_ms = 0u64;
        for (w, h, delay_ms) in &pattern {
            elapsed_ms += delay_ms;
            let t = base + Duration::from_millis(elapsed_ms);
            let _ = c.handle_resize_at(*w, *h, t);
            let _ = c.tick_at(t + Duration::from_millis(1));
        }

        // After oscillation, verify coalescer didn't panic and has pending/applied state.
        // The regime may still be Burst after rapid events — what matters is stability.
        let transitions_before = c.regime_transition_count();
        // No further events — just tick forward to let it settle
        for i in 0..20u64 {
            let t = base + Duration::from_millis(elapsed_ms + 100 + i * 50);
            let _ = c.tick_at(t);
        }
        // Verify no crash and that the coalescer is still functional
        let _ = c.regime();
        let _ = c.last_applied();
        assert!(c.regime_transition_count() >= transitions_before);
    }

    #[test]
    fn resize_storm_hard_deadline_bounded_latency() {
        use ftui::runtime::resize_coalescer::ResizeCoalescer;
        let config = storm_coalescer_config();
        let mut c = ResizeCoalescer::new(config, (80, 24));
        let base = Instant::now();

        // Continuous stream of events at 5ms intervals with ticks between
        for i in 0..50u64 {
            let t = base + Duration::from_millis(i * 5);
            let _ = c.handle_resize_at(80 + (i % 3) as u16, 24, t);
            // Tick after each event to let coalescer process
            let _ = c.tick_at(t + Duration::from_millis(1));
        }

        // Tick well after all events to flush pending
        let late = base + Duration::from_millis(500);
        let _ = c.tick_at(late);

        // Check logs for any applies (forced or normal)
        let logs = c.logs();
        assert!(!logs.is_empty(), "should have decision logs");

        let has_apply = logs
            .iter()
            .any(|l| matches!(l.action, "apply" | "apply_forced" | "apply_immediate"));
        assert!(
            has_apply,
            "hard deadline should have forced at least one apply"
        );
    }

    #[test]
    fn resize_storm_same_size_skipped() {
        use ftui::runtime::resize_coalescer::{CoalesceAction, ResizeCoalescer};
        let config = storm_coalescer_config();
        let mut c = ResizeCoalescer::new(config, (80, 24));
        let base = Instant::now();

        // Resize to same size as current — should return None
        let action = c.handle_resize_at(80, 24, base);
        assert!(
            matches!(action, CoalesceAction::None),
            "same-size resize should be skipped: {action:?}"
        );
    }

    #[test]
    fn resize_storm_evidence_summary_accumulates() {
        use ftui::runtime::resize_coalescer::Regime;
        let mut summary = ResizeEvidenceSummary::default();

        // Simulate a storm of 50 resize events
        for i in 1..=50u64 {
            let regime = if i < 20 {
                Regime::Steady
            } else {
                Regime::Burst
            };
            let snap = Some(make_resize_snapshot(i, regime));
            summary.update_from_raw(&snap, &None);
        }

        // Ring buffer should be capped at RESIZE_HISTORY_CAPACITY
        assert_eq!(summary.history_len(), RESIZE_HISTORY_CAPACITY);
        // Oldest should have been evicted
        assert_eq!(
            summary.recent_resizes.front().unwrap().event_idx,
            50 - RESIZE_HISTORY_CAPACITY as u64 + 1
        );
        // Latest should have Burst regime
        assert_eq!(summary.regime, "Burst");
        assert_eq!(summary.recent_resizes.back().unwrap().regime, "Burst");
    }

    #[test]
    fn resize_storm_checksum_deterministic() {
        use ftui::runtime::resize_coalescer::ResizeCoalescer;
        let config = storm_coalescer_config();
        let base = Instant::now();

        let pattern: Vec<(u16, u16, u64)> = vec![
            (100, 40, 10),
            (120, 50, 10),
            (80, 24, 10),
            (100, 40, 200),
            (150, 60, 200),
        ];

        // Two coalescer runs with identical events from the same base Instant
        let run = |c: &mut ResizeCoalescer| {
            let mut elapsed_ms = 0u64;
            for (w, h, delay_ms) in &pattern {
                elapsed_ms += delay_ms;
                let t = base + Duration::from_millis(elapsed_ms);
                let _ = c.handle_resize_at(*w, *h, t);
                let _ = c.tick_at(t + Duration::from_millis(1));
            }
            let final_tick = base + Duration::from_millis(elapsed_ms + 200);
            let _ = c.tick_at(final_tick);
        };

        let mut c1 = ResizeCoalescer::new(config.clone(), (80, 24)).with_last_render(base);
        let mut c2 = ResizeCoalescer::new(config, (80, 24)).with_last_render(base);
        run(&mut c1);
        run(&mut c2);

        assert_eq!(
            c1.decision_checksum(),
            c2.decision_checksum(),
            "identical event streams should produce identical checksums"
        );
    }

    #[test]
    fn resize_storm_regime_transitions_counted() {
        use ftui::runtime::resize_coalescer::ResizeCoalescer;
        let config = storm_coalescer_config();
        let mut c = ResizeCoalescer::new(config, (80, 24));
        let base = Instant::now();

        assert_eq!(c.regime_transition_count(), 0);

        // Rapid burst to trigger Steady -> Burst
        for i in 0..15u64 {
            let t = base + Duration::from_millis(i * 8);
            let _ = c.handle_resize_at(80 + (i as u16), 24, t);
        }
        // Tick to process
        let _ = c.tick_at(base + Duration::from_millis(200));

        let transitions = c.regime_transition_count();
        assert!(
            transitions >= 1,
            "expected at least 1 regime transition, got {transitions}"
        );
    }

    #[test]
    fn resize_storm_evidence_integrity_no_gaps() {
        let mut summary = ResizeEvidenceSummary::default();

        // Feed events 1..=RESIZE_HISTORY_CAPACITY and verify no gaps
        for i in 1..=RESIZE_HISTORY_CAPACITY as u64 {
            let snap = Some(make_resize_snapshot(
                i,
                ftui::runtime::resize_coalescer::Regime::Steady,
            ));
            summary.update_from_raw(&snap, &None);
        }

        // Verify contiguous event_idx sequence
        let indices: Vec<u64> = summary.recent_resizes.iter().map(|e| e.event_idx).collect();
        for pair in indices.windows(2) {
            assert_eq!(
                pair[1],
                pair[0] + 1,
                "event_idx should be contiguous: {} -> {}",
                pair[0],
                pair[1]
            );
        }
    }

    // -----------------------------------------------------------------------
    // Resize config parity matrix (1mfw3.2.7)
    // -----------------------------------------------------------------------
    //
    // Proves that build_resize_config() produces identical configuration
    // regardless of which launch mode the TUI enters (standard, inline,
    // macro-record, macro-playback). The ProgramConfig construction in
    // run_tui_ftui() applies the result uniformly; these tests verify
    // the config builder itself.

    #[test]
    fn resize_config_parity_across_data_dirs() {
        // The config builder must produce identical BOCPD/logging settings
        // regardless of which data_dir is used (only the evidence file path
        // differs).
        let dir_a = std::path::PathBuf::from("/tmp/cass-a");
        let dir_b = std::path::PathBuf::from("/tmp/cass-b");

        let (coal_a, sink_a) = super::build_resize_config(&dir_a);
        let (coal_b, sink_b) = super::build_resize_config(&dir_b);

        // Coalescer knobs are identical
        assert_eq!(coal_a.enable_bocpd, coal_b.enable_bocpd);
        assert_eq!(coal_a.enable_logging, coal_b.enable_logging);
        assert_eq!(coal_a.steady_delay_ms, coal_b.steady_delay_ms);
        assert_eq!(coal_a.burst_delay_ms, coal_b.burst_delay_ms);
        assert_eq!(coal_a.hard_deadline_ms, coal_b.hard_deadline_ms);

        // Evidence sink enabled state matches
        assert_eq!(sink_a.enabled, sink_b.enabled);
        assert_eq!(sink_a.flush_on_write, sink_b.flush_on_write);

        // Evidence paths differ only by data_dir prefix
        assert!(
            matches!(
                (&sink_a.destination, &sink_b.destination),
                (
                    ftui::runtime::evidence_sink::EvidenceSinkDestination::File(_),
                    ftui::runtime::evidence_sink::EvidenceSinkDestination::File(_)
                )
            ),
            "expected file destinations"
        );
        if let (
            ftui::runtime::evidence_sink::EvidenceSinkDestination::File(pa),
            ftui::runtime::evidence_sink::EvidenceSinkDestination::File(pb),
        ) = (&sink_a.destination, &sink_b.destination)
        {
            assert_ne!(pa, pb, "paths should differ across data dirs");
            assert!(
                pa.ends_with("resize_evidence.jsonl"),
                "evidence file name must be consistent"
            );
            assert!(pb.ends_with("resize_evidence.jsonl"));
        }
    }

    #[test]
    fn resize_config_bocpd_is_enabled_by_default() {
        let data_dir = std::path::PathBuf::from("/tmp/cass-parity");
        let (coalescer, evidence_sink) = super::build_resize_config(&data_dir);

        // BOCPD should be on by default
        assert!(coalescer.enable_bocpd, "BOCPD must be enabled by default");
        assert!(coalescer.enable_logging, "logging must be enabled");
        assert!(
            coalescer.bocpd_config.is_some(),
            "bocpd_config must be present"
        );

        // Evidence sink should be active
        assert!(evidence_sink.enabled, "evidence sink must be enabled");
        assert!(
            !evidence_sink.flush_on_write,
            "batch flush for lower I/O overhead"
        );
    }

    #[test]
    fn resize_config_bocpd_responsive_preset_values() {
        use ftui::runtime::bocpd::BocpdConfig;

        let data_dir = std::path::PathBuf::from("/tmp/cass-responsive");
        let (coalescer, _) = super::build_resize_config(&data_dir);

        let bocpd = coalescer.bocpd_config.expect("BOCPD config must exist");
        let reference = BocpdConfig::responsive();

        // Verify responsive preset is used (not default or aggressive)
        assert!(
            (bocpd.mu_steady_ms - reference.mu_steady_ms).abs() < f64::EPSILON,
            "mu_steady_ms must match responsive preset"
        );
        assert!(
            (bocpd.mu_burst_ms - reference.mu_burst_ms).abs() < f64::EPSILON,
            "mu_burst_ms must match responsive preset"
        );
        assert!(
            (bocpd.hazard_lambda - reference.hazard_lambda).abs() < f64::EPSILON,
            "hazard_lambda must match responsive preset"
        );
        assert!((bocpd.steady_threshold - reference.steady_threshold).abs() < f64::EPSILON,);
        assert!((bocpd.burst_threshold - reference.burst_threshold).abs() < f64::EPSILON,);

        // Logging must be enabled on the BOCPD config itself
        assert!(bocpd.enable_logging, "BOCPD evidence logging must be on");
    }

    #[test]
    fn resize_config_mode_matrix_proves_uniform_knobs() {
        // This is the definitive parity test: simulate all four launch mode
        // combinations and prove the resize config is byte-identical.
        //
        // Launch modes:
        //  1. Standard fullscreen (no inline, no macro)
        //  2. Inline mode (inline_config = Some)
        //  3. Macro recording (record_path = Some)
        //  4. Macro playback (play_path = Some)
        //
        // In run_tui_ftui(), build_resize_config() is called once BEFORE
        // the mode-specific ProgramConfig branching, guaranteeing that the
        // coalescer/evidence config is identical across all modes.

        let data_dir = std::path::PathBuf::from("/tmp/cass-matrix");

        // Call build_resize_config N times — must always return same values.
        let configs: Vec<_> = (0..4)
            .map(|_| super::build_resize_config(&data_dir))
            .collect();

        for (i, (coal, sink)) in configs.iter().enumerate() {
            let (ref_coal, ref_sink) = &configs[0];

            // Coalescer knobs
            assert_eq!(
                coal.enable_bocpd, ref_coal.enable_bocpd,
                "mode {i}: BOCPD enable mismatch"
            );
            assert_eq!(
                coal.enable_logging, ref_coal.enable_logging,
                "mode {i}: logging mismatch"
            );
            assert_eq!(
                coal.steady_delay_ms, ref_coal.steady_delay_ms,
                "mode {i}: steady_delay mismatch"
            );
            assert_eq!(
                coal.burst_delay_ms, ref_coal.burst_delay_ms,
                "mode {i}: burst_delay mismatch"
            );
            assert_eq!(
                coal.hard_deadline_ms, ref_coal.hard_deadline_ms,
                "mode {i}: hard_deadline mismatch"
            );
            assert_eq!(
                coal.cooldown_frames, ref_coal.cooldown_frames,
                "mode {i}: cooldown mismatch"
            );
            assert_eq!(
                coal.rate_window_size, ref_coal.rate_window_size,
                "mode {i}: rate_window mismatch"
            );

            // Evidence sink
            assert_eq!(
                sink.enabled, ref_sink.enabled,
                "mode {i}: evidence enabled mismatch"
            );
            assert_eq!(
                sink.flush_on_write, ref_sink.flush_on_write,
                "mode {i}: flush_on_write mismatch"
            );
        }
    }

    // ── Baseline snapshot tests (2dccg.6.2) ─────────────────────────────

    fn assert_affordance_snapshot(name: &str, buf: &ftui::Buffer) {
        ftui_harness::assert_buffer_snapshot(
            name,
            buf,
            env!("CARGO_MANIFEST_DIR"),
            ftui_harness::MatchMode::TrimTrailing,
        );
    }

    /// Shared fixture for detail-pane snapshot baselines.
    fn app_with_detail_snapshot_fixture() -> CassApp {
        let mut app = app_with_rich_visual_fixture();
        app.active_pane = 0;
        if let Some(first_pane) = app.panes.first_mut() {
            first_pane.selected = 0;
        }
        app.focus_manager.focus(focus_ids::DETAIL_PANE);
        app.cached_detail = Some((
            "/test/session.jsonl".to_string(),
            make_test_conversation_view(),
        ));
        app
    }

    /// Shared role-message fixture for snapshot lanes that validate gutter styles.
    fn role_gutter_snapshot_messages() -> Vec<Message> {
        vec![
            Message {
                id: Some(1),
                idx: 0,
                role: MessageRole::User,
                author: Some("operator".to_string()),
                created_at: Some(1_700_000_000),
                content: "User intent: improve visual hierarchy and readability.".to_string(),
                extra_json: serde_json::json!({}),
                snippets: vec![],
            },
            Message {
                id: Some(2),
                idx: 1,
                role: MessageRole::Agent,
                author: Some("cass".to_string()),
                created_at: Some(1_700_000_010),
                content: "Assistant response: proposing tab, find-bar, and pill refinements."
                    .to_string(),
                extra_json: serde_json::json!({}),
                snippets: vec![],
            },
            Message {
                id: Some(3),
                idx: 2,
                role: MessageRole::Tool,
                author: Some("ubs".to_string()),
                created_at: Some(1_700_000_020),
                content: "Tool output: scan completed with deterministic fixture checks."
                    .to_string(),
                extra_json: serde_json::json!({}),
                snippets: vec![],
            },
            Message {
                id: Some(4),
                idx: 3,
                role: MessageRole::System,
                author: Some("runtime".to_string()),
                created_at: Some(1_700_000_030),
                content: "System event: render budget remains stable at full quality.".to_string(),
                extra_json: serde_json::json!({}),
                snippets: vec![],
            },
        ]
    }

    /// Render detail pane in isolation so snapshots stay focused and diff-friendly.
    fn render_detail_snapshot_buffer(app: &CassApp, width: u16, height: u16) -> ftui::Buffer {
        let mut pool = ftui::GraphemePool::new();
        let mut frame = ftui::Frame::new(width, height, &mut pool);
        frame.set_degradation(ftui::render::budget::DegradationLevel::Full);

        let styles = app.resolved_style_context();
        app.render_detail_pane(
            &mut frame,
            Rect::new(0, 0, width, height),
            BorderType::Rounded,
            Borders::ALL,
            &styles,
            styles.style(style_system::STYLE_PANE_BASE),
            styles.style(style_system::STYLE_PANE_FOCUSED),
            styles.style(style_system::STYLE_PANE_TITLE_FOCUSED),
            styles.style(style_system::STYLE_PANE_TITLE_UNFOCUSED),
            styles.style(style_system::STYLE_TEXT_MUTED),
        );
        frame.buffer
    }

    /// Render only the pills rows (inactive + active) for minimal snapshot diffs.
    fn render_pill_matrix_snapshot_buffer(width: u16) -> ftui::Buffer {
        let inactive_app = app_with_rich_visual_fixture();
        let mut active_app = app_with_rich_visual_fixture();
        active_app.filters.agents.insert("codex".to_string());
        active_app
            .filters
            .workspaces
            .insert("/workspace/cass".to_string());
        active_app.filters.created_from = Some(1_700_000_000);
        active_app.filters.source_filter = SourceFilter::SourceId("remote-ci".to_string());
        active_app.pane_filter = Some("triage".to_string());

        let base_style = ftui::Style::default();
        let mut pool = ftui::GraphemePool::new();
        let mut frame = ftui::Frame::new(width, 4, &mut pool);
        let area = Rect::new(0, 0, width, 4);
        let rows = Flex::vertical()
            .constraints([
                Constraint::Fixed(1),
                Constraint::Fixed(1),
                Constraint::Fixed(1),
                Constraint::Fixed(1),
            ])
            .split(area);

        let (inactive_line, _) = inactive_app.build_pills_row(
            rows[1],
            &inactive_app.filter_pills(),
            base_style,
            base_style,
            base_style,
            base_style,
        );
        let (active_line, _) = active_app.build_pills_row(
            rows[3],
            &active_app.filter_pills(),
            base_style,
            base_style,
            base_style,
            base_style,
        );

        Paragraph::new(ftui::text::Text::from_lines(vec![ftui::text::Line::from(
            "inactive slots:",
        )]))
        .render(rows[0], &mut frame);
        Paragraph::new(ftui::text::Text::from_lines(vec![inactive_line]))
            .render(rows[1], &mut frame);
        Paragraph::new(ftui::text::Text::from_lines(vec![ftui::text::Line::from(
            "active filters:",
        )]))
        .render(rows[2], &mut frame);
        Paragraph::new(ftui::text::Text::from_lines(vec![active_line])).render(rows[3], &mut frame);

        frame.buffer
    }

    #[test]
    fn snapshot_baseline_pills_active_inactive_matrix() {
        let buf = render_pill_matrix_snapshot_buffer(110);
        let text = ftui_harness::buffer_to_text(&buf);
        assert!(
            text.contains("inactive slots:"),
            "snapshot should include inactive baseline heading"
        );
        assert!(
            text.contains("active filters:"),
            "snapshot should include active baseline heading"
        );
        assert_affordance_snapshot("cassapp_baseline_pills_active_inactive", &buf);
    }

    #[test]
    fn snapshot_baseline_detail_tabs_active_inactive() {
        let mut app = app_with_detail_snapshot_fixture();
        app.detail_tab = DetailTab::Messages;
        let messages_buf = render_detail_snapshot_buffer(&app, 88, 18);
        assert_affordance_snapshot(
            "cassapp_baseline_detail_tabs_messages_active",
            &messages_buf,
        );

        app.detail_tab = DetailTab::Snippets;
        let snippets_buf = render_detail_snapshot_buffer(&app, 88, 18);
        assert_affordance_snapshot(
            "cassapp_baseline_detail_tabs_snippets_active",
            &snippets_buf,
        );

        app.detail_tab = DetailTab::Raw;
        let raw_buf = render_detail_snapshot_buffer(&app, 88, 18);
        assert_affordance_snapshot("cassapp_baseline_detail_tabs_raw_active", &raw_buf);

        app.detail_tab = DetailTab::Json;
        let json_buf = render_detail_snapshot_buffer(&app, 88, 18);
        assert_affordance_snapshot("cassapp_baseline_detail_tabs_json_active", &json_buf);
    }

    #[test]
    fn snapshot_baseline_role_gutters_messages_all_roles() {
        let mut app = app_with_detail_snapshot_fixture();
        let mut cv = make_test_conversation_view();
        cv.messages = role_gutter_snapshot_messages();
        app.cached_detail = Some(("/test/session.jsonl".to_string(), cv));
        app.detail_tab = DetailTab::Messages;

        let buf = render_detail_snapshot_buffer(&app, 96, 30);
        let text = ftui_harness::buffer_to_text(&buf);
        assert!(text.contains("User"));
        assert!(text.contains("Agent"));
        assert!(text.contains("Tool"));
        assert!(text.contains("System"));
        assert_affordance_snapshot("cassapp_baseline_role_gutters_messages", &buf);
    }

    #[test]
    fn snapshot_baseline_detail_find_closed() {
        let mut app = app_with_detail_snapshot_fixture();
        app.detail_find = None;
        let buf = render_detail_snapshot_buffer(&app, 96, 20);
        let text = ftui_harness::buffer_to_text(&buf);
        assert!(
            !text.contains("/ type to find"),
            "closed state should not render find-row hint"
        );
        assert_affordance_snapshot("cassapp_baseline_detail_find_closed", &buf);
    }

    #[test]
    fn snapshot_baseline_detail_find_open_empty_query() {
        let mut app = app_with_detail_snapshot_fixture();
        app.detail_find = Some(DetailFindState::default());
        let buf = render_detail_snapshot_buffer(&app, 96, 20);
        let text = ftui_harness::buffer_to_text(&buf);
        assert!(text.contains("/ type to find"));
        assert_affordance_snapshot("cassapp_baseline_detail_find_empty_query", &buf);
    }

    #[test]
    fn snapshot_baseline_detail_find_no_match_state() {
        let mut app = app_with_detail_snapshot_fixture();
        app.detail_find = Some(DetailFindState {
            query: "definitely-no-hit".to_string(),
            matches: vec![],
            current: 0,
        });
        let buf = render_detail_snapshot_buffer(&app, 96, 20);
        let text = ftui_harness::buffer_to_text(&buf);
        assert!(text.contains("0/0"));
        assert_affordance_snapshot("cassapp_baseline_detail_find_no_matches", &buf);
    }

    #[test]
    fn snapshot_baseline_detail_find_current_match_state() {
        let mut app = app_with_detail_snapshot_fixture();
        app.detail_find = Some(DetailFindState {
            query: "needle".to_string(),
            matches: vec![2, 7, 11],
            current: 1,
        });
        let buf = render_detail_snapshot_buffer(&app, 96, 20);
        let text = ftui_harness::buffer_to_text(&buf);
        assert!(text.contains("needle"));
        assert!(text.contains("(2/3)"));
        assert_affordance_snapshot("cassapp_baseline_detail_find_current_match", &buf);
    }

    // ── Breadcrumb rendering tests (2dccg.8.2) ────────────────────────

    /// Breadcrumb line contains all expected segments.
    #[test]
    fn breadcrumb_contains_all_segments() {
        let app = app_with_hits(5);
        let s = ftui::Style::default();
        let line = app.breadcrumb_line(200, s, s, s);
        let plain: String = line.spans().iter().map(|sp| sp.content.as_ref()).collect();
        assert!(plain.contains("All agents"), "should show agent segment");
        assert!(
            plain.contains("All workspaces"),
            "should show workspace segment"
        );
        assert!(plain.contains("Any time"), "should show time segment");
        assert!(plain.contains("all sources"), "should show source segment");
    }

    /// Active filter crumbs get a different style from inactive ones.
    #[test]
    fn breadcrumb_active_filter_gets_active_style() {
        let mut app = app_with_hits(5);
        app.filters.agents.insert("codex".to_string());
        let ctx = StyleContext::from_options(crate::ui::style_system::StyleOptions::default());
        let active = ctx.style(style_system::STYLE_CRUMB_ACTIVE);
        let inactive = ctx.style(style_system::STYLE_CRUMB_INACTIVE);
        let sep = ctx.style(style_system::STYLE_CRUMB_SEPARATOR);
        let line = app.breadcrumb_line(200, active, inactive, sep);
        // First span should be agent "codex" with active style
        let agent_span = &line.spans()[0];
        assert!(
            agent_span.content.contains("codex"),
            "first crumb should be agent"
        );
        assert_eq!(
            agent_span.style.as_ref().and_then(|s| s.fg),
            active.fg,
            "active agent crumb should use active style"
        );
        // Workspace should be inactive
        let ws_span = line
            .spans()
            .iter()
            .find(|sp| sp.content.contains("All workspaces"));
        assert!(ws_span.is_some(), "workspace crumb should be present");
        if let Some(ws) = ws_span {
            assert_eq!(
                ws.style.as_ref().and_then(|s| s.fg),
                inactive.fg,
                "inactive workspace crumb should use inactive style"
            );
        }
    }

    /// Breadcrumb uses › separator between segments.
    #[test]
    fn breadcrumb_uses_separator_glyph() {
        let app = app_with_hits(5);
        let s = ftui::Style::default();
        let line = app.breadcrumb_line(200, s, s, s);
        let has_sep = line
            .spans()
            .iter()
            .any(|sp| sp.content.contains('\u{203a}'));
        assert!(has_sep, "breadcrumb should use › separator");
    }

    /// Breadcrumb renders in output buffer.
    #[test]
    fn breadcrumb_renders_in_output() {
        use ftui::render::budget::DegradationLevel;
        use ftui_harness::buffer_to_text;

        let app = app_with_hits(5);
        let text = buffer_to_text(&render_at_degradation(
            &app,
            120,
            24,
            DegradationLevel::Full,
        ));
        assert!(
            text.contains("\u{203a}") || text.contains(">"),
            "breadcrumb separator should appear in rendered output"
        );
    }

    /// Breadcrumb elides gracefully at narrow widths.
    #[test]
    fn breadcrumb_elides_at_narrow_width() {
        let app = app_with_hits(5);
        let s = ftui::Style::default();
        let line = app.breadcrumb_line(20, s, s, s);
        let total: usize = line
            .spans()
            .iter()
            .map(|sp| sp.content.chars().count())
            .sum();
        assert!(
            total <= 20,
            "breadcrumb at width=20 should fit budget, got {total}"
        );
    }

    // ── Search-surface regression snapshots (2dccg.8.6) ─────────────────

    fn search_surface_fixture_app() -> CassApp {
        let mut app = CassApp::default();
        app.results = rich_visual_fixture_hits()
            .into_iter()
            .filter(|hit| hit.title == "Large-snippet rendering edge case")
            .collect();
        assert_eq!(
            app.results.len(),
            1,
            "search-surface snapshots require a single canonical fixture row"
        );
        app.grouping_mode = ResultsGrouping::Flat;
        app.regroup_panes();
        app.active_pane = 0;
        app.query = "authentication regression".to_string();
        app.cursor_pos = 13;
        app.search_mode = SearchMode::Hybrid;
        app.match_mode = MatchMode::Prefix;
        app
    }

    #[test]
    fn snapshot_search_surface_structure_default() {
        use ftui::render::budget::DegradationLevel;

        let app = search_surface_fixture_app();
        let buf = render_at_degradation(&app, 120, 24, DegradationLevel::Full);
        let text = ftui_harness::buffer_to_text(&buf);

        assert!(
            text.contains("cass"),
            "test_id=8.6.structure.default component=search_bar action=render expected=title actual=missing"
        );
        assert!(
            text.contains("[agent:"),
            "test_id=8.6.structure.default component=pills action=render expected=agent-pill actual=missing"
        );
        assert!(
            text.contains("hits:"),
            "test_id=8.6.structure.default component=footer action=render expected=hud-lane actual=missing"
        );
        assert_affordance_snapshot("cassapp_search_surface_structure_default", &buf);
    }

    #[test]
    fn snapshot_search_surface_active_filters_hierarchy() {
        use ftui::render::budget::DegradationLevel;

        let mut app = search_surface_fixture_app();
        app.filters.agents.insert("codex".to_string());
        app.filters.workspaces.insert("/workspace/cass".to_string());
        app.filters.created_from = Some(1_700_000_000);
        app.filters.source_filter = SourceFilter::SourceId("remote-ci".to_string());
        app.pane_filter = Some("triage".to_string());

        let buf = render_at_degradation(&app, 120, 24, DegradationLevel::Full);
        let text = ftui_harness::buffer_to_text(&buf);
        assert!(
            text.contains("[agent:codex]"),
            "test_id=8.6.hierarchy.filters component=pills action=render expected=active-agent-value actual=missing"
        );
        assert!(
            text.contains("\u{203a}") || text.contains(">"),
            "test_id=8.6.hierarchy.filters component=breadcrumbs action=render expected=separator actual=missing"
        );
        assert_affordance_snapshot("cassapp_search_surface_active_filters", &buf);
    }

    #[test]
    fn snapshot_search_surface_breakpoint_matrix() {
        use ftui::render::budget::DegradationLevel;

        let app = search_surface_fixture_app();
        let cases = [
            ("cassapp_search_surface_breakpoint_narrow", 79u16),
            ("cassapp_search_surface_breakpoint_medium", 120u16),
            ("cassapp_search_surface_breakpoint_wide", 160u16),
        ];
        for (name, width) in cases {
            let buf = render_at_degradation(&app, width, 24, DegradationLevel::Full);
            let text = ftui_harness::buffer_to_text(&buf);
            assert!(
                text.contains("cass"),
                "test_id=8.6.structure.breakpoint component=search_bar action=render expected=title actual=missing width={width}"
            );
            assert_affordance_snapshot(name, &buf);
        }
    }

    #[test]
    fn snapshot_search_surface_theme_toggle_updates_chrome_immediately() {
        use ftui::render::budget::DegradationLevel;

        let mut app = search_surface_fixture_app();
        let dark_buf = render_at_degradation(&app, 120, 24, DegradationLevel::Full);
        let dark_text = ftui_harness::buffer_to_text(&dark_buf);

        let _ = app.update(CassMsg::ThemeToggled);
        let light_buf = render_at_degradation(&app, 120, 24, DegradationLevel::Full);
        let light_text = ftui_harness::buffer_to_text(&light_buf);

        assert_ne!(
            dark_text, light_text,
            "test_id=8.6.hierarchy.theme component=search-surface action=theme-toggle expected=updated-render actual=unchanged"
        );
        assert_affordance_snapshot("cassapp_search_surface_theme_dark", &dark_buf);
        assert_affordance_snapshot("cassapp_search_surface_theme_light", &light_buf);
    }

    #[test]
    fn snapshot_search_surface_theme_high_contrast() {
        use ftui::render::budget::DegradationLevel;

        let mut app = search_surface_fixture_app();
        app.theme_preset = UiThemePreset::HighContrast;
        app.theme_dark = true;
        app.style_options.preset = UiThemePreset::HighContrast;
        app.style_options.dark_mode = true;

        let buf = render_at_degradation(&app, 120, 24, DegradationLevel::Full);
        let text = ftui_harness::buffer_to_text(&buf);
        assert!(
            text.contains("cass"),
            "test_id=8.6.hierarchy.theme_hc component=search-surface action=render expected=title actual=missing"
        );
        assert_affordance_snapshot("cassapp_search_surface_theme_high_contrast", &buf);
    }

    #[test]
    fn search_surface_interaction_matrix_enter_click_escape() {
        use ftui::render::budget::DegradationLevel;

        let mut app = search_surface_fixture_app();
        app.query = "follow-up query".to_string();

        // Enter submit should push query history.
        let _ = app.update(CassMsg::QuerySubmitted);
        assert!(
            app.query_history
                .front()
                .is_some_and(|q| q == "follow-up query"),
            "test_id=8.6.interaction.enter component=search_bar action=query_submit expected=history_push actual={:?}",
            app.query_history.front()
        );

        // Left-click on an agent pill should enter agent-edit mode.
        app.filters.agents.insert("codex".to_string());
        render_at_degradation(&app, 120, 24, DegradationLevel::Full);
        let rect = app
            .last_pill_rects
            .borrow()
            .iter()
            .find_map(|(rect, pill)| (pill.label == "agent").then_some(*rect))
            .expect("test_id=8.6.interaction.pill expected=agent-pill-rect actual=none");
        let _ = app.update(CassMsg::MouseEvent {
            kind: MouseEventKind::LeftClick,
            x: rect.x,
            y: rect.y,
        });
        assert_eq!(
            app.input_mode,
            InputMode::Agent,
            "test_id=8.6.interaction.pill component=pills action=left_click expected=input_mode_agent actual={:?}",
            app.input_mode
        );

        // Esc unwind from non-query input mode should return to query mode.
        let _ = app.update(CassMsg::QuitRequested);
        assert_eq!(
            app.input_mode,
            InputMode::Query,
            "test_id=8.6.interaction.escape component=input_mode action=quit_requested expected=query_mode actual={:?}",
            app.input_mode
        );
        assert!(
            app.input_buffer.is_empty(),
            "test_id=8.6.interaction.escape component=input_buffer action=quit_requested expected=cleared actual={}",
            app.input_buffer
        );
    }

    #[test]
    fn search_bar_renders_mode_aware_title() {
        use ftui::render::budget::DegradationLevel;
        use ftui_harness::buffer_to_text;

        let modes = [
            (InputMode::Query, "<type to search>"),
            (InputMode::Agent, "[agent]"),
            (InputMode::Workspace, "[workspace]"),
            (InputMode::CreatedFrom, "[from]"),
            (InputMode::CreatedTo, "[to]"),
            (InputMode::PaneFilter, "[pane]"),
        ];

        for (mode, expected_prefix) in modes {
            let mut app = search_surface_fixture_app();
            app.input_mode = mode;
            if mode == InputMode::Query {
                app.query.clear(); // empty query shows placeholder
            }
            let buf = render_at_degradation(&app, 120, 24, DegradationLevel::Full);
            let text = buffer_to_text(&buf);
            assert!(
                text.contains(expected_prefix),
                "test_id=8.6.structure.mode_title component=search_bar mode={mode:?} expected='{expected_prefix}' actual_text_missing"
            );
        }
    }

    #[test]
    fn search_bar_cursor_position_tracks_input() {
        use ftui::render::budget::DegradationLevel;
        use ftui_harness::buffer_to_text;

        let mut app = search_surface_fixture_app();
        app.query = "hello world".to_string();
        app.cursor_pos = 5; // cursor after "hello"

        let buf = render_at_degradation(&app, 120, 24, DegradationLevel::Full);
        let text = buffer_to_text(&buf);
        // The caret character │ should appear between "hello" and " world"
        assert!(
            text.contains("hello") && text.contains("world"),
            "test_id=8.6.structure.cursor component=search_bar action=render expected=query_visible"
        );
    }

    #[test]
    fn pill_spans_use_distinct_styles_for_active_and_inactive() {
        let app = search_surface_fixture_app();
        let active_style = ftui::Style::new()
            .fg(ftui::render::cell::PackedRgba::rgba(255, 100, 100, 255))
            .bold();
        let inactive_style =
            ftui::Style::new().fg(ftui::render::cell::PackedRgba::rgba(128, 128, 128, 255));
        let label_style =
            ftui::Style::new().fg(ftui::render::cell::PackedRgba::rgba(200, 200, 200, 255));
        let sep_style = ftui::Style::new();

        let mut pills = app.filter_pills();
        // Ensure we have at least one active and one inactive pill
        pills[0].active = true;
        pills[1].active = false;

        let area = Rect::new(0, 0, 120, 1);
        let (line, _rects) = app.build_pills_row(
            area,
            &pills,
            active_style,
            inactive_style,
            label_style,
            sep_style,
        );
        let spans = line.spans();

        // Collect value spans (those that are not label or separator) —
        // active pill values should have different fg than inactive pill values
        let active_value_spans: Vec<_> = spans
            .iter()
            .filter(|sp| {
                sp.style.as_ref().and_then(|s| s.fg)
                    == Some(ftui::render::cell::PackedRgba::rgba(255, 100, 100, 255))
            })
            .collect();
        let inactive_value_spans: Vec<_> = spans
            .iter()
            .filter(|sp| {
                sp.style.as_ref().and_then(|s| s.fg)
                    == Some(ftui::render::cell::PackedRgba::rgba(128, 128, 128, 255))
            })
            .collect();
        assert!(
            !active_value_spans.is_empty(),
            "test_id=8.6.hierarchy.pill_active component=pills expected=active_styled_span actual=none"
        );
        assert!(
            !inactive_value_spans.is_empty(),
            "test_id=8.6.hierarchy.pill_inactive component=pills expected=inactive_styled_span actual=none"
        );
    }

    #[test]
    fn breadcrumb_spans_differentiate_active_inactive_segments() {
        let mut app = search_surface_fixture_app();
        app.filters.agents.insert("codex".to_string());
        // ws filter NOT set — should be inactive

        let active_style =
            ftui::Style::new().fg(ftui::render::cell::PackedRgba::rgba(0, 255, 0, 255));
        let inactive_style =
            ftui::Style::new().fg(ftui::render::cell::PackedRgba::rgba(100, 100, 100, 255));
        let sep_style =
            ftui::Style::new().fg(ftui::render::cell::PackedRgba::rgba(50, 50, 50, 255));

        let line = app.breadcrumb_line(120, active_style, inactive_style, sep_style);
        let spans = line.spans();

        // Should have multiple spans with mixed styles
        let active_count = spans
            .iter()
            .filter(|sp| {
                sp.style.as_ref().and_then(|s| s.fg)
                    == Some(ftui::render::cell::PackedRgba::rgba(0, 255, 0, 255))
            })
            .count();
        let inactive_count = spans
            .iter()
            .filter(|sp| {
                sp.style.as_ref().and_then(|s| s.fg)
                    == Some(ftui::render::cell::PackedRgba::rgba(100, 100, 100, 255))
            })
            .count();
        assert!(
            active_count >= 1,
            "test_id=8.6.hierarchy.crumb_active component=breadcrumbs expected>=1_active_span actual={active_count}"
        );
        assert!(
            inactive_count >= 1,
            "test_id=8.6.hierarchy.crumb_inactive component=breadcrumbs expected>=1_inactive_span actual={inactive_count}"
        );
    }

    #[test]
    fn footer_hud_uses_key_desc_token_pairing() {
        use ftui::render::budget::DegradationLevel;
        use ftui_harness::buffer_to_text;

        let mut app = search_surface_fixture_app();
        app.last_search_ms = Some(42);

        let buf = render_at_degradation(&app, 120, 24, DegradationLevel::Full);
        let text = buffer_to_text(&buf);

        // Footer HUD should contain key:value pairs
        assert!(
            text.contains("hits:"),
            "test_id=8.6.structure.footer_hud component=footer action=render expected=hits_lane"
        );
        assert!(
            text.contains("query:") || text.contains("hybrid"),
            "test_id=8.6.structure.footer_hud component=footer action=render expected=query_lane"
        );
        assert!(
            text.contains("lat:42ms"),
            "test_id=8.6.structure.footer_hud component=footer action=render expected=perf_lane"
        );
    }

    #[test]
    fn footer_hud_line_produces_key_style_per_lane() {
        let key_style =
            ftui::Style::new().fg(ftui::render::cell::PackedRgba::rgba(200, 200, 255, 255));
        let sep_style =
            ftui::Style::new().fg(ftui::render::cell::PackedRgba::rgba(80, 80, 80, 255));
        let value_style =
            ftui::Style::new().fg(ftui::render::cell::PackedRgba::rgba(100, 200, 100, 255));

        let lanes = vec![
            FooterHudLane {
                key: "hits",
                value: "42".to_string(),
                value_style,
            },
            FooterHudLane {
                key: "query",
                value: "hybrid / prefix".to_string(),
                value_style,
            },
        ];

        let line = build_footer_hud_line(&lanes, 120, key_style, sep_style);
        let spans = line.spans();

        // Key spans should use key_style
        let key_spans: Vec<_> = spans
            .iter()
            .filter(|sp| {
                sp.style.as_ref().and_then(|s| s.fg)
                    == Some(ftui::render::cell::PackedRgba::rgba(200, 200, 255, 255))
            })
            .collect();
        assert!(
            key_spans.len() >= 2,
            "test_id=8.6.structure.footer_spans component=footer expected>=2_key_styled_spans actual={}",
            key_spans.len()
        );
        // Separator spans (colons, dividers) should use sep_style
        let sep_spans: Vec<_> = spans
            .iter()
            .filter(|sp| {
                sp.style.as_ref().and_then(|s| s.fg)
                    == Some(ftui::render::cell::PackedRgba::rgba(80, 80, 80, 255))
            })
            .collect();
        assert!(
            !sep_spans.is_empty(),
            "test_id=8.6.structure.footer_spans component=footer expected=sep_styled_spans actual=none"
        );
    }

    #[test]
    fn fkey_cycling_enters_filter_input_modes() {
        use ftui::Model;

        let mut app = search_surface_fixture_app();
        assert_eq!(app.input_mode, InputMode::Query);

        // F3 → Agent
        let _ = app.update(CassMsg::InputModeEntered(InputMode::Agent));
        assert_eq!(
            app.input_mode,
            InputMode::Agent,
            "test_id=8.6.interaction.fkey component=input_mode action=f3 expected=agent"
        );

        // Cancel, then F4 → Workspace
        let _ = app.update(CassMsg::InputModeCancelled);
        assert_eq!(app.input_mode, InputMode::Query);
        let _ = app.update(CassMsg::InputModeEntered(InputMode::Workspace));
        assert_eq!(
            app.input_mode,
            InputMode::Workspace,
            "test_id=8.6.interaction.fkey component=input_mode action=f4 expected=workspace"
        );

        // Cancel, then F5 → CreatedFrom
        let _ = app.update(CassMsg::InputModeCancelled);
        let _ = app.update(CassMsg::InputModeEntered(InputMode::CreatedFrom));
        assert_eq!(
            app.input_mode,
            InputMode::CreatedFrom,
            "test_id=8.6.interaction.fkey component=input_mode action=f5 expected=created_from"
        );

        // Cancel, then F6 → CreatedTo
        let _ = app.update(CassMsg::InputModeCancelled);
        let _ = app.update(CassMsg::InputModeEntered(InputMode::CreatedTo));
        assert_eq!(
            app.input_mode,
            InputMode::CreatedTo,
            "test_id=8.6.interaction.fkey component=input_mode action=f6 expected=created_to"
        );
    }

    #[test]
    fn input_mode_apply_sets_filter_and_returns_to_query() {
        use ftui::Model;

        let mut app = search_surface_fixture_app();

        // Enter agent mode, type buffer, apply
        let _ = app.update(CassMsg::InputModeEntered(InputMode::Agent));
        app.input_buffer = "gemini, codex".to_string();
        let _ = app.update(CassMsg::InputModeApplied);

        assert_eq!(
            app.input_mode,
            InputMode::Query,
            "test_id=8.6.interaction.apply component=input_mode expected=query_after_apply"
        );
        assert!(
            app.input_buffer.is_empty(),
            "test_id=8.6.interaction.apply component=input_buffer expected=cleared_after_apply"
        );
    }

    #[test]
    fn footer_contextual_hints_stable_across_themes() {
        use ftui::Model;

        let mut app = search_surface_fixture_app();

        // Dark theme hints
        let dark_hints = app.build_contextual_footer_hints(120);

        // Toggle to light
        let _ = app.update(CassMsg::ThemeToggled);
        let light_hints = app.build_contextual_footer_hints(120);

        // Hints should contain the same structural key=action pairs
        // (same keys/descriptions regardless of theme)
        assert_eq!(
            dark_hints, light_hints,
            "test_id=8.6.hierarchy.footer_hints component=footer action=theme_toggle expected=same_hint_text"
        );
    }

    #[test]
    fn search_bar_query_inset_visually_distinct() {
        use ftui::render::budget::DegradationLevel;

        // The search bar uses STYLE_TAB_ACTIVE/INACTIVE for its background.
        // Verify that the rendered buffer at the search bar row differs from adjacent rows.
        let app = search_surface_fixture_app();
        let _buf = render_at_degradation(&app, 120, 24, DegradationLevel::Full);

        // Search bar area is stored — verify it was rendered
        let search_area = app.last_search_bar_area.borrow();
        assert!(
            search_area.is_some(),
            "test_id=8.6.hierarchy.search_inset component=search_bar expected=area_recorded actual=none"
        );
    }

    #[test]
    fn escape_unwind_clears_pane_filter() {
        use ftui::Model;

        let mut app = search_surface_fixture_app();
        app.pane_filter = Some("test-filter".to_string());
        app.input_mode = InputMode::PaneFilter;

        // First Esc: should clear pane filter
        let _ = app.update(CassMsg::QuitRequested);
        assert!(
            app.pane_filter.is_none(),
            "test_id=8.6.interaction.escape_pane component=pane_filter expected=cleared"
        );
        assert_eq!(
            app.input_mode,
            InputMode::Query,
            "test_id=8.6.interaction.escape_pane component=input_mode expected=query"
        );
    }

    #[test]
    fn escape_unwind_clears_selection_before_quit() {
        use ftui::Model;

        let mut app = search_surface_fixture_app();
        app.selected.insert(SelectedHitKey {
            source_id: "local".into(),
            source_path: "/path/0".into(),
            line_number: None,
            content_hash: 0,
        });
        app.selected.insert(SelectedHitKey {
            source_id: "local".into(),
            source_path: "/path/1".into(),
            line_number: None,
            content_hash: 1,
        });

        // Esc should clear selection first, not quit
        let cmd = app.update(CassMsg::QuitRequested);
        assert!(
            app.selected.is_empty(),
            "test_id=8.6.interaction.escape_selection component=selection expected=cleared"
        );
        assert!(
            !matches!(cmd, ftui::Cmd::Quit),
            "test_id=8.6.interaction.escape_selection expected=no_quit_yet"
        );
    }

    #[test]
    fn right_click_pill_clears_filter_and_triggers_search() {
        use ftui::Model;
        use ftui::render::budget::DegradationLevel;

        let mut app = search_surface_fixture_app();
        app.filters.workspaces.insert("/test/ws".to_string());
        render_at_degradation(&app, 120, 24, DegradationLevel::Full);

        let rect = app
            .last_pill_rects
            .borrow()
            .iter()
            .find_map(|(rect, pill)| (pill.label == "ws").then_some(*rect))
            .expect("test_id=8.6.interaction.right_click expected=ws_pill_rect");

        let _ = app.update(CassMsg::MouseEvent {
            kind: MouseEventKind::RightClick,
            x: rect.x,
            y: rect.y,
        });

        assert!(
            app.filters.workspaces.is_empty(),
            "test_id=8.6.interaction.right_click component=ws_filter expected=cleared"
        );
        assert!(
            app.search_dirty_since.is_some(),
            "test_id=8.6.interaction.right_click component=search expected=dirty_for_debounce"
        );
    }

    #[test]
    fn search_surface_degradation_matrix() {
        use ftui::render::budget::DegradationLevel;
        use ftui_harness::buffer_to_text;

        let app = search_surface_fixture_app();
        let levels = [
            DegradationLevel::Full,
            DegradationLevel::SimpleBorders,
            DegradationLevel::NoStyling,
            DegradationLevel::EssentialOnly,
        ];

        for level in levels {
            let buf = render_at_degradation(&app, 120, 24, level);
            let text = buffer_to_text(&buf);
            // Core structure should survive all degradation levels
            assert!(
                text.contains("cass"),
                "test_id=8.6.structure.degradation component=search_bar level={level:?} expected=title_present"
            );
        }
    }

    // =====================================================================
    // 2dccg.6.3 — Cross-theme × cross-degradation visual regression matrix
    // =====================================================================

    #[test]
    fn cross_theme_degradation_matrix_results_pane() {
        use crate::ui::style_system::UiThemePreset;
        use ftui::render::budget::DegradationLevel;
        use ftui_harness::buffer_to_text;

        // Compact matrix: 3 representative themes × 2 reliable degradation tiers
        // Full + SimpleBorders: full hierarchy must be present
        // EssentialOnly: too aggressive for content assertions — tested as no-panic only
        let themes = [
            UiThemePreset::Dark,
            UiThemePreset::Light,
            UiThemePreset::HighContrast,
        ];

        for preset in themes {
            for level in [DegradationLevel::Full, DegradationLevel::SimpleBorders] {
                let mut app = app_with_hits(8);
                app.theme_preset = preset;
                app.theme_dark = !matches!(preset, UiThemePreset::Light);
                app.style_options.preset = preset;
                app.style_options.dark_mode = app.theme_dark;

                let buf = render_at_degradation(&app, 120, 24, level);
                let text = buffer_to_text(&buf);

                // Core hierarchy must survive Full and SimpleBorders
                assert!(
                    text.contains("Results"),
                    "test_id=6.3.matrix.{:?}.{:?} component=results-title expected=present",
                    preset,
                    level
                );
                assert!(
                    text.contains("Hit 0"),
                    "test_id=6.3.matrix.{:?}.{:?} component=first-result expected=present",
                    preset,
                    level
                );
                assert!(
                    text.contains("[local]"),
                    "test_id=6.3.matrix.{:?}.{:?} component=source-badge expected=local-present",
                    preset,
                    level
                );
            }
            // EssentialOnly: no-panic rendering (chrome may be stripped)
            {
                let mut app = app_with_hits(8);
                app.theme_preset = preset;
                app.theme_dark = !matches!(preset, UiThemePreset::Light);
                app.style_options.preset = preset;
                app.style_options.dark_mode = app.theme_dark;
                let _buf = render_at_degradation(&app, 120, 24, DegradationLevel::EssentialOnly);
            }
        }
    }

    #[test]
    fn cross_theme_degradation_matrix_search_surface() {
        use crate::ui::style_system::UiThemePreset;
        use ftui::render::budget::DegradationLevel;
        use ftui_harness::buffer_to_text;

        let themes = [
            UiThemePreset::Dark,
            UiThemePreset::Light,
            UiThemePreset::HighContrast,
        ];

        for preset in themes {
            for level in [DegradationLevel::Full, DegradationLevel::SimpleBorders] {
                let mut app = search_surface_fixture_app();
                app.theme_preset = preset;
                app.theme_dark = !matches!(preset, UiThemePreset::Light);
                app.style_options.preset = preset;
                app.style_options.dark_mode = app.theme_dark;

                let buf = render_at_degradation(&app, 120, 24, level);
                let text = buffer_to_text(&buf);

                assert!(
                    text.contains("cass"),
                    "test_id=6.3.matrix.search.{:?}.{:?} component=search-bar expected=title",
                    preset,
                    level
                );
            }
            // EssentialOnly: no-panic only
            {
                let mut app = search_surface_fixture_app();
                app.theme_preset = preset;
                app.theme_dark = !matches!(preset, UiThemePreset::Light);
                app.style_options.preset = preset;
                app.style_options.dark_mode = app.theme_dark;
                let _buf = render_at_degradation(&app, 120, 24, DegradationLevel::EssentialOnly);
            }
        }
    }

    #[test]
    fn cross_theme_degradation_matrix_full_preset_sweep() {
        use crate::ui::style_system::UiThemePreset;
        use ftui::render::budget::DegradationLevel;
        use ftui_harness::buffer_to_text;

        // Exhaustive: all 6 themes at Full degradation — ensures no theme panics
        for preset in UiThemePreset::all() {
            let mut app = app_with_hits(5);
            app.theme_preset = preset;
            app.theme_dark = !matches!(preset, UiThemePreset::Light);
            app.style_options.preset = preset;
            app.style_options.dark_mode = app.theme_dark;

            let buf = render_at_degradation(&app, 120, 24, DegradationLevel::Full);
            let text = buffer_to_text(&buf);

            assert!(
                text.contains("Results"),
                "test_id=6.3.sweep.{:?} component=results-title expected=present",
                preset
            );
        }
    }

    #[test]
    fn cross_theme_degradation_light_specific_regressions() {
        use crate::ui::style_system::UiThemePreset;
        use ftui::render::budget::DegradationLevel;
        use ftui_harness::buffer_to_text;

        // Light theme at degraded levels — historically where regressions hide
        let mut app = app_with_hits(8);
        app.theme_preset = UiThemePreset::Light;
        app.theme_dark = false;
        app.style_options.preset = UiThemePreset::Light;
        app.style_options.dark_mode = false;

        for level in [
            DegradationLevel::Full,
            DegradationLevel::SimpleBorders,
            DegradationLevel::NoStyling,
        ] {
            let buf = render_at_degradation(&app, 120, 24, level);
            let text = buffer_to_text(&buf);

            // Structural content must survive Full/SimpleBorders/NoStyling
            assert!(
                text.contains("Results"),
                "test_id=6.3.light.{:?} component=results-title expected=present",
                level
            );
            assert!(
                text.contains("Hit 0"),
                "test_id=6.3.light.{:?} component=first-hit expected=present",
                level
            );
        }
        // EssentialOnly: no-panic only (too aggressive for content assertions)
        let _buf = render_at_degradation(&app, 120, 24, DegradationLevel::EssentialOnly);
    }

    #[test]
    fn cross_theme_degradation_high_contrast_preserves_hierarchy() {
        use crate::ui::style_system::UiThemePreset;
        use ftui::render::budget::DegradationLevel;
        use ftui_harness::buffer_to_text;

        // HighContrast at degraded — must preserve accessibility-critical content
        let mut app = app_with_hits(8);
        app.theme_preset = UiThemePreset::HighContrast;
        app.theme_dark = true;
        app.style_options.preset = UiThemePreset::HighContrast;
        app.style_options.dark_mode = true;

        for level in [DegradationLevel::Full, DegradationLevel::SimpleBorders] {
            let buf = render_at_degradation(&app, 120, 24, level);
            let text = buffer_to_text(&buf);

            assert!(
                text.contains("Results"),
                "test_id=6.3.hc.{:?} component=results-title expected=present",
                level
            );
            assert!(
                text.contains("[local]"),
                "test_id=6.3.hc.{:?} component=source-badge expected=present",
                level
            );
        }
        // EssentialOnly: no-panic only
        let _buf = render_at_degradation(&app, 120, 24, DegradationLevel::EssentialOnly);
    }

    // =====================================================================
    // 2dccg.11.3 — Deterministic TUI E2E scenario playback (unit-test level)
    // =====================================================================

    /// Replay a sequence of CassMsg events and verify rendering at each step.
    fn replay_scenario(app: &mut CassApp, steps: Vec<(CassMsg, &str)>, width: u16, height: u16) {
        use ftui::render::budget::DegradationLevel;
        use ftui_harness::buffer_to_text;

        for (i, (msg, assertion_text)) in steps.into_iter().enumerate() {
            let _ = app.update(msg);
            let buf = render_at_degradation(app, width, height, DegradationLevel::Full);
            let text = buffer_to_text(&buf);
            if !assertion_text.is_empty() {
                assert!(
                    text.contains(assertion_text),
                    "scenario step {i}: expected '{assertion_text}' in rendered output"
                );
            }
        }
    }

    #[test]
    fn e2e_scenario_search_select_detail() {
        let mut app = app_with_hits(10);

        // Step 1: Initial state — results visible
        replay_scenario(
            &mut app,
            vec![(CassMsg::SearchRequested, "Results")],
            120,
            24,
        );

        // Step 2: Move selection down
        let _ = app.update(CassMsg::SelectionMoved { delta: 2 });
        assert_eq!(app.panes[0].selected, 2);

        // Step 3: Open detail modal — the handler will set show_detail_modal
        // and push the focus trap since we have a selected hit at index 2.
        let _ = app.update(CassMsg::DetailOpened);
        assert!(app.show_detail_modal, "detail modal should be open");
        assert_eq!(app.focused_region(), FocusRegion::Detail);
    }

    #[test]
    fn e2e_scenario_theme_switch_mid_session() {
        use ftui::render::budget::DegradationLevel;
        use ftui_harness::buffer_to_text;

        let mut app = app_with_hits(5);

        // Render in dark theme
        let dark_text = buffer_to_text(&render_at_degradation(
            &app,
            120,
            24,
            DegradationLevel::Full,
        ));
        assert!(dark_text.contains("Results"));

        // Toggle theme
        let _ = app.update(CassMsg::ThemeToggled);

        // Render in light theme — must still show results
        let light_text = buffer_to_text(&render_at_degradation(
            &app,
            120,
            24,
            DegradationLevel::Full,
        ));
        assert!(light_text.contains("Results"));

        // Selection should be preserved
        assert_eq!(app.panes[0].selected, 0);
    }

    #[test]
    fn e2e_scenario_density_cycling_during_browsing() {
        use ftui::render::budget::DegradationLevel;

        let mut app = app_with_hits(20);

        // Navigate to middle of results
        for _ in 0..8 {
            let _ = app.update(CassMsg::SelectionMoved { delta: 1 });
        }
        assert_eq!(app.panes[0].selected, 8);

        // Cycle through all density modes while rendering
        for _ in 0..3 {
            let _ = app.update(CassMsg::DensityModeCycled);
            let _buf = render_at_degradation(&app, 120, 24, DegradationLevel::Full);
            // Must not panic; selection must be preserved
            assert_eq!(app.panes[0].selected, 8);
        }
    }

    #[test]
    fn e2e_scenario_palette_search_execute() {
        let mut app = CassApp::default();

        // Open palette
        let _ = app.update(CassMsg::PaletteOpened);
        assert!(app.command_palette.is_visible());

        // Close palette via PaletteClosed
        let _ = app.update(CassMsg::PaletteClosed);
        assert!(
            !app.command_palette.is_visible(),
            "palette should close after PaletteClosed"
        );
    }

    #[test]
    fn e2e_scenario_help_overlay_lifecycle() {
        use ftui::render::budget::DegradationLevel;
        use ftui_harness::buffer_to_text;

        let mut app = app_with_hits(5);

        // Open help
        let _ = app.update(CassMsg::HelpToggled);
        assert!(app.show_help);

        let text = buffer_to_text(&render_at_degradation(
            &app,
            120,
            24,
            DegradationLevel::Full,
        ));
        // Help overlay should show key bindings
        assert!(
            text.contains("help") || text.contains("Help") || text.contains("Key"),
            "help overlay should display key info"
        );

        // Scroll help
        let _ = app.update(CassMsg::HelpScrolled { delta: 3 });
        assert_eq!(app.help_scroll, 3);

        // Close help
        let _ = app.update(CassMsg::HelpToggled);
        assert!(!app.show_help);
    }

    #[test]
    fn e2e_scenarios_complete_under_1s() {
        // Meta-test: verify all scenario playbacks are fast enough
        let start = std::time::Instant::now();

        // Run a representative scenario
        let mut app = app_with_hits(20);
        for _ in 0..10 {
            let _ = app.update(CassMsg::SelectionMoved { delta: 1 });
        }
        let _ = app.update(CassMsg::ThemeToggled);
        let _ = app.update(CassMsg::DensityModeCycled);
        let _ = app.update(CassMsg::HelpToggled);
        let _ = app.update(CassMsg::HelpToggled);
        render_at_degradation(&app, 120, 24, ftui::render::budget::DegradationLevel::Full);

        let elapsed = start.elapsed();
        assert!(
            elapsed.as_millis() < 1000,
            "scenario playback should complete under 1s, took {:?}",
            elapsed
        );
    }

    // =====================================================================
    // 2dccg.11.7 — E2E stress scenarios
    // =====================================================================

    /// Stress: render 500-hit dataset at all degradation levels without panic.
    #[test]
    fn stress_large_dataset_all_degradation_levels() {
        use ftui::render::budget::DegradationLevel;

        let mut app = app_with_hits(500);
        let _ = app.update(CassMsg::SearchRequested);

        let levels = [
            DegradationLevel::Full,
            DegradationLevel::SimpleBorders,
            DegradationLevel::NoStyling,
            DegradationLevel::EssentialOnly,
            DegradationLevel::Skeleton,
        ];

        for level in &levels {
            let _buf = render_at_degradation(&app, 120, 40, *level);
        }

        // Scroll to bottom and render again at all levels
        for _ in 0..250 {
            let _ = app.update(CassMsg::SelectionMoved { delta: 1 });
        }
        for level in &levels {
            let _buf = render_at_degradation(&app, 120, 40, *level);
        }
    }

    /// Stress: rapid theme toggling 20× with render after each toggle.
    #[test]
    fn stress_rapid_theme_switching_with_render() {
        use ftui::render::budget::DegradationLevel;
        use ftui_harness::buffer_to_text;

        let mut app = app_with_hits(50);
        let _ = app.update(CassMsg::SearchRequested);

        for i in 0..20 {
            let _ = app.update(CassMsg::ThemeToggled);
            let buf = render_at_degradation(&app, 120, 24, DegradationLevel::Full);
            let text = buffer_to_text(&buf);
            assert!(
                !text.is_empty(),
                "rendered text should not be empty after theme toggle {i}"
            );
        }

        // After even number of toggles, should be back to original dark mode
        assert!(app.theme_dark, "20 toggles should return to dark theme");
    }

    /// Stress: all degradation levels × all density modes render without panic.
    #[test]
    fn stress_degradation_cross_density_matrix() {
        use ftui::render::budget::DegradationLevel;

        let mut app = app_with_hits(30);
        let _ = app.update(CassMsg::SearchRequested);

        let levels = [
            DegradationLevel::Full,
            DegradationLevel::SimpleBorders,
            DegradationLevel::NoStyling,
            DegradationLevel::EssentialOnly,
            DegradationLevel::Skeleton,
        ];

        // 3 density modes × 5 degradation levels = 15 combos
        for _ in 0..3 {
            for level in &levels {
                let _buf = render_at_degradation(&app, 120, 24, *level);
            }
            let _ = app.update(CassMsg::DensityModeCycled);
        }
    }

    /// Stress: responsive width sweep from 40 to 200 columns at all breakpoints.
    #[test]
    fn stress_responsive_width_sweep() {
        use ftui::render::budget::DegradationLevel;

        let mut app = app_with_hits(20);
        let _ = app.update(CassMsg::SearchRequested);

        // Sweep from narrow to ultra-wide
        for width in (40..=200).step_by(10) {
            let _buf = render_at_degradation(&app, width, 24, DegradationLevel::Full);
        }

        // Also sweep height
        for height in (8..=60).step_by(4) {
            let _buf = render_at_degradation(&app, 120, height, DegradationLevel::Full);
        }
    }

    /// Stress: interleaved theme + density + selection + degradation transitions.
    #[test]
    fn stress_interleaved_transitions() {
        use ftui::render::budget::DegradationLevel;

        let mut app = app_with_hits(100);
        let _ = app.update(CassMsg::SearchRequested);

        let levels = [
            DegradationLevel::Full,
            DegradationLevel::SimpleBorders,
            DegradationLevel::EssentialOnly,
        ];

        for round in 0..10 {
            // Move selection
            let _ = app.update(CassMsg::SelectionMoved { delta: 5 });
            // Toggle theme
            let _ = app.update(CassMsg::ThemeToggled);
            // Cycle density
            let _ = app.update(CassMsg::DensityModeCycled);
            // Render at a degradation level
            let level = levels[round % levels.len()];
            let _buf = render_at_degradation(&app, 120, 24, level);
        }
    }

    /// Stress: scroll + find behavior with help overlay toggling.
    #[test]
    fn stress_scroll_with_help_overlay() {
        use ftui::render::budget::DegradationLevel;

        let mut app = app_with_hits(100);
        let _ = app.update(CassMsg::SearchRequested);

        // Scroll through results with help toggled on/off
        for i in 0..50 {
            let _ = app.update(CassMsg::SelectionMoved { delta: 1 });
            if i % 7 == 0 {
                let _ = app.update(CassMsg::HelpToggled);
                let _buf = render_at_degradation(&app, 120, 24, DegradationLevel::Full);
                let _ = app.update(CassMsg::HelpToggled);
            }
            let _buf = render_at_degradation(&app, 120, 24, DegradationLevel::Full);
        }
    }

    /// Stress: large dataset with long content hits renders without panic.
    #[test]
    fn stress_long_content_hits() {
        use ftui::render::budget::DegradationLevel;

        let mut app = CassApp::default();
        let hits: Vec<SearchHit> = (0..100)
            .map(|i| SearchHit {
                title: format!("Long hit {i} — {}", "x".repeat(200)),
                snippet: "word ".repeat(500),
                content: "line\n".repeat(1000),
                content_hash: i,
                score: 1.0 - (i as f32 * 0.005),
                agent: "claude_code".into(),
                source_path: format!("/very/deep/nested/path/to/file_{i}.rs"),
                workspace: "/workspace".into(),
                workspace_original: None,
                created_at: None,
                line_number: Some(i as usize),
                match_type: Default::default(),
                source_id: "local".into(),
                origin_kind: "local".into(),
                origin_host: None,
            })
            .collect();
        app.panes.push(AgentPane {
            agent: "claude_code".into(),
            total_count: hits.len(),
            hits,
            selected: 0,
        });
        app.active_pane = 0;

        // Render at multiple sizes
        for width in [60, 120, 200] {
            let _buf = render_at_degradation(&app, width, 24, DegradationLevel::Full);
        }

        // Scroll to middle and render
        for _ in 0..50 {
            let _ = app.update(CassMsg::SelectionMoved { delta: 1 });
        }
        let _buf = render_at_degradation(&app, 120, 24, DegradationLevel::Full);
    }

    /// Stress: full suite completes under 3 seconds.
    #[test]
    fn stress_suite_completes_under_3s() {
        let start = std::time::Instant::now();

        // Run representative stress operations
        let mut app = app_with_hits(200);
        let _ = app.update(CassMsg::SearchRequested);

        for _ in 0..100 {
            let _ = app.update(CassMsg::SelectionMoved { delta: 1 });
        }
        for _ in 0..10 {
            let _ = app.update(CassMsg::ThemeToggled);
            let _ = app.update(CassMsg::DensityModeCycled);
        }
        for width in (40..=200).step_by(20) {
            render_at_degradation(
                &app,
                width,
                24,
                ftui::render::budget::DegradationLevel::Full,
            );
        }

        let elapsed = start.elapsed();
        assert!(
            elapsed.as_millis() < 3000,
            "stress suite should complete under 3s, took {:?}",
            elapsed
        );
    }

    // =====================================================================
    // 2dccg.7.1 — Screenshot capture tests (text-based visual evidence)
    // =====================================================================

    /// Generate text-based screenshot captures demonstrating ftui visual quality.
    /// Writes captures to test-results/screenshots/ for evidence bundle consumption.
    #[test]
    fn capture_ftui_screenshots() {
        use ftui::render::budget::DegradationLevel;
        use ftui_harness::buffer_to_text;

        let out_dir = std::path::Path::new("test-results/screenshots");
        std::fs::create_dir_all(out_dir).expect("create screenshots dir");

        let mut app = app_with_rich_visual_fixture();
        let _ = app.update(CassMsg::SearchRequested);

        // Capture 1: Search results (dark theme, 120×24)
        let buf = render_at_degradation(&app, 120, 24, DegradationLevel::Full);
        let text = buffer_to_text(&buf);
        std::fs::write(out_dir.join("01_search_results_dark_120x24.txt"), &text)
            .expect("write screenshot");
        assert!(!text.is_empty());

        // Capture 2: Light theme
        let _ = app.update(CassMsg::ThemeToggled);
        let buf = render_at_degradation(&app, 120, 24, DegradationLevel::Full);
        let text = buffer_to_text(&buf);
        std::fs::write(out_dir.join("02_search_results_light_120x24.txt"), &text)
            .expect("write screenshot");
        let _ = app.update(CassMsg::ThemeToggled); // back to dark

        // Capture 3: Cozy density
        let _ = app.update(CassMsg::DensityModeCycled); // → Cozy
        let buf = render_at_degradation(&app, 120, 30, DegradationLevel::Full);
        let text = buffer_to_text(&buf);
        std::fs::write(out_dir.join("03_cozy_density_120x30.txt"), &text)
            .expect("write screenshot");

        // Capture 4: Spacious density
        let _ = app.update(CassMsg::DensityModeCycled); // → Spacious
        let buf = render_at_degradation(&app, 140, 35, DegradationLevel::Full);
        let text = buffer_to_text(&buf);
        std::fs::write(out_dir.join("04_spacious_density_140x35.txt"), &text)
            .expect("write screenshot");
        let _ = app.update(CassMsg::DensityModeCycled); // → Compact

        // Capture 5: Help overlay
        let _ = app.update(CassMsg::HelpToggled);
        let buf = render_at_degradation(&app, 120, 24, DegradationLevel::Full);
        let text = buffer_to_text(&buf);
        std::fs::write(out_dir.join("05_help_overlay_120x24.txt"), &text)
            .expect("write screenshot");
        let _ = app.update(CassMsg::HelpToggled);

        // Capture 6: Wide terminal (200 cols)
        let buf = render_at_degradation(&app, 200, 40, DegradationLevel::Full);
        let text = buffer_to_text(&buf);
        std::fs::write(out_dir.join("06_wide_terminal_200x40.txt"), &text)
            .expect("write screenshot");

        // Capture 7: Narrow terminal (60 cols)
        let buf = render_at_degradation(&app, 60, 24, DegradationLevel::Full);
        let text = buffer_to_text(&buf);
        std::fs::write(out_dir.join("07_narrow_terminal_60x24.txt"), &text)
            .expect("write screenshot");

        // Capture 8: SimpleBorders degradation
        let buf = render_at_degradation(&app, 120, 24, DegradationLevel::SimpleBorders);
        let text = buffer_to_text(&buf);
        std::fs::write(out_dir.join("08_simple_borders_120x24.txt"), &text)
            .expect("write screenshot");

        // Write manifest
        let manifest = format!(
            concat!(
                "# Screenshot Captures\n\n",
                "Generated: {}\n",
                "Commit: {}\n\n",
                "| File | Description |\n",
                "|------|-------------|\n",
                "| 01_search_results_dark_120x24.txt | Dark theme, search results, 120×24 |\n",
                "| 02_search_results_light_120x24.txt | Light theme, search results, 120×24 |\n",
                "| 03_cozy_density_120x30.txt | Cozy density mode, 120×30 |\n",
                "| 04_spacious_density_140x35.txt | Spacious density mode, 140×35 |\n",
                "| 05_help_overlay_120x24.txt | Help overlay visible, 120×24 |\n",
                "| 06_wide_terminal_200x40.txt | Ultra-wide terminal, 200×40 |\n",
                "| 07_narrow_terminal_60x24.txt | Narrow terminal, 60×24 |\n",
                "| 08_simple_borders_120x24.txt | SimpleBorders degradation, 120×24 |\n",
            ),
            chrono::Utc::now().format("%Y-%m-%d %H:%M:%S UTC"),
            option_env!("GIT_SHA").unwrap_or("local"),
        );
        std::fs::write(out_dir.join("MANIFEST.md"), manifest).expect("write manifest");
    }
}
